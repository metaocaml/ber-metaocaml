(*
  This file is to post-process the Typedtree built by the type checker
  before it is passed to the code generator -- to get rid of bracket and
  escape. The main function is trx_structure, which initiates the
  traversal and transforms every found expression with trx_exp. The
  real transformation is done by trx_bracket.

  For example,
     <succ 1> 
  gets transformed to 
     mkApp <succ> <1> 
  and eventually to
     mkApp (mkIdent "succ") (mkConst 1)
  One may say that we `push the brackets inside'.  We replace brackets
  with calls to functions that will construct, at run-time, a
  Parsetree, which is the representation of values of the code type.

  Generally, the Parsetree is constructed when the program is run.
  In some cases we can construct the Parsetree at compile time,
  that is, when this trx.ml is run. Constants like <1> is such a case.
  If we see <1>, or, in terms of trees,
      Texp_bracket (Texp_constant (Constant_int 1))
  we can immediately construct the Parsetree:
      Pexp_constant (Constant_int 1)
  After we construct the Parsetree at compile time, we use CSP to
  pass it over to run-time. At run-time, we merely use the compiled constant.
  This mechanism of building Parsetree at compile-time whenever possible
  is one of the large differences from the previous versions of MetaOCaml.

  Future-stage Bindings.
  Future-stage bindings are introduced by patterns in let, fun,
  match, try and for forms. Global bindings are always at present-stage.
  Since local modules in brackets are not allowed, all future bindings are
  unqualified (i.e., simple names, without the module path).
  The principal rule of translating binding forms is
     <fun x -> e> ---> let x = gensym "x" in mkLAM x <e>
  Emphatically, gensym cannot be generated at compile time!
  Reason: consider the recursive invocation:
     let rec f z = <fun y -> ~( ... f 1 ... )>

  Thus, at run-time, we generate new names for bound variables and
  use the OCaml's evaluator (the `run-time') to substitute these
  new names in <e>. Therefore, a future-stage bound variable after
  the translation becomes a present-stage bound variable,
  but at a different type: string loc. We use string loc rather
  than Longident.t loc since all, at present, future-stage bindings
  are simple names.

  We now check for scope extrusion: we enforce the region discipline
  for generated identifiers. To make it easier to impose checks,
  the translation rule is modified as follows
     <fun x -> e> ---> with_binding_region "x" (fun x -> mkLAM x <e>)
  For more complicated binding patterns, we iterate
     <fun (x1,x2) -> e> ---> 
       with_binding_region "x1" (fun x1 ->
       with_binding_region "x2" (fun x2 ->
         mkLAM (x1,x2) <e>))
  etc.

  Here are the main patterns of scope extrusion
  let r = <0> in 
  <fun x -> ~(r := <x + 1>; <()>)>

  let r = <0> in
  <fun x -> .~(<fun x -> ~(let v = <x> in r := <fun x -> ~v>; <()>)>; !r)>

  exception E of int code
  try <fun x -> ~(raise (E <x>)> with E x -> x
  (actually we need a local polymorphic exception, but the idea is the same)

  and similar using control effects.

  The most obvious method of detecting the scope extrusion is traversing
  the generated code looking for unbound identifiers. We can do
  such a check when we are about to show or run the code, or
  about to splice (in the latter case, we have to maintain
  the dynamic environment of gensym'ed names generated by 
  with_binding_region). However, reporting the scope
  extrusion upon printing or running the code is reporting it too
  late. Doing the check on each escape (since only splices can incorporate
  scope-extruded code) means many repeated traversals of the generated
  code.

  We use a different method: we mark each piece of the generated code
  with the `timestamp' of the latest free variable the code contains.
  The partial order of free variables is the partial order of their
  regions (nesting of with_binding_region calls).
  If the timestamp is missing, the code is closed.
  The function with_binding_region generates timestamps and
  this function also checks that the generated binding form is
  timestamped with exactly the timestamp of that 
  particular with_binding_region (or the timestamp is missing).
  After the checks, with_binding_region adjusts the time stamp
  to that of the parent with_binding_region function.
  Every code building function ( build_* ) checks to see that the timestamps
  of incorporated fragments correspond to the timestamps of currently
  alive variables.

  Generally speaking, a single timestamp does not suffice. We should maintain
  the full list of free variables for each piece of code. The AST building
  functions will merge the lists; with_binding_region will check the list
  and remove the gensym that with_binding_region has created.
  A single timestamp is a sound approximation. It presupposes that a code
  that contains a free variable also contains all earlier free variables.
  Therefore, the safe code
    let r = .<0> in 
    let _ = .<fun x -> .~(r := .<fun y -> y>.; !r)>. in !r
  will be flagged as scope-extruding. We go with the single timestamp
  approximation for now as being simper.

  Alas Parsetree doesn't have a dedicated field for marking expressions
  with timestamps. Therefore, in an ad hoc and hacking way re-purpose
  the Pexp_setinstvar node. To designate that a code expression 'e'
  has a free variable 'x : string loc' we create a wrapper node
   {pexp_loc = timestamp_loc;
    pexp_desc = Pexp_setinstvar (x,e)}
  We distinguish such special timestamp nodes by their unique pexp_loc,
  being physically equal to timestamp_loc. Although a hack, this
  convention avoids modifying the Parsetree data structure and makes it
  easy to add, check and remove the timestamp.

This file is based on trx.ml from the original MetaOCaml, but it is
completely re-written from scratch and has many comments. The
traversal algorithm, the way of compiling Parsetree builders, dealing
with CSP and many other algorithms are all different.

*)

open Parsetree
open Asttypes
open Misc
open Typedtree
open Types

(*
XXX check all Obj.repr, that CSP really builds annotated tree
XXX Check Parsetree.expression. Should all be replaced by marked expr
Check that all Trx. functions have the correct type that matches
that in .mli
*)

(*{{{ Preliminaries, common functions *)

(* BER MetaOCaml version string *)
let meta_version  = "N 101"

(* Co-opt Camlp4 class of warnings *)
let debug_print : string -> unit = fun msg ->
 ignore(Warnings.print Format.err_formatter 
          (Warnings.Camlp4 msg))

(* Emit a translation-time error *)
let trx_error ?(loc = Location.none) fn =
  raise (Typecore.Error (loc, Env.initial, Typecore.Trx_error fn))

let not_supported loc msg =
  trx_error ~loc:loc (fun ppf -> Format.fprintf ppf 
      "%s is not yet supported within brackets" msg)

(* left-to-right accumulating map *)
let rec map_accum : ('accum -> 'a -> 'b * 'accum) -> 'accum -> 'a list ->
  'b list * 'accum = fun f acc -> function
    | []   -> ([],acc)
    | h::t -> 
        let (h,acc) = f acc h in
        let (t,acc) = map_accum f acc t in
        (h::t, acc)

(*}}}*)


(*{{{ Path and location utilities *)

(* ------------------------------------------------------------------------ *)
(* Path utilities *)

(* We always use path when available, and convert it to Longident
   when needed -- even if the Typedtree already carries the longident.
   The path is preferred because it is fully qualified for
   external identifiers and it is unambiguous.
   If we open a module, its components can be referred to without
   qualification -- the path will be qualified nevertheless.
   When we build a Parsetree representing the generated code,
   we have to use fully qualified identifiers since the open statement
   in the original code won't be represented in the generated
   Parsetree.
*)

(* Check to see if a path refers to an identifier, exception, or
   constructor that is available from an external module. If so, the run-time
   compiler invoked by run can get the definition for the identifier from
   a .cmi file. The value of an external identifier can be obtained from
   a .cmo file.
*)
let is_external = function
  | Path.Pident id -> Ident.persistent id              (* not qualified *)
  | Path.Papply _  -> false
  | Path.Pdot(Path.Pident id, _,_) -> Ident.persistent id
  | _             -> false

(* Convert a path to an identifier. Since the path is assumed to be
   `global', time stamps don't matter and we can use just strings.
*)
let rec path_to_lid : Path.t -> Longident.t = function
  | Path.Pident i       -> Longident.Lident (Ident.name i)
  | Path.Pdot (p,s,_)   -> Longident.Ldot (path_to_lid p, s)
  | Path.Papply (p1,p2) ->
      Longident.Lapply(path_to_lid p1, path_to_lid p2)

(* Replace the last component of p1 with p2, which should be a Pident
   path 
*)
let path_replace_last : Path.t -> Path.t -> Path.t = fun p1 p2 ->
 match (p1,p2) with
  | (Path.Pident _,x) -> x
  | (Path.Pdot(p1,_,s),Path.Pident id) -> Path.Pdot(p1,Ident.name id,s)
  | _ -> assert false

(* Check to make sure a constructor, label, exception, etc.
   have the name that we can put into AST (Parsetree).
   Local names can't be put into the Parsetree since the type env in which
   they are declared is not represented in the Parsetree.
*)
let check_path_quotable msg path =
  if not (is_external path) then
    trx_error (fun ppf ->
      Format.fprintf ppf 
        "%s %s cannot be used within brackets. Put into a separate file."
        msg (Path.name path))

(* Check to see that a constructor belongs to a type defined
   in a persistent module or in the initial environment.
   Return the fully qualified name to put into AST 
   (Pervasive constructors remain unqualified however).

   We have nothing to do if the constructor is already fully qualified
   with a persistent module identifier: for example, Scanf.Scan_failure.
   The major complexity comes from this scenario:
      open Scanf
      .<raise (Scan_failure "xx")>.
   The Texp_construct node of Typedtree contains the lid and the
   path that refer to "Scan_failure" without any module qualifications.
   We have to find the fully qualified path and check
   that it is external. We do that by finding the path for the _type_
   constructor, for the type of which the data constructor is a member.
   That type_path is fully qualified. We can ascertain the later fact
   from Typecore.constructors_of_type, which puts the complete path
   into the type of the constructor, which is always of the form
   Tconstr(ty_path,_,_). The function constructors_of_type is used
   within store_type, which is used when opening a module.

   Alternatively we could've used Env.lookup_constuctor, which also
   returns the qualified path? Searching the environment is costly
   though.
 *)
let qualify_ctor : Location.t -> Path.t -> constructor_description -> 
  Longident.t loc = 
 fun loc p cdesc ->
  (fun lid -> Location.mkloc lid loc) (
  let lid = path_to_lid p in
  if is_external p then lid
  else if try ignore (Env.lookup_constructor lid Env.initial); true
          with Not_found -> false
       then lid
  else match (cdesc.cstr_tag, Ctype.repr cdesc.cstr_res) with
  | (Cstr_exception (p,_),_) ->
      if is_external p then path_to_lid p else
       trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
       "Exception %s cannot be used within brackets. Put into a separate file."
        (Path.name p))
  | (_,{desc = Tconstr(ty_path, _, _)}) ->
      if is_external ty_path then
        path_to_lid (path_replace_last ty_path p)
      else
      trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
      "Constructor %s cannot be used within brackets. Put into a separate file."
          (Path.name p))
  | _ -> Printtyp.type_expr Format.err_formatter cdesc.cstr_res;
           failwith ("qualify_ctor: cannot determine type_ctor from data_ctor "^
                     Path.name p)
  )

(* Check to see that a record label belongs to a record defined
   in a persistent module or in the initial environment.
   This is a label version of qualify_ctor
*)
let qualify_label : Location.t -> Path.t -> label_description -> 
  Longident.t loc =
 fun loc p ldesc ->
  (fun lid -> Location.mkloc lid loc) (
  let lid = path_to_lid p in
  if is_external p then lid
  else if try ignore (Env.lookup_label lid Env.initial); true
          with Not_found -> false
       then lid
  else match (Ctype.repr ldesc.lbl_res) with
  | {desc = Tconstr(ty_path, _, _)} ->
      if is_external ty_path then
        path_to_lid (path_replace_last ty_path p)
      else
        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
          "Label %s cannot be used within brackets. Put into a separate file."
          (Path.name p))
  | _ -> Printtyp.type_expr Format.err_formatter ldesc.lbl_res;
           failwith ("qualify_label: cannot determine type from label "^
                     Path.name p)
 )

(* Test if we should refer to a CSP value by name rather than by
   value
*)
(* Module identifiers for the modules that are expected to be
   present at run-time -- that is, will be available for
   dynamic linking of the run-time generated code.
*)

let ident_can_be_quoted = is_external

(*}}}*)


(*{{{ Templates for building Parsetree/Typedtree components *)

let dummy_lid : string -> Longident.t loc = fun name ->
  Location.mknoloc (Longident.Lident name)

(* Exported. Used as a template for constructing lid expressions *)
let sample_lid = dummy_lid "*sample*"

(* Exported. Used as a template for constructing name expression *)
let sample_name : string loc = mknoloc "*sample*"

(* Exported. Used as a template for constructing Location.t expressions *)
let sample_loc = Location.none

(* Exported. Used as a template for constructing pattern lists expressions *)
let sample_pat_list : Parsetree.pattern list = []

(* Exported. Used as a template for passing the Asttypes.rec_flag *)
let sample_rec_flag : Asttypes.rec_flag = Nonrecursive

(*}}}*)

(* ------------------------------------------------------------------------ *)
(* Building Texp nodes *)
(* Env.initial is used for all look-ups. Unqualified identifiers
   must be found there. For qualified identifiers, Env.lookup
   functions look things up in the persistent structures, loading them
   up as needed.
*)

let mk_texp : ?env:Env.t -> Typedtree.expression_desc -> type_expr -> 
  Typedtree.expression =
  fun ?(env=Env.initial) desc ty ->
  { exp_desc = desc; exp_type = ty;
    exp_loc  = Location.none; exp_extra = [];
    exp_env  = env }

(* TODO: add memoization? *)

(* Compiling an identifier with a given (qualified) name *)
let texp_ident : string -> expression = fun name ->
  let lid     = Longident.parse name in
  let (p, vd) = try Env.lookup_value lid Env.initial 
                with Not_found -> fatal_error ("Trx.find_value: " ^ name) in
  mk_texp (Texp_ident (p,mknoloc lid, vd))
          (Ctype.instance Env.initial vd.val_type)


(* Building an application *)
let texp_apply : Typedtree.expression -> Typedtree.expression list -> 
 Typedtree.expression_desc = fun f args ->
   Texp_apply(f, List.map (fun arg -> ("",Some arg, Required)) args)

(* Compiling location data *)
let texp_loc : Location.t -> Typedtree.expression = fun loc ->
  let loc_exp = texp_ident "Trx.sample_loc" in (* this fills in the type, etc.*)
  {loc_exp with exp_desc = Texp_cspval (Obj.repr loc, dummy_lid "*loc*")}

(* Compiling longident with location data *)
let texp_lid : Longident.t loc -> Typedtree.expression = fun lid ->
  let lid_exp = texp_ident "Trx.sample_lid" in (* this fills in the type, etc.*)
  {lid_exp with exp_desc = Texp_cspval (Obj.repr lid, dummy_lid "*lid*")}

(* Compiling a string constant *)
let texp_string : string -> Typedtree.expression = fun str ->
  mk_texp (Texp_constant (Const_string str))
          (Ctype.instance_def Predef.type_string)

(* Compiling a boolean *)
(* For prototype, see Typecore.option_none *)
let texp_bool : bool -> Typedtree.expression = fun b ->
  let lid = Longident.Lident (if b then "true" else "false") in
  let cdec = Env.lookup_constructor lid Env.initial in
  mk_texp (Texp_construct(mknoloc lid, cdec, [], false))
          (Ctype.instance_def Predef.type_bool)

(* Compiling an option *)
(* For prototype, see Typecore.option_none *)
let texp_option : Typedtree.expression option -> Typedtree.expression = 
  function
    | None -> 
        let lid = Longident.Lident "None" in
        let cnone = Env.lookup_constructor lid Env.initial in
        mk_texp (Texp_construct(mknoloc lid, cnone, [], false))
                (Ctype.instance_def (Predef.type_option (Btype.newgenvar ())))
    | Some e ->
        let lid = Longident.Lident "Some" in
        let csome = Env.lookup_constructor lid Env.initial in
        mk_texp (Texp_construct(mknoloc lid, csome, [e],false))
                (Ctype.instance_def (Predef.type_option e.exp_type)) 
                ~env:e.exp_env

(* Compiling a tuple *)
let texp_tuple : Typedtree.expression list -> Typedtree.expression = fun el ->
  mk_texp (Texp_tuple el)
          (Ctype.newty (Ttuple (List.map (fun e -> e.exp_type) el)))

(* Compiling an array *)
(* We use this function for grouping trx_bracket-transformed expressions,
   which have the same representation type (but may be different
   code type). We ignore the differences in the code type, since
   the representation type is the same.

   We don't use lists since they are harder to compile, and more
   fragile. Texp_construct has more arguments, we have to locate
   constructor information, etc.
*)
let texp_array : Typedtree.expression list -> Typedtree.expression = function
  | [] -> 
      mk_texp (Texp_array []) 
	      (Ctype.instance_def (Predef.type_array (Btype.newgenvar ())))
  | (h::_) as el ->
      mk_texp (Texp_array el) 
	      (Ctype.instance_def (Predef.type_array h.exp_type))

(* ------------------------------------------------------------------------ *)
(* Stack marks, a simple form of dynamic binding *)
module type STACKMARK = sig
  type t
  val is_valid : t -> bool
  (* compare is supposed to be called on stack marks that are
     checked to be valid
   *)
  val compare : t -> t -> int
  val with_stack_mark : (t -> 'w) -> 'w
end

(* Simple implementation with shallow dynamic binding *)
module StackMark : STACKMARK = struct
  type t = int ref

  (* The global counter of the nesting depth of with_stack_mark *)
  let stack_mark_cnt = ref 0

  (* A stack mark is ref n where n is the depth of the corresponding
     with_stack_mark form.
     The stack mark is invalid if the counter is 0
   *)
  let with_stack_mark body =
    incr stack_mark_cnt;
    let mark = ref !stack_mark_cnt in
    let finalize () =
      mark := 0;                         (* invalidate the mark *)
      assert (!stack_mark_cnt > 0);
      decr stack_mark_cnt
    in
    try 
      let r = body mark in finalize (); r
    with e -> finalize (); raise e

  let is_valid mark = !mark > 0
  let compare m1 m2 =
    assert (!m1 >0 && !m2 > 0);
    compare !m1 !m2
end

    
(* ------------------------------------------------------------------------ *)
(* Simple heap *)
(* A mapping of keys to values
   Duplicate bindings to a key are ignored (collapsed).
   However, we do not ignore eagerly -- only when we encounter
   the duplicates during the heap operations.

   Keys should be comparable. The invariant: for each non-leaf
   node, the key at the node is strictly greater than the key of any of
   the child nodes. The order of keys between children can be arbitrary.
*)
type 'v heap = Nil | HNode of StackMark.t * 'v * 'v heap * 'v heap
let empty = Nil

let rec merge : 'v heap -> 'v heap -> 'v heap = fun h1 h2 ->
  match (h1,h2) with
  | (Nil,h) | (h,Nil)-> h
  | (HNode (k1,v1,l1,r1), HNode (k2,v2,l2,r2)) ->
      begin
        match StackMark.compare k1 k2 with
        | 0 -> HNode (k1,v1, merge l1 l2, merge r1 r2) (* same keys *)
        | n when n < 0 -> HNode (k2,v2, merge h1 l2, r2)
        | _ -> HNode (k1,v1,l1,merge h2 r1)
      end

(* Remove the top of a non-empty heap *)
let remove_top : 'v heap -> 'v heap = function
  | Nil -> assert false
  | HNode (_,_,h1,h2) -> merge h1 h2


(* The representation of the possibly open code: AST plus the
   set of free identifiers, annotated with the marks
   of the corresponding with_binding_region forms
*)
type code_repr = Code of string loc heap * Parsetree.expression

(* The closed code is AST *)
type closed_code_repr = Parsetree.expression

(* Check that the code is closed and return the closed code *)

(* The same as close_code but return the closedness check as a thunk
   rather than performing it.
   This is useful for debugging and for showing the code
*)
let close_code_delay_check : code_repr -> closed_code_repr * (unit -> unit) =
 function
  | Code (Nil,ast) -> (ast,fun () -> ())
  | Code (HNode (_,var,_,_),ast) ->
    (ast, fun () ->
      Format.fprintf Format.str_formatter
      "The code built at %a is not closed: identifier %s bound at %a is free"
      Location.print ast.pexp_loc var.txt Location.print var.loc;
      failwith (Format.flush_str_formatter ()))

let close_code_repr : code_repr -> closed_code_repr = fun cde ->
  let (ast, check) = close_code_delay_check cde in
  check (); ast

let open_code : closed_code_repr -> code_repr = fun ast ->
  Code (Nil,ast)

(* Compiling a closed code value: a structural constant of
   type code_repr
   This constant is transported via CSP (although we could have
   built a Typedtree node for that purpose.
 *)
let texp_code : ?node_id:string ->
  Location.t -> Parsetree.expression_desc -> Typedtree.expression_desc =
  fun ?(node_id="") loc desc ->
  let ast = {pexp_loc = loc; pexp_desc = desc}
  in Texp_cspval (Obj.repr (open_code ast), dummy_lid node_id)



(* ------------------------------------------------------------------------ *)
(* Bindings in the future stage *)
(* Recall, all bindings at the future stage are introduced by
   patterns, and hence are simple names, without any module qualifications.
*)
let gensym_count = ref 0

(* Generate a fresh name with a given base name *)
let gensym : string -> string = fun s ->
  incr gensym_count;
  s ^ "_" ^ string_of_int !gensym_count

let reset_gensym_counter () = gensym_count := 0

(* Make a simple identifier unique *)
let genident : string loc -> string loc = fun name ->
  {name with txt = gensym name.txt}

(* This is a run-time error, rather than a translation-time error *)
let scope_extrusion_error : 
  detected:Location.t -> occurred:Location.t -> string loc -> 'a = 
  fun ~detected ~occurred var ->
  Format.fprintf Format.str_formatter
    "Scope extrusion detected at %a for code built at %a for the identifier %s bound at %a"
    Location.print detected Location.print occurred
    var.txt Location.print var.loc;
  failwith (Format.flush_str_formatter ())

(* Check to make sure that free variables in the potentially open
   code fragment are valid.
   We only check for the variable with the latest stack_mark (the
   one corresponding to the latest binding)
*)
let validate_vars : Location.t -> code_repr -> code_repr = 
  fun l -> function
  | Code (Nil,_) as cde -> cde
  | Code (HNode (sm,var,_,_), ast) as cde ->
    if StackMark.is_valid sm then cde
    else scope_extrusion_error ~detected:l ~occurred:ast.pexp_loc var 

(* ZZZZZ
(* The names of gensym'd future stage bindings currently in scope,
   of new_binding_region.
   We use physical equality to search the list.
   Therefore, we may reset_gensym_counter on each top-level phrase.
*)
let bindings_in_scope : string loc list ref = ref []

(* Return the index of a given free variable in bindings_in_scope:
   essentially the de Bruijn index.
   Report a scope extrusion error if any.
*)
let fvar_dB_index : Location.t -> string loc -> int = fun l var ->
  let rec loop n = function
    | h::t -> if h == var then n        (* physical equality! *)
              else loop (succ n) t
    | []   -> scope_extrusion_error l var
  in loop 0 !bindings_in_scope

(* Dedicated Location.t for the identification of timestamp nodes 
   We test the comparison with timestamp_loc using physical equality.
*)
let timestamp_loc =
  let open Lexing in
  let loc = dummy_pos in
  let loc = {loc with pos_fname = "**timestamp**"} in
  {Location.loc_start = loc; loc_end = loc; loc_ghost=true}


(* check to see if an expression has a time-stamp. If so, remove it
   and return the un-timestamped expression. Return the latest of the
   removed timestamp and the given as the argument.
   The timestamp is just the variable name.
*)
let remove_tstamp : string loc option -> Parsetree.expression -> 
  Parsetree.expression * string loc option = fun old_tstamp -> function
  | {pexp_loc = tloc; pexp_desc = Pexp_setinstvar (var,e)} 
    when tloc == timestamp_loc -> 
     let vi = fvar_dB_index e.pexp_loc var in (* also checks that vi is alive *)
     begin match old_tstamp with
      | None      -> (e,Some var)
      | Some var' -> 
         if var == var' then (e,Some var) else (* common case *)
         let vi' = fvar_dB_index e.pexp_loc var' in
         (e, Some (if vi' > vi then var else var'))
     end
  |  e -> (e,old_tstamp)

     
(* Add a timestamp to an expression *)
let add_timestamp : string loc option -> Parsetree.expression -> 
  Parsetree.expression = fun var e ->
  match var with 
  | None     -> e
  | Some var -> 
  {pexp_loc  = timestamp_loc;
   pexp_desc = Pexp_setinstvar (var,e)}

let remove_tstamp_option : string loc option -> 
  Parsetree.expression option -> 
  Parsetree.expression option * string loc option = fun var -> function
    | None   -> (None,var)
    | Some e -> let (e,var) = remove_tstamp var e in (Some e,var)

(* Generate a gensym with a given base name and enter a new region 
   in which this gensym will live
*)
let with_binding_region : string loc -> 
  (string loc -> Parsetree.expression) -> Parsetree.expression =
  fun name_base body ->
    let old_bindings = !bindings_in_scope in
    let new_var = genident name_base in
    let () = bindings_in_scope := new_var :: old_bindings in
    try 
      let r = body new_var in
      let remr = remove_tstamp None r in (* checks tstamp *) 
      let () = bindings_in_scope := old_bindings in
      match remr with
      | (e,None) -> e
      | (e,Some var) when var == new_var ->
          add_timestamp (match old_bindings with h::_ -> Some h | _ -> None) e
      | (e,Some var) ->
          let _ = fvar_dB_index e.pexp_loc var  (* check that var is current *)
          in r
    with e -> bindings_in_scope := old_bindings; raise e

let check_scope_extrusion : Parsetree.expression -> Parsetree.expression = 
  fun exp -> fst (remove_tstamp None exp)

(* Convert the meta-level (fun var -> body) to the Typedtree.expression
   representing the same function, and use the result generate the call to
   with_binding_region
*)
let texp_binding_simple : 
  Ident.t * string loc -> (Typedtree.expression -> Typedtree.expression) ->
  Typedtree.expression_desc = fun (id,name) fbody ->
  let name_exp = texp_ident "Trx.sample_name" in
  let base_name_exp = 
    {name_exp with
     exp_desc = Texp_cspval (Obj.repr name, dummy_lid "*name*")} in
  let pat = { pat_desc = Tpat_var (id,name);
              pat_loc  = name.loc; pat_extra = [];
              pat_type = name_exp.exp_type;
              pat_env  = name_exp.exp_env }(* not including the binding to id!*)
  in
  let name_vd = match name_exp.exp_desc with
                  | Texp_ident (_,_,vd) -> vd
                  | _ -> assert false in
  let gensymed_exp =                (* translated var *)
    {name_exp with exp_desc = 
       Texp_ident (Path.Pident id,
                    (mkloc (Longident.Lident name.txt) name.loc),name_vd)} in
  let body = fbody gensymed_exp in 
  let fun_body_exp = 
        { body with
          exp_desc = Texp_function ("",[(pat,body)],Total); 
          exp_type = Ctype.newty (Tarrow("", name_exp.exp_type, 
                                             body.exp_type, Cok)) }
  in
  texp_apply (texp_ident "Trx.with_binding_region")
    [base_name_exp; fun_body_exp]
*)

(* ------------------------------------------------------------------------ *)
(* Building Parsetree nodes *)

(* Handle timestamp for builders of the type 
      Parsetree.expression -> Parsetree.expression
*)
let code_wrapper : 
    (Location.t -> Parsetree.expression -> Parsetree.expression) ->
    (Location.t -> code_repr -> code_repr) =
fun f l e ->
  let Code (vars,e) = validate_vars l e in
  Code (vars, f l e)

(* building a typical Parsetree node: Pexp_assert of expression*)
let build_assert : Location.t -> code_repr -> code_repr = 
  code_wrapper
  (fun l e -> {pexp_loc = l; pexp_desc = Pexp_assert e})

(* When we translate the typed-tree, we have to manually compile
   the above code 
First, to see the AST for the phrase, invoke the top-level with the flag
-dparsetree. Then
   {pexp_loc  = l; pexp_desc = Pexp_assert e}

gives the parsetree:
let build_assert_ast : Location.t -> Parsetree.expression -> Parsetree.expression = 
{pexp_loc = l1;
 pexp_desc = 
  Pexp_record
        ([(Location.mknoloc (Longident.parse "Parsetree.pexp_loc"), 
           Pexp_ident "l");
         (Location.mknoloc (Longident.parse "Parsetree.pexp_desc"),
           {pexp_loc  = Location.none;
            pexp_desc = Pexp_construct 
                          ((Location.mknoloc (Longident.parse 
                                                "Parsetree.Pexp_assert")),
              Some {pexp_loc = Location.none;
                    pexp_desc = Pexp_ident "e"},
              false)})
        ],
        None)}
type_expression

If building the parsetree on our own, beware! For example, labels in
Texp_record must be sorted, in their declared order!
*)


(* Other similar builders *)
let build_lazy : Location.t -> code_repr -> code_repr = 
  code_wrapper
    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_lazy e})
let build_bracket : Location.t -> code_repr -> code_repr= 
  code_wrapper
    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_bracket e})
let build_escape : Location.t -> code_repr -> code_repr = 
  code_wrapper
    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_escape e})

let build_sequence : Location.t -> code_repr -> code_repr -> code_repr = 
  fun l e1 e2 -> 
    let Code (vars1,e1) = validate_vars l e1 in
    let Code (vars2,e2) = validate_vars l e2 in
    Code (merge vars1 vars2,
          {pexp_loc = l; pexp_desc = Pexp_sequence (e1,e2) })
let build_while : Location.t -> code_repr -> code_repr -> code_repr = 
  fun l e1 e2 -> 
    let Code (vars1,e1) = validate_vars l e1 in
    let Code (vars2,e2) = validate_vars l e2 in
    Code (merge vars1 vars2,
          {pexp_loc = l; pexp_desc = Pexp_while (e1,e2) })
let build_when : Location.t -> code_repr -> code_repr -> code_repr = 
  fun l e1 e2 -> 
    let Code (vars1,e1) = validate_vars l e1 in
    let Code (vars2,e2) = validate_vars l e2 in
    Code (merge vars1 vars2,
          {pexp_loc = l; pexp_desc = Pexp_when (e1,e2) })

(* ZZZZZ
(* Build the application. The first element in the array is the
   function. The others are arguments. *)
let build_apply : Location.t -> (label * Parsetree.expression) array -> 
  Parsetree.expression = 
  fun l ea -> 
    assert (Array.length ea > 1);
    let (el,var) = map_accum 
        (fun var (l,e) -> let (e,var) = remove_tstamp var e in ((l,e),var))
        None (Array.to_list ea) in
    add_timestamp var
    {pexp_loc  = l; 
     pexp_desc = Pexp_apply (snd (List.hd el),List.tl el)}

let build_tuple : 
  Location.t -> Parsetree.expression array -> Parsetree.expression =
  fun l ea -> 
    let (el,var) = map_accum remove_tstamp None (Array.to_list ea) in
    add_timestamp var
      {pexp_loc = l; pexp_desc = Pexp_tuple el }

let build_array : 
  Location.t -> Parsetree.expression array -> Parsetree.expression =
  fun l ea -> 
    let (el,var) = map_accum remove_tstamp None (Array.to_list ea) in
    add_timestamp var
      {pexp_loc = l; pexp_desc = Pexp_array el }

let build_ifthenelse : 
  Location.t -> 
  Parsetree.expression -> Parsetree.expression -> Parsetree.expression option ->
  Parsetree.expression =
  fun l e1 e2 eo -> 
    let (e1,var) = remove_tstamp None e1 in
    let (e2,var) = remove_tstamp var  e2 in
    let (eo,var) = remove_tstamp_option var eo in
    add_timestamp var
      {pexp_loc = l; pexp_desc = Pexp_ifthenelse (e1,e2,eo) }

let build_construct :
 Location.t -> Longident.t loc -> Parsetree.expression array -> bool ->
 Parsetree.expression =
 fun loc lid args explicit_arity ->
   let (args,var) = map_accum remove_tstamp None (Array.to_list args) in
   add_timestamp var
  {pexp_loc  = loc;
   pexp_desc = Pexp_construct (lid,
     begin
      match args with
      | []  -> None
      | [x] -> Some x
      | xl  -> Some { pexp_loc  = loc; pexp_desc = Pexp_tuple xl }
     end,
     explicit_arity) }

let build_record :
 Location.t -> (Longident.t loc * Parsetree.expression) array ->
 Parsetree.expression option -> Parsetree.expression =
 fun loc lel eo ->
    let (lel,var) = map_accum 
        (fun var (l,e) -> let (e,var) = remove_tstamp var e in ((l,e),var))
        None (Array.to_list lel) in
   let (eo,var) = remove_tstamp_option var eo in
   add_timestamp var
      {pexp_loc  = loc; pexp_desc = Pexp_record (lel,eo)}

let build_field :
 Location.t -> Parsetree.expression -> Longident.t loc -> Parsetree.expression =
 fun loc e lid ->
   let (e,var) = remove_tstamp None e in
   add_timestamp var
     {pexp_loc  = loc;
      pexp_desc = Pexp_field (e,lid)}

let build_setfield :
 Location.t -> Parsetree.expression -> Longident.t loc -> 
   Parsetree.expression -> Parsetree.expression =
 fun loc e1 lid e2 ->
   let (e1,var) = remove_tstamp None e1 in
   let (e2,var) = remove_tstamp var  e2 in
   add_timestamp var
     {pexp_loc  = loc;
      pexp_desc = Pexp_setfield (e1,lid,e2)}

let build_variant :
 Location.t -> string -> Parsetree.expression option -> Parsetree.expression =
 fun loc l eo ->
   let (eo,var) = remove_tstamp_option None eo in
   add_timestamp var
     {pexp_loc  = loc;
      pexp_desc = Pexp_variant (l,eo)}

let build_send :
 Location.t -> Parsetree.expression -> string -> Parsetree.expression =
 fun loc e l ->
   let (e,var) = remove_tstamp None e in
   add_timestamp var
     {pexp_loc  = loc;
      pexp_desc = Pexp_send (e,l)}

let build_open :
 Location.t -> Longident.t loc -> Parsetree.expression -> Parsetree.expression =
 fun loc l e ->
   let (e,var) = remove_tstamp None e in
   add_timestamp var
     {pexp_loc  = loc;
      pexp_desc = Pexp_open (l,e)}


(* Build a Parsetree for a future-stage identifier
   It is always in scope of with_binding_region:
   Bound variables are always in scope of their binders;
   A well-typed code has no unbound variables.
*)
let build_ident : Location.t -> string loc -> Parsetree.expression =
 fun loc l ->
  add_timestamp (Some l)
   {pexp_loc  = loc;
    pexp_desc = Pexp_ident (mkloc (Longident.Lident l.txt) l.loc)}

let build_for : 
  Location.t -> string loc -> Parsetree.expression -> Parsetree.expression -> 
  bool -> Parsetree.expression -> Parsetree.expression =
  fun l name elo ehi dir ebody -> 
  let (elo,var)   = remove_tstamp None elo in
  let (ehi,var)   = remove_tstamp var  ehi in
  let (ebody,var) = remove_tstamp var  ebody in
  add_timestamp var
  {pexp_loc = l; 
   pexp_desc = Pexp_for (name,elo,ehi,(if dir then Upto else Downto), ebody) }

let build_fun_simple : 
  Location.t -> string -> string loc -> Parsetree.expression -> 
  Parsetree.expression =
  fun l label name ebody -> 
  let (ebody,var) = remove_tstamp None ebody in
  let pat = {ppat_loc  = l; ppat_desc = Ppat_var name} in
  add_timestamp var
  {pexp_loc = l; 
   pexp_desc = Pexp_function (label,None,[(pat,ebody)])}

let build_let_simple : 
  Location.t -> rec_flag -> string loc -> Parsetree.expression -> 
  Parsetree.expression -> Parsetree.expression =
  fun l recf name e ebody -> 
  let (e,var)     = remove_tstamp None e in
  let (ebody,var) = remove_tstamp var  ebody in
  let pat = {ppat_loc  = l; ppat_desc = Ppat_var name} in
  add_timestamp var
  {pexp_loc = l; 
   pexp_desc = Pexp_let (recf,[(pat,e)],ebody)}

(* All simple Pext_ident must use alive gensym'd names  *)
(*
let rec check_scope_extrusion : Parsetree.expression -> unit = fun exp ->
  let check = check_scope_extrusion in
  let check_option = function 
    | None -> () 
    | Some e -> check e in
  let check_list = List.iter check in
  let check_xl l   = List.iter (fun (_,e) -> check e) l in
  match exp.pexp_desc with
  | Pexp_ident ({txt = Longident.Lident s} as l) ->
      if not (BVar.mem (mkloc s l.loc) !bindings_in_scope) then
        (* This is a run-time error, rather than translation-time error *)
        (Format.fprintf Format.str_formatter
            "Scope extrusion at %a for the identifier %s bound at %a"
             Location.print exp.pexp_loc s Location.print l.loc;
         failwith (Format.flush_str_formatter ()))
  | Pexp_ident _    -> ()
  | Pexp_constant _ -> ()
  | Pexp_let (_,pel,e)       -> check_xl pel; check e
  | Pexp_function (_,None,pel) -> ()
  | Pexp_apply (e,lel)       -> check e; check_xl lel
  | Pexp_match (e,pel)       -> check e; check_xl pel
  | Pexp_try (e,pel)         -> check e; check_xl pel
  | Pexp_tuple el            -> check_list el
  | Pexp_construct (_,eo,_)  -> check_option eo
  | Pexp_variant (_,eo)      -> check_option eo
  | Pexp_record (lel,eo)     -> check_xl lel; check_option eo
  | Pexp_field (e,_)         -> check e
  | Pexp_setfield (e1,_,e2)  -> check e1; check e2
  | Pexp_array el            -> check_list el 
  | Pexp_ifthenelse (e1,e2,eo) -> check e1; check e2; check_option eo
  | Pexp_sequence (e1,e2)    -> check e1; check e2
  | Pexp_while (e1,e2)       -> check e1; check e2
  | Pexp_for (_,e1,e2,_,e3)  -> ()      (* we run when construct *)
  | Pexp_constraint (e,_,_)  -> check e
  | Pexp_when (e1,e2)        -> check e1; check e2
  | Pexp_send (e,_)          -> check e
  | Pexp_new _               -> ()
  | Pexp_setinstvar (_,e)    -> check e
  | Pexp_override lel        -> check_xl lel
  | Pexp_assert e            -> check e
  | Pexp_assertfalse         -> ()
  | Pexp_lazy e              -> check e
  | Pexp_poly (e,_)          -> check e
  | Pexp_object _            -> ()
  | Pexp_newtype (_,e)       -> check e
  | Pexp_pack _              -> ()
  | Pexp_open (_,e)          -> check e
  | Pexp_bracket e           -> check e
  | Pexp_escape e            -> check e
  | Pexp_cspval _            -> ()
  | _                        -> assert false (* can't occur in generated code *)
*)


(* ------------------------------------------------------------------------ *)
(* Dealing with CSP *)

exception CannotLift

(* Analyze the type of the expression and figure out if we can lift it.
   Raise CannotLift if cannot (e.g., the type is polymorphic), or it is too
   much to bother.
   TODO: lists, arrays, option types of liftable types are themselves
   liftable. We can lift many more types. For arrays, check their length.
   If the array is short, it should be lifted. For long arrays,
   building a CSP is better (although it make take a bit longer since
   we will have to invoke dyn_quote at run-time).

   TODO: currently we generate calls to run-time functions like 
   lift_constant_int to do the Parsetree generation. In the future
   we should `inline' those functions -- that is, obtain the Typedtree
   for them and use the tree for building Texp_apply.
*)
let lift_as_literal : 
  Typedtree.expression -> Path.t -> Longident.t loc -> 
  Typedtree.expression_desc = fun exp p li ->
  let exp_ty =
        Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
  match Ctype.repr exp_ty with
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
        texp_apply (texp_ident "Trx.lift_constant_int") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
        texp_apply (texp_ident "Trx.lift_constant_char") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
        texp_apply (texp_ident "Trx.lift_constant_bool") [exp]
          (* double and string are handled by dyn_quote *)
    | _ -> raise CannotLift

(* TODO: similarly handle Const_nativeint, Const_int32, Const_int64 *)
let lift_constant_int : int -> Parsetree.expression = fun x -> 
  {pexp_loc  = Location.none;
   pexp_desc = Pexp_constant (Const_int x)}

let lift_constant_char : char -> Parsetree.expression = fun x -> 
  {pexp_loc  = Location.none;
   pexp_desc = Pexp_constant (Const_char x)}

let lift_constant_bool : bool -> Parsetree.expression = fun x -> 
  let b = if x then "true" else "false" in 
  {pexp_loc  = Location.none;
   pexp_desc = Pexp_construct (Location.mknoloc (Longident.Lident b), 
                               None, false)}


(* Lift the run-time value v into a Parsetree for the code that, when
   run, will produce v.
   We do not have the type information for v, but we can examine
   its run-time representation, to decide if we lift it is a source
   literal or as a CSP.

  TODO: also check for double_array_tag
   and create a (structured) constant for a double array
*)
let dyn_quote : Obj.t -> Longident.t loc -> Parsetree.expression =
  fun v li ->
   let dflt = Pexp_cspval(v,li) in        (* By default, we build CSP *)
   let desc = 
    match Obj.is_int v with
    | true -> dflt  (* If v looks like an int, it can represent many things: *)
                    (* can't lift *)
    | false when Obj.tag v = Obj.double_tag ->
      Pexp_constant (Const_float (string_of_float (Obj.obj v)))
    | false when Obj.tag v = Obj.string_tag ->
      Pexp_constant (Const_string (Obj.obj v))
    | _   -> dflt
   in 
   {pexp_loc = li.loc; pexp_desc = desc}

       
(* Build the Typedtree that lifts the variable with the given path and type.
   Since this code receives the type of the variable, we use the
   type to generate the lifting code for that particular type.
   For example, we build the code to convert a float
   0.1 to the Parsetree node Pexp_constant(Const_float "0.1")).
   If we cannot or would not do the type-dependent lifting and we cannot
   refer to the variable by name (e.g., because it is local),
   we generate the call to the dynamic quoter, dyn_quote.
   The latter will receive the actual value to quote and will generate,
   at run-time, a Parsetree constant or CSP, based on that value.
 *)
let trx_csp : 
  Typedtree.expression -> Path.t -> Longident.t loc ->
  Typedtree.expression_desc = fun exp p li ->
  (* First we try lifting as a constant *)
  try lift_as_literal exp p li 
  with CannotLift ->
  (* Then check if we can pass by reference *)
  if ident_can_be_quoted p then
     let ast = 
         {pexp_loc = exp.exp_loc;
          pexp_desc = Pexp_ident (Location.mkloc (path_to_lid p) li.loc)}
      in Texp_cspval (Obj.repr ast, dummy_lid "*id*")
  else
  (* Otherwise, do the lifting at run-time *)
  texp_apply (texp_ident "Trx.dyn_quote") [exp; texp_lid li]


(* Analyze and translate a pattern:
         Typedtree.pattern -> Parsetree.pattern
  The function is somewhat similar to tools/untypeast.ml;untype_pattern

  However, we also determine and return the list of bound variables.
  The list is in the reverse of the order of variables occurring in the pattern.
  Finally, we check that labels and constructors may be quoted.

  The algorithm of determining the names of bound variables is based
  on Typedtree.pat_bound_idents. There is one subtle issue.
  Normally all variables within a pattern are unique (patterns are
  always linear). Identically named variables within a list of patterns, like 
      match ... with
      | [x] -> 
      | [x;y] ->
  are _distinct_ variables. They have different Ident.t values, even though
  their names may be the same. However, components of an OR pattern 
  bind exactly the same identifiers. Don't count them twice!
*)


(* The first argument is a list of identifiers. Found identifiers are
   prepended to that list. The order of identifiers is important!
   If you change the traversal order, be sure to modify pattern_subst below!
*)
let rec trx_pattern : 
    (Ident.t * string loc) list -> Typedtree.pattern -> 
     Parsetree.pattern * (Ident.t * string loc) list = fun acc pat ->
 if not (pat.pat_extra = []) then
   not_supported pat.pat_loc
    "patterns with unpack, constraints, and other pat_extra";
  let (pd,acc) = match pat.pat_desc with
  | Tpat_any -> (Ppat_any, acc)
  | Tpat_var (id, name) when 
      (match (Ident.name id).[0] with 'A'..'Z' -> true | _ -> false) ->
        (Ppat_unpack name,acc)        (* We don't handle modules though...*)
  | Tpat_var (id, name) ->
      (Ppat_var name, (id,name)::acc)
  | Tpat_alias (p, id, name) ->
      let (p,acc) = trx_pattern acc p in
      (Ppat_alias (p, name),(id,name)::acc)
  | Tpat_constant cst -> (Ppat_constant cst, acc)
  | Tpat_tuple lst ->
    let (pl,acc) = map_accum trx_pattern acc lst
    in (Ppat_tuple pl, acc)
  | Tpat_construct (p, li, cdesc, args, explicit_arity) ->
      let lid = qualify_ctor li.loc p cdesc in
      let (args,acc) = map_accum trx_pattern acc args in
      (Ppat_construct (lid,
          (match args with
          | []  -> None 
          | [x] -> Some x 
          | _   -> Some {ppat_desc = Ppat_tuple args; ppat_loc = pat.pat_loc}),
          explicit_arity),
       acc)
  | Tpat_variant (label, None, _) -> (Ppat_variant (label,None),acc)
  | Tpat_variant (label, Some p, _) ->
      let (p,acc) = trx_pattern acc p 
      in (Ppat_variant (label,Some p),acc)
  | Tpat_record (lst, closed) ->
      let dolab acc (p,li,ldesc,pat) =
        let lid = qualify_label li.loc p ldesc in
        let (pat,acc) = trx_pattern acc pat in
        ((lid,pat),acc)
      in
      let (lpl,acc) = map_accum dolab acc lst in
      (Ppat_record (lpl,closed),acc)
  | Tpat_array lst -> 
    let (pl,acc) = map_accum trx_pattern acc lst
    in (Ppat_array pl, acc)
  | Tpat_or (p1, p2, _) -> 
      (* Invariant : both arguments bind the same variables *)
      let (p1,acc) = trx_pattern acc p1 in
      let (p2,_)   = trx_pattern acc p2 in (* ignore vars in p2 *)
      (Ppat_or (p1,p2),acc)
  | Tpat_lazy p -> 
      let (p,acc) = trx_pattern acc p in (Ppat_lazy p,acc)
  in
  ({ ppat_desc = pd; ppat_loc = pat.pat_loc}, acc)

(* Process all patterns in the pattern-expression list *)
(* Patterned are processed left-to-right. The found bound identifiers
   are added to lst, in strict reverse order. The last identifier added
   by the last (right-most) pattern in the list is at the head
   of the list of identifiers.
*)
let trx_pel : 
    (Ident.t * string loc) list -> 
     (Typedtree.pattern * Typedtree.expression) list -> 
     Parsetree.pattern list * (Ident.t * string loc) list = 
   map_accum (fun acc (p,_) -> trx_pattern acc p)

(* Substitute the names of bound variables in the pattern.
   The new names are given in the string loc list. We
   take advantage of the fact that patterns are linear and
   the list of new names is ordered, in the order the bound
   variables occur in the pattern. Therefore, we substitute based
   on position.
   OR-patterns bring complexity however: both branches of an OR
   pattern bind exactly the same variables (but the order of
   variable occurrence within branches may be different).
   So for OR patterns we substitute by name, taking advantage
   of the fact the new names differ from the old ones in _nnn
   suffix. OR patterns are uncommon, so the complication of their processing
   is not that bad.

   This function is closely related to trx_pattern; It relies on the
   same pattern traversal order as trx_pattern.
 *)

         (* two strings are the same up to (and including) n *)
let rec same_upto s1 s2 n =
  n < 0 || (s1.[n] = s2.[n] && same_upto s1 s2 (n-1))

let rec pattern_subst : ?by_name:bool ->
    string loc list -> Parsetree.pattern -> 
     Parsetree.pattern * string loc list = fun ?(by_name=false) acc pat ->
 if acc = [] then (pat,acc) else           (* no more variables to subst *)
 let subst old_name acc =
   if by_name then begin
     let new_name =
       try List.find (fun n -> 
         same_upto old_name.txt n.txt (String.rindex n.txt '_' - 1)) acc 
       with _ ->
         begin
           Format.fprintf Format.str_formatter "old_name %s %a\n"
             old_name.txt Location.print old_name.loc;
           List.iter (fun n -> Format.fprintf Format.str_formatter
               "new name %s %a\n" n.txt Location.print n.loc) acc;
           failwith (Format.flush_str_formatter ())
         end
     in
     (new_name, acc)                       (* don't bother removing from acc*)
   end
   else match acc with
   | h::t -> (h,t)
   | _    -> assert false
 in
 let (desc,acc) = match pat.ppat_desc with
  | Ppat_any as x -> (x,acc)
  | Ppat_var old_name ->
      let (new_name,acc) = subst old_name acc in (Ppat_var new_name,acc)
  | Ppat_alias (p,old_name) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     let (new_name,acc) = subst old_name acc in 
     (Ppat_alias (p,new_name),acc)
  | Ppat_constant _ as x -> (x,acc)
  | Ppat_tuple pl ->
      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
      (Ppat_tuple pl,acc)
  | Ppat_construct (_,None,_) as x -> (x,acc)
  | Ppat_construct (lid,Some p,b) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_construct (lid,Some p,b),acc)
  | Ppat_variant (_,None) as x -> (x,acc)
  | Ppat_variant (l,Some p) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_variant (l,Some p),acc)
  | Ppat_record (pl,cf) ->
      let (pl,acc) = map_accum (fun acc (l,p) -> 
          let (p,acc) = pattern_subst ~by_name acc p in ((l,p),acc)) acc pl in
      (Ppat_record (pl,cf),acc)
  | Ppat_array pl ->
      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
      (Ppat_array pl,acc)
  | Ppat_or (p1,p2) ->
     let (p1,acc') = pattern_subst ~by_name acc p1 in
     let (p2,_)   = pattern_subst ~by_name:true acc p2 in
     (Ppat_or (p1,p2), acc')
  | Ppat_constraint (p,cty) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_constraint (p,cty), acc)
  | Ppat_type _ as x -> (x,acc)
  | Ppat_lazy p ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_lazy p, acc)
  | Ppat_unpack _ as x -> (x,acc)
 in
 ({pat with ppat_desc = desc}, acc)


let pattern_subst_list :
    string loc list -> Parsetree.pattern list -> 
     Parsetree.pattern list * string loc list = fun acc pl ->
 map_accum (pattern_subst ~by_name:false) acc pl


(* Generalization of texp_binding_simple to the general binding pattern:
   Convert the meta-level (fun vars pats exps -> body) to the 
   Typedtree.expression
   representing the same function, and use the result generate the call to
   with_binding_region
*)
let texp_binding_pattern : 
    (Typedtree.pattern * Typedtree.expression) list ->
    Typedtree.expression -> (* the template for the result: the exp that fbody
                               will construct, with correct
                               exp_loc, exp_type slots; exp_desc will be
                               replaced
                             *)
    (Typedtree.expression list -> Typedtree.expression -> 
     Typedtree.expression list -> Typedtree.expression) ->
  Typedtree.expression_desc = fun pel exp fbody ->
  let (pl,idents) = trx_pel [] pel in
  let idents = List.rev idents in (* idents ordered as pl *)
  let pl_exp = texp_ident "Trx.sample_pat_list" in
  let pats   = {pl_exp with
                exp_desc = Texp_cspval (Obj.repr pl, dummy_lid "*pl*")} in
  let rec loop acc = function
    | [] -> fbody (List.rev acc) pats (List.map snd pel)
    | idname::rest ->
        {exp with exp_desc =
         texp_binding_simple idname (fun gensymed_var ->
           loop (gensymed_var::acc) rest)}
  in (loop [] idents).exp_desc

(* Build the general fun Parsetree *)
let build_fun : 
  Location.t -> string -> string loc array -> 
  Parsetree.pattern list -> Parsetree.expression array ->
  Parsetree.expression =
  fun l label names pats ebodies -> 
    let (ebodies,var) = map_accum remove_tstamp None (Array.to_list ebodies) in
    let pats = 
      if names = [||] then pats else
      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
      assert (acc = []); pats
    in
    add_timestamp var
      {pexp_loc = l; 
       pexp_desc = Pexp_function (label,None,
                                  List.map2 (fun p e -> (p,e)) pats ebodies)}

(* The second argument to build_match is the Parsetree representing
   the expression to match. Since the expression is evaluated
   outside the bindings, its timestamp should be earlier than those
   corresponding to the expressions in the branch. 
  TODO: implement this check. So far, we don't discriminate.
*)
let build_match : 
  Location.t -> Parsetree.expression -> string loc array -> 
  Parsetree.pattern list -> Parsetree.expression array ->
  Parsetree.expression =
  fun l exp names pats ebodies -> 
    let (exp,var)     = remove_tstamp None exp in (* must be an earlier tstamp*)
    let (ebodies,var) = map_accum remove_tstamp var (Array.to_list ebodies) in
    let pats = 
      if names = [||] then pats else
      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
      assert (acc = []); pats
    in
    add_timestamp var
      {pexp_loc = l; 
       pexp_desc = Pexp_match (exp, List.map2 (fun p e -> (p,e)) pats ebodies)}

(* Essentially the same as build_match.
   TODO: implement the same check on the timestamp of the expression to try
*)
let build_try : 
  Location.t -> Parsetree.expression -> string loc array -> 
  Parsetree.pattern list -> Parsetree.expression array ->
  Parsetree.expression =
  fun l exp names pats ebodies -> 
    let (exp,var)     = remove_tstamp None exp in (* must be an earlier tstamp*)
    let (ebodies,var) = map_accum remove_tstamp var (Array.to_list ebodies) in
    let pats = 
      if names = [||] then pats else
      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
      assert (acc = []); pats
    in
    add_timestamp var
      {pexp_loc = l; 
       pexp_desc = Pexp_try (exp, List.map2 (fun p e -> (p,e)) pats ebodies)}

(* Build the general let-Parsetree (like the fun-Parsetree) *)
let build_let : 
  Location.t -> rec_flag -> string loc array -> 
  Parsetree.pattern list -> 
  Parsetree.expression array ->         (* the first is the body of let *)
  Parsetree.expression =
  fun l recf names pats ebodies -> 
    let (ebodies,var) = map_accum remove_tstamp None (Array.to_list ebodies) in
    let pats = 
      if names = [||] then pats else
      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
      assert (acc = []); pats
    in
    match ebodies with
     | (body::el) ->
        add_timestamp var
          {pexp_loc = l; 
           pexp_desc = 
             Pexp_let (recf,List.map2 (fun p e -> (p,e)) pats el,body)}
     | _ -> assert false

ZZZZ
*)

(* ------------------------------------------------------------------------ *)
(* The main function to translate away brackets. It receives
   an expression at the level n > 0.

   Since bracket-translation is somewhat similar to un-typechecking,
   see tools/untypeast.ml for hints on mapping Typedtree.expression
   to Parsetree.expression.

TODO: an optimization idea. Consider <assert e> as a typical expression.
We translate it to the invocation of build_assert that will construct
the Parsetree node at run-time. However, of 'e' is simple (e.g., a constant)
then we can construct the Parsetree node at compile time and pass it
as a CSP. There are no longer any functions calls to make at run-time.
So, we can modify the translation of <assert e> below to detect
if the translation of e produced Texp_cspval. We extract the CSP value,
invoke build_assert (at compile time, when trx.ml is run) to build
the Pexp_assert node, and wrap it as a CSP.

*)

(* Given a type [ty], return [ty code code ... code] (n times code).
   When we push the bracket in, expressions that had type ty before
   will have the type ty code.
   Here, ty code is an abstract type whose concrete representation
   is code_repr.
   Generally speaking we don't have to adjust the types since the
   type checking is finished. However, code generator may look
   at types; it's better if we don't lie. Thus, as trx_bracket
   translates the expression, it should also adjust the types.
*)

let rec wrap_ty_in_code : int -> type_expr -> type_expr = fun n ty ->
  if n=0 then ty else
  (* let clsfier = Btype.newgenvar () in *)
  wrap_ty_in_code (n-1) (Predef.type_code ty)

let map_option : ('a -> 'b) -> 'a option -> 'b option = fun f -> function
  | None   -> None
  | Some x -> Some (f x)


let rec trx_bracket : 
  (expression -> expression) -> (* 0-level traversal *)
  int -> (expression -> expression) = fun trx_exp n exp ->
  let new_desc = match exp.exp_desc with
    (* Don't just do when vd.val_kind = Val_reg 
       because (+) or Array.get are Val_prim *)
(*
YYYY
  | Texp_ident (p,li,vd)  ->
    let stage = try Env.find_stage p exp.exp_env
	        with Not_found ->
                  if false then
                    debug_print ("Stage for var is set to implicit 0:" ^ 
	                         Path.name p ^ "\n");  [] in
    (* We make CSP only if the variable is bound at the stage 0.
       Variables bound at stage > 0 are subject to renaming.
       They are translated into stage 0 variable but of a different
       type (string loc), as explained in the title comments.
     *)
    if stage = [] then trx_csp exp p li 
    else
      texp_apply (texp_ident "Trx.build_ident")
        [texp_loc exp.exp_loc; 
         (* Future-stage bound variable becomes the present-stage
            bound-variable, but at a different type
          *)
         match texp_ident "Trx.sample_name" with (* fill in the type, etc.*)
         | {exp_desc = Texp_ident (_,_,vd); exp_type = ty}  ->
           {exp with exp_desc = Texp_ident(p,li,vd); exp_type = ty}
         | _ -> assert false]
*)

  | Texp_constant cst -> 
      texp_code ~node_id:"*cst*" exp.exp_loc (Pexp_constant cst)

(*
YYYY
     (* The most common case of let-expressions: let x = e in body *)
  | Texp_let (recf,[({pat_desc = Tpat_var (id,name)},e)],body) ->
      let recf_exp = texp_ident "Trx.sample_rec_flag" in
      let recf_exp = {recf_exp with exp_desc = 
                        Texp_cspval (Obj.repr recf, dummy_lid "*recf*")} in
      texp_binding_simple (id,name) (fun gensymed_var ->
        { exp with
          exp_type = wrap_ty_in_code n exp.exp_type; (* lifted type *)
          exp_desc = 
            texp_apply (texp_ident "Trx.build_let_simple") 
            [texp_loc exp.exp_loc;
             recf_exp;
             gensymed_var;
             trx_bracket trx_exp n e;
             trx_bracket trx_exp n body] })

  | Texp_let (recf,pel,body) ->         (* General case. Like Texp_function *)
      let recf_exp = texp_ident "Trx.sample_rec_flag" in
      let recf_exp = {recf_exp with exp_desc = 
                        Texp_cspval (Obj.repr recf, dummy_lid "*recf*")} in
      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
      texp_binding_pattern pel exp
       (fun gensyms pats exps ->
        { exp with
          exp_desc = 
            texp_apply (texp_ident "Trx.build_let") 
            [texp_loc exp.exp_loc;
             recf_exp;
             texp_array gensyms;
             pats;
             texp_array (trx_bracket trx_exp n body::
                         (List.map (trx_bracket trx_exp n) exps))]
        })


     (* The most common case of functions: fun x -> body *)
  | Texp_function (l,[({pat_desc = Tpat_var (id,name)},ebody)],_) ->
      texp_binding_simple (id,name) (fun gensymed_var ->
        { exp with
          exp_type = wrap_ty_in_code n exp.exp_type; (* lifted type *)
          exp_desc = 
            texp_apply (texp_ident "Trx.build_fun_simple") 
            [texp_loc exp.exp_loc;
             texp_string l;
             gensymed_var;
             trx_bracket trx_exp n ebody] })

  | Texp_function (l,pel,_) ->
      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
      texp_binding_pattern pel exp
       (fun gensyms pats exps ->
        { exp with
          exp_desc = 
            texp_apply (texp_ident "Trx.build_fun") 
            [texp_loc exp.exp_loc;
             texp_string l;
             texp_array gensyms;
             pats;
             texp_array (List.map (trx_bracket trx_exp n) exps)]
        })

  | Texp_apply (e, el) ->
     (* first, we remove from el the information added by the type-checker *)
     let lel = List.fold_right (function                 (* keep the order! *)
                | (_,None,_)   -> fun acc -> acc
                | (l,Some e,_) -> fun acc -> (l,e)::acc) el [] in
     let lel = ("",e) :: lel in          (* Add the operator *)
      texp_apply (texp_ident "Trx.build_apply")
        [texp_loc exp.exp_loc; 
         texp_array (List.map (fun (l,e) ->
           texp_tuple [texp_string l;trx_bracket trx_exp n e]) lel)]

  (* Pretty much like a function *)
  (* Since e and pel don't share any bindings (the type-checker appropriately
     renamed all variables into timestamped Ident), there is no
     harm done if we evaluate 'e' within the scope of with_binding_region.
     Weakening is admissible. Old MetaOCaml did something similar.
     What about the scope extrusion check? build_match should make sure
     the expression to match has an earlier tstamp.
   *)
  | Texp_match (e,pel,_) ->
      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
      texp_binding_pattern pel exp
       (fun gensyms pats exps ->
        { exp with
          exp_desc = 
            texp_apply (texp_ident "Trx.build_match") 
            [texp_loc exp.exp_loc;
             trx_bracket trx_exp n e;
             texp_array gensyms;
             pats;
             texp_array (List.map (trx_bracket trx_exp n) exps)]
        })

  | Texp_try (e,pel) ->                 (* same as Texp_match *)
      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
      texp_binding_pattern pel exp
       (fun gensyms pats exps ->
        { exp with
          exp_desc = 
            texp_apply (texp_ident "Trx.build_try") 
            [texp_loc exp.exp_loc;
             trx_bracket trx_exp n e;
             texp_array gensyms;
             pats;
             texp_array (List.map (trx_bracket trx_exp n) exps)]
        })

  | Texp_tuple el ->
      texp_apply (texp_ident "Trx.build_tuple")
        [texp_loc exp.exp_loc; 
	 texp_array (List.map (trx_bracket trx_exp n) el)]

  | Texp_construct (li, cdesc, args, explicit_arity) ->
      let lid = qualify_ctor li.loc p cdesc in
      texp_apply (texp_ident "Trx.build_construct")
        [texp_loc exp.exp_loc; 
         texp_lid lid;
	 texp_array (List.map (trx_bracket trx_exp n) args);
         texp_bool explicit_arity]

  | Texp_variant (l,eo) ->              (* polymorphic variant *)
      texp_apply (texp_ident "Trx.build_variant")
        [texp_loc exp.exp_loc; 
         texp_string l;
	 texp_option (map_option (trx_bracket trx_exp n) eo)]

  | Texp_record (lel,eo) ->
      texp_apply (texp_ident "Trx.build_record")
        [texp_loc exp.exp_loc; 
         texp_array (List.map (fun (p,li,ldesc,e) ->
           texp_tuple [texp_lid (qualify_label li.loc p ldesc);
                       trx_bracket trx_exp n e]) lel);
         texp_option (map_option (trx_bracket trx_exp n) eo)]

  | Texp_field (e,p,li,ldesc) ->
      texp_apply (texp_ident "Trx.build_field")
        [texp_loc exp.exp_loc; 
         trx_bracket trx_exp n e;
         texp_lid (qualify_label li.loc p ldesc)]

  | Texp_setfield (e1,p,li,ldesc,e2) ->
      texp_apply (texp_ident "Trx.build_setfield")
        [texp_loc exp.exp_loc; 
         trx_bracket trx_exp n e1;
         texp_lid (qualify_label li.loc p ldesc);
         trx_bracket trx_exp n e2]

  | Texp_array el ->
      texp_apply (texp_ident "Trx.build_array")
        [texp_loc exp.exp_loc; 
	 texp_array (List.map (trx_bracket trx_exp n) el)]

  | Texp_ifthenelse (e,et,efo) ->
      texp_apply (texp_ident "Trx.build_ifthenelse")
        [texp_loc exp.exp_loc; 
         trx_bracket trx_exp n e;
         trx_bracket trx_exp n et;
	 texp_option (map_option (trx_bracket trx_exp n) efo)]
*)
  | Texp_sequence (e1,e2) ->
      texp_apply (texp_ident "Trx.build_sequence")
        [texp_loc exp.exp_loc; 
	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
  | Texp_while (e1,e2) ->
      texp_apply (texp_ident "Trx.build_while")
        [texp_loc exp.exp_loc; 
	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
(*
  | Texp_for (id, name, elo, ehi, dir, ebody) ->
      texp_binding_simple (id,name) (fun gensymed_var ->
        { exp with
          exp_type = wrap_ty_in_code n exp.exp_type; (* lifted type of for *)
          exp_desc = 
            texp_apply (texp_ident "Trx.build_for") 
            [texp_loc exp.exp_loc;
             gensymed_var;
             trx_bracket trx_exp n elo;
             trx_bracket trx_exp n ehi;
             texp_bool (dir = Upto);
             trx_bracket trx_exp n ebody] })
*)

  | Texp_when (e1,e2) ->
      texp_apply (texp_ident "Trx.build_when")
        [texp_loc exp.exp_loc; 
	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
(*
  | Texp_send (e,m,_) ->
      (* We don't check the persistence of the method: after all,
         a method name is somewhat like a polymorphic variant.
         It's perfectly OK to have a function fun x -> x # foo
      *)
      texp_apply (texp_ident "Trx.build_send")
        [texp_loc exp.exp_loc; 
	 trx_bracket trx_exp n e;
         texp_string (match m with
                        | Tmeth_name name -> name
                        | Tmeth_val id -> Ident.name id)]
*)

  | Texp_new (p,li,_) ->
      check_path_quotable "Class" p;
      texp_code ~node_id:"*new*" exp.exp_loc 
        (Pexp_new (Location.mkloc (path_to_lid p) li.loc))

  | Texp_instvar (p1,p2,s) ->
      not_supported exp.exp_loc "Objects (Texp_instvar)"
        (* Alternatively: since instance variables are always bound 
           at level 0 (for now)
           so this is like a csp variable 
        call_trx_mkcsp exp None (path_to_lid p2)
        *)
  | Texp_setinstvar _ -> not_supported exp.exp_loc "Objects (Texp_setinstvar)"
  | Texp_override  _  -> not_supported exp.exp_loc "Objects (Texp_override)"
  | Texp_letmodule (id,s,me,e) -> not_supported exp.exp_loc "let module"

  | Texp_assert e ->
      texp_apply (texp_ident "Trx.build_assert")
        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
  | Texp_assertfalse ->
      texp_code ~node_id:"*af*" exp.exp_loc Pexp_assertfalse

  | Texp_lazy e ->
      texp_apply (texp_ident "Trx.build_lazy")
        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]

  | Texp_object (cl,fl) -> not_supported exp.exp_loc "Objects"
  | Texp_pack _         -> not_supported exp.exp_loc "First-class modules"

  | Texp_bracket e ->
      texp_apply (texp_ident "Trx.build_bracket")
        [texp_loc exp.exp_loc; trx_bracket trx_exp (n+1) e]
  | Texp_escape e ->
      if n = 1 then (trx_exp e).exp_desc	(* switch to 0 level *)
      else
      texp_apply (texp_ident "Trx.build_escape")
        [texp_loc exp.exp_loc; trx_bracket trx_exp (n-1) e]
  | Texp_cspval (v,li) ->               (* CSP is a sort of a constant *)
      texp_code ~node_id:"*csp*" exp.exp_loc (Pexp_cspval(v,li))

  | _ -> not_supported exp.exp_loc "not yet supported" (* YYYYY *)
  in                               
  let trx_extra (extra, loc) exp = (* See untype_extra in tools/untypeast.ml *)
   let desc =
    match extra with
      (* Should check that cty1 and cty2 contain only globally declared
         type components
       *)
    | Texp_constraint (cty1, cty2) -> 
        not_supported loc "Texp_constraint"
    | Texp_open (ovf, path, lid, _) -> not_supported loc "not yet supported" (* XXX *)
(* YYY
    | Texp_open (ovf, path, lid, _) -> 
       check_path_quotable "Texp_open" path;
       texp_apply (texp_ident "Trx.build_open")
        [texp_loc exp.exp_loc; 
XXX need ovf
         texp_lid (mkloc (path_to_lid path) lid.loc);
         exp]      (* exp is the result of trx_bracket *)
*)
    | Texp_poly cto  -> not_supported loc "Texp_poly"
    | Texp_newtype s -> not_supported loc "Texp_newtype"
    in {exp with exp_loc = loc; exp_desc = desc} (* type is the same: code *)
  in
  List.fold_right trx_extra exp.exp_extra
  {exp with exp_type = wrap_ty_in_code n exp.exp_type;
            exp_desc = new_desc}



(*{{{ Typedtree traversal to eliminate bracket/escapes *)

(* ------------------------------------------------------------------------ *)
(* Typedtree traversal to eliminate bracket/escapes *)

(* Functions to help traverse and transform a tree.
   We assume that every tree mapping function of the type 'a -> 'a
   throws the exception Not_modified if the tree has not been
   modified.
   This protocol helps minimize garbage and prevent useless tree
   duplication.
*)

exception Not_modified

let replace_list : ('a -> 'a) -> 'a list -> 'a list = fun f l ->
  let rec loop mdf = function
  | [] -> if mdf then [] else raise Not_modified
  | h::t -> match (try Some (f h) with Not_modified -> None) with
             | Some h -> h :: loop true t
             | None   -> h :: loop mdf  t
  in loop false l

let replace_pair : ('a -> 'a) -> ('b -> 'b) -> 'a * 'b -> 'a * 'b =
  fun f g (x,y) ->
  match ((try Some (f x) with Not_modified -> None),
         (try Some (g y) with Not_modified -> None)) with
  | (None,None)      -> raise Not_modified
  | (Some x, None)   -> (x,y)
  | (None, Some y)   -> (x,y)
  | (Some x, Some y) -> (x,y)

let replace_opt : ('a -> 'a) -> 'a option -> 'a option = fun f -> function
  | Some e -> Some (f e)
  | None   -> raise Not_modified

(* The main function to scan the typed tree at the 0 level and
   detect brackets 
*)

let rec trx_struct str =
  {str with str_items = 
  replace_list (fun si -> {si with str_desc = trx_struct_item si.str_desc})
           str.str_items}

and trx_struct_item = function
| Tstr_eval e -> Tstr_eval (trx_exp e)
| Tstr_value (rf,pel) ->
    Tstr_value(rf, replace_list (fun (p,e) -> (p, trx_exp e)) pel)
| Tstr_primitive (_,_,_) 
| Tstr_type _
| Tstr_exception (_,_,_)
| Tstr_exn_rebind (_,_,_,_) -> raise Not_modified
| Tstr_module (i,l,me) -> Tstr_module (i, l, trx_me me)
| Tstr_recmodule l ->
  Tstr_recmodule (replace_list (fun (i,l,mt,me) -> (i,l,mt,trx_me me)) l)
| Tstr_modtype (_,_,_)
| Tstr_open (_,_,_) -> raise Not_modified
| Tstr_class l ->
    Tstr_class (replace_list (fun (dcl,sl,vf) -> (trx_cdcl dcl,sl,vf)) l)
| Tstr_class_type _ -> raise Not_modified
| Tstr_include (me,il) -> Tstr_include (trx_me me, il)

and trx_me me = 
  {me with mod_desc = trx_me_desc me.mod_desc} 

and trx_me_desc = function
| Tmod_ident _ -> raise Not_modified
| Tmod_structure str -> Tmod_structure (trx_struct str)
| Tmod_functor (i,l,t,me) -> Tmod_functor (i,l,t, trx_me me)
| Tmod_apply (me1,me2,mc) ->
  let (me1,me2) = replace_pair trx_me trx_me (me1,me2) in
  Tmod_apply (me1, me2, mc)
| Tmod_constraint (me,mt,mtc,mc) -> Tmod_constraint (trx_me me, mt, mtc, mc)
| Tmod_unpack (e,mt) -> Tmod_unpack (trx_exp e,mt)

and trx_cdcl class_decl =
  {class_decl with ci_expr = trx_ce class_decl.ci_expr}

and trx_ce class_expr =
  {class_expr with cl_desc = trx_ce_desc class_expr.cl_desc}

and trx_cl_struct cs =
  {cs with cstr_fields = 
     replace_list (fun cf -> {cf with cf_desc = trx_cf cf.cf_desc})
                  cs.cstr_fields}

and trx_ce_desc = function
| Tcl_ident (_,_,_) -> raise Not_modified
| Tcl_structure cs ->
  Tcl_structure (trx_cl_struct cs)
| Tcl_fun (l,p,el,ce,pa) ->
  let (el,ce) = 
        replace_pair (replace_list (fun (i,l,e) -> (i,l,trx_exp e)))
                     trx_ce (el,ce) in
  Tcl_fun (l,p,el,ce,pa)
| Tcl_apply (ce,el) ->
  let repel (l,eo,o) = (l,replace_opt trx_exp eo,o) in
  let (ce,el) = replace_pair trx_ce (replace_list repel) (ce,el) in
  Tcl_apply (ce,el)
| Tcl_let (rf,el1,el2,ce) ->
  let repel1 = replace_list (fun (p,e) -> (p,trx_exp e)) in
  let repel2 = replace_list (fun (i,l,e) -> (i,l,trx_exp e)) in
  let ((el1,el2),ce) = replace_pair (replace_pair repel1 repel2) trx_ce
                        ((el1,el2),ce)
  in Tcl_let (rf,el1,el2,ce)
| Tcl_constraint (ce,ct,sl1,sl2,cty) ->
  Tcl_constraint (trx_ce ce,ct,sl1,sl2,cty)

and trx_cf = function
| Tcf_inher (ofl,ce,so,sl1,sl2) ->
  Tcf_inher (ofl,trx_ce ce,so,sl1,sl2)
| Tcf_val (_,_,_,_,Tcfk_virtual _,_) -> raise Not_modified
| Tcf_val (s,l,mf,i,Tcfk_concrete e,b) ->
  Tcf_val (s,l,mf,i,Tcfk_concrete (trx_exp e),b)
| Tcf_meth (s,l,pf,Tcfk_virtual _,_) -> raise Not_modified
| Tcf_meth (s,l,pf,Tcfk_concrete e,b) ->
  Tcf_meth (s,l,pf,Tcfk_concrete (trx_exp e),b)
| Tcf_constr (_,_) -> raise Not_modified
| Tcf_init e -> Tcf_init (trx_exp e)

and trx_exp exp =
  {exp with exp_desc = trx_expression exp.exp_desc}

and trx_pelist l = replace_list (fun (p,e) -> (p,trx_exp e)) l
and trx_expression = function
| Texp_ident (_,_,_)
| Texp_constant _ -> raise Not_modified
| Texp_let (rf, el, e) ->
  let (el,e) = replace_pair trx_pelist trx_exp (el,e)
  in Texp_let (rf, el, e)
| Texp_function (l,el,p) ->
  Texp_function (l,trx_pelist el,p)
| Texp_apply (e,el) ->
  let repl (l,eo,op) = (l,replace_opt trx_exp eo,op) in
  let (e,el) = replace_pair trx_exp (replace_list repl) (e,el)
  in Texp_apply (e,el)
| Texp_match (e,el,p) ->
  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
  in Texp_match (e,el,p)
| Texp_try (e,el) ->
  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
  in Texp_try (e,el)
| Texp_tuple l -> Texp_tuple (replace_list trx_exp l)
| Texp_construct (l,cd,el,b) ->
  Texp_construct (l,cd,replace_list trx_exp el,b)
| Texp_variant (l,eo) -> Texp_variant (l,replace_opt trx_exp eo)
| Texp_record (ll,eo) ->
  let repll (l,ld,e) = (l,ld,trx_exp e) in
  let (ll,eo) = replace_pair (replace_list repll) (replace_opt trx_exp) (ll,eo)
  in Texp_record (ll,eo)
| Texp_field (e,l,ld) -> Texp_field (trx_exp e,l,ld)
| Texp_setfield (e1,l,ld,e2) ->
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_setfield (e1,l,ld,e2)
| Texp_array el -> Texp_array (replace_list trx_exp el)
| Texp_ifthenelse (e1,e2,eo) ->
  let ((e1,e2),eo) = replace_pair (replace_pair trx_exp trx_exp) 
                                  (replace_opt trx_exp) ((e1,e2),eo)
  in Texp_ifthenelse (e1,e2,eo)
| Texp_sequence (e1,e2) -> 
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_sequence (e1,e2)
| Texp_while (e1,e2) ->
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_while (e1,e2)
| Texp_for (i,l,e1,e2,df,e3) ->
  let ((e1,e2),e3) = replace_pair (replace_pair trx_exp trx_exp) 
                                  trx_exp ((e1,e2),e3)
  in Texp_for (i,l,e1,e2,df,e3)
| Texp_when (e1,e2) ->
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_when (e1,e2)
| Texp_send (e1,m,eo) ->
  let (e1,eo) = replace_pair trx_exp (replace_opt trx_exp) (e1,eo)
  in Texp_send (e1,m,eo)
| Texp_new (_,_,_)
| Texp_instvar (_,_,_) -> raise Not_modified
| Texp_setinstvar (p1,p2,l,e) -> Texp_setinstvar (p1,p2,l,trx_exp e)
| Texp_override (p, el) ->
  Texp_override (p, replace_list (fun (p,l,e) -> (p,l,trx_exp e)) el)
| Texp_letmodule (i,l,me,e) ->
  let (me,e) = replace_pair trx_me trx_exp (me,e)
  in Texp_letmodule (i,l,me,e)
| Texp_assert e -> Texp_assert (trx_exp e)
| Texp_assertfalse -> raise Not_modified
| Texp_lazy e -> Texp_lazy (trx_exp e)
| Texp_object (cs,sl) -> Texp_object (trx_cl_struct cs,sl)
| Texp_pack me -> Texp_pack (trx_me me)

| Texp_bracket e -> 
   let trx_exp e = try trx_exp e with Not_modified -> e in
  (trx_bracket trx_exp 1 e).exp_desc

| Texp_escape _ -> assert false         (* Not possible in well-typed code *)
| Texp_cspval (_,_) -> raise Not_modified


(* public interface *)
let trx_structure str = 
  try trx_struct str with Not_modified -> str

(*}}}*)

  
(*{{{ Historical: hints on native mode CSP *)

(* Native mode is moved out to the `userland'

let remove_texp_cspval exp =
  if !native_mode = false then exp else
  failwith "native mode CSP are not impemented yet"

   XXX old code
  match exp.exp_desc with
  | Texp_cspval (v,l) ->
      let i = add_csp_value (v,l) in
      let exp' = {exp with exp_desc = Texp_constant (Const_int i)} in
      let desc = if !initial_native_compilation
        then (Texp_apply (trx_array_get exp, [(Some !local_csp_arr_texp, Required);(Some exp', Required)]))
	else (Texp_apply (trx_get_csp_value exp, [(Some exp', Required)])) in
      {exp with exp_desc = desc}
  | _ -> assert false
*)

(*}}}*)
