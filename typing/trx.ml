(*
  This file is to post-process the Typedtree built by the type checker
  when it finished parsing the present-stage bracket expression.
  (Unlike versions before N102, the full Typedtree is not traversed;
  only the bracket expressions are traversed and lifted.) The
  transformation is done by trx_bracket.

  For example,
     <succ 1> 
  gets transformed to 
     mkApp <succ> <1> 
  and eventually to
     mkApp (mkIdent "succ") (mkConst 1)
  One may say that we `push the brackets inside'.  We replace brackets
  with calls to functions that will construct, at run-time, a
  Parsetree, which is the representation of values of the code type.

  Generally, the Parsetree is constructed when the program is run.
  In some cases we can construct the Parsetree at compile time,
  that is, when this trx.ml is run. Constants like <1> is such a case.
  If we see <1>, or, in terms of trees,
      Texp_bracket (Texp_constant (Constant_int 1))
  we can immediately construct the Parsetree:
      Pexp_constant (Constant_int 1)
  After we construct the Parsetree at compile time, we use CSP to
  pass it over to run-time. At run-time, we merely use the compiled constant.
  This mechanism of building Parsetree at compile-time whenever possible
  is one of the large differences from the previous versions of MetaOCaml.

  Future-stage Bindings.
  Future-stage bindings are introduced by patterns in let, fun,
  match, try and for forms. Global bindings are always at present-stage.
  Since local modules in brackets are not allowed, all future bindings are
  unqualified (i.e., simple names, without the module path).
  The principal rule of translating binding forms is
     <fun x -> e> ---> let x = gensym "x" in mkLAM x <e>
  Emphatically, gensym cannot be run at compile time!
  Reason: consider the recursive invocation:
     let rec f z = <fun y -> ~( ... f 1 ... )>

  Thus, at run-time, we generate new names for bound variables and
  use the OCaml's evaluator (the `run-time') to substitute these
  new names in <e>. Therefore, a future-stage bound variable after
  the translation becomes a present-stage bound variable,
  but at a different type: string loc. We use string loc rather
  than Longident.t loc since all, at present, future-stage bindings
  are simple names.

  We now check for scope extrusion: we enforce the region discipline
  for generated identifiers. To make it easier to impose checks,
  the translation rule is modified as follows
     <fun x -> e> ---> build_simple_fun "x" (fun x -> <e>)
  One can say that <fun x -> e> of the type (a->b) code is translated
  into (fun x -> <e>) of the type a code -> b code. This looks quite
  like the HOAS syntax for lambda (see the code-generation approach
  with code combinators. The function build_simple_fun generates a gensym
  and establishes a region for the gensym variable.

  OCaml has more complicated functions, <function pattern -> body> with
  complex patterns. If the patterns contain no binding variables,
  there is no need to go into the gensym generation. The translation is
  no more complex than that of <lazy e>. 
  For more complicated binding patterns, we generalize, for example
     <fun (x1,true,x2) as x3 -> e1 | _ -> e2> ---> 
       build_fun ["x1";"x2"] (fun (x1,x2,x3) -> [<e1>;e2])
  That is, we pick all binding variables from the pattern and build a
  function that receives the code for these variables and produces the
  array of code for all alternatives.

  Here are the main patterns of scope extrusion
  let r = <0> in 
  <fun x -> ~(r := <x + 1>; <()>)>

  let r = <0> in
  <fun x -> .~(<fun x -> ~(let v = <x> in r := <fun x -> ~v>; <()>)>; !r)>

  exception E of int code
  try <fun x -> ~(raise (E <x>)> with E x -> x
  (actually we need a local polymorphic exception, but the idea is the same)

  and similar using control effects.

  The most obvious method of detecting the scope extrusion is traversing
  the generated code looking for unbound identifiers. We can do
  such a check when we are about to show or run the code, or
  about to splice (in the latter case, we have to maintain
  the dynamic environment of gensym'ed names generated by 
  build_fun_). However, reporting the scope
  extrusion upon printing or running the code is reporting it too
  late. Doing the check on each escape (since only splices can incorporate
  scope-extruded code) means many repeated traversals of the generated
  code.

  We use a different method: we mark each piece of the generated code
  with the list of free variable the code contains. Each variable
  is associated with a `stackmark', which identifiers the region
  with which the variable is associated. All valid stackmarks form
  a total order. Alas, delimited control can reshuffle that order.
  The function build_simple_fun and others enter a new region
  and then check that the generated body contains only valid stackmarks
  (that is, stackmarks that correspond to active regions). 
  Every code building function ( build_* ) checks to see that the stackmarks
  in the incorporated fragments are all valid, that is,
  correspond currently alive variables. These code building function
  merge the free variable lists (heaps actually) from the incorporated
  fragments.

This file was based on trx.ml from the original MetaOCaml, but it is
completely re-written from scratch and has many comments. The
traversal algorithm, the way of compiling Parsetree builders, dealing
    with CSP and many other algorithms are all different.

*)

open Parsetree
open Asttypes
open Typedtree
open Types


(*{{{ Preliminaries, common functions *)

(* BER MetaOCaml version string *)
let meta_version  = "N 102"

(* Co-opt the Preprocessor class of warnings *)
let debug_print ?(loc = Location.none) : string -> unit = fun msg ->
  Location.prerr_warning loc (Warnings.Preprocessor msg)

(* Emit a translation-time error *)
exception Error of Location.error

let trx_error loc_err = raise @@ Error loc_err

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some err
      | _         -> None
    )

let not_supported loc msg =
  trx_error @@ Location.errorf ~loc
      "%s is not yet supported within brackets" msg

(* left-to-right accumulating map *)
let rec map_accum : ('accum -> 'a -> 'b * 'accum) -> 'accum -> 'a list ->
  'b list * 'accum = fun f acc -> function
    | []   -> ([],acc)
    | h::t -> 
        let (h,acc) = f acc h in
        let (t,acc) = map_accum f acc t in
        (h::t, acc)

let initial_env = Env.initial_safe_string

(* Attributes *)
(* In a Parsetree, brackets, escape and CSPs are attributes on 
   the corresponding nodes. 
*)

let attr_bracket = (Location.mknoloc "metaocaml.bracket",PStr [])

let attr_escape = (Location.mknoloc "metaocaml.escape",PStr [])

let rec get_attr : string -> attributes -> Parsetree.structure option =
  fun name -> function
    | [] -> None
    | ({txt = n}, PStr str) :: _ when n = name -> Some str
    | _ :: t -> get_attr name t

let attr_csp : Longident.t loc -> attribute = fun lid ->
  (Location.mknoloc "metaocaml.csp",PStr [
     Ast_helper.Str.eval (Ast_helper.Exp.ident lid)])

(* If the attribute is present, the expression is non-expansive 
   We use physical equality comparison, to speed things up
*)
let attr_nonexpansive : attribute = 
  (Location.mknoloc "metaocaml.nonexpansive",PStr [])

  
(* The result of what_stage_attr *)
type stage_attr_elim = 
  | Stage0
  | Bracket of attribute * (* bracket attribute *)
               attributes  (* other attributes  *)
  | Escape  of attribute * (* escape attribute *)
               attributes  (* other attributes  *)
  | CSP     of attribute * Longident.t loc * (* CSP attribute and lid *)
               attributes  (* other attributes  *)

(* Determining if an AST node bears a staging attribute *)
let what_stage_attr : attributes -> stage_attr_elim =
  let rec loop acc = function
    | [] -> Stage0
    | (({txt = "metaocaml.bracket"},_) as a) :: t -> 
        Bracket (a,acc @ t)
    | (({txt = "metaocaml.escape"},_) as a) :: t -> 
        Escape (a,acc @ t)
    | (({txt = "metaocaml.csp"},PStr [{pstr_desc = 
            Pstr_eval ({pexp_desc=Pexp_ident lid},_)}]) as a) :: t -> 
        CSP (a,lid,acc @ t)
    | a :: t -> loop (a::acc) t
  in loop []

(* Staging level 
   It is set via an attribute on the value_description in the Typedtree 
*)
type stage = int                        (* staging level *)

let attr_level n = 
  (Location.mknoloc "metaocaml.level",PStr [
   Ast_helper.Str.eval (Ast_helper.Exp.constant (Const_int n))])

let get_level : Parsetree.attributes -> stage = fun attrs ->
  match get_attr "metaocaml.level" attrs with
  | None -> 0
  | Some [{pstr_desc = 
            Pstr_eval ({pexp_desc=Pexp_constant (Const_int n)},_)}] -> 
     assert (n>=0); n
  | _ -> assert false  (* Invalid level attribute *)


(* In a Typedtree, <e> is represented as a sequence
        begin 0; e end
   again, with the corresponding attribute.
   I chose 0 rather than () because if we forget to handle
   bracket/escape properly, we get a warning. Still, begin 0; e end
   is syntactically and type-correct .
   Ditto for Escape.
*)

(*}}}*)


(*{{{ Path and location utilities *)

(* ------------------------------------------------------------------------ *)
(* Path utilities *)

(* We always use path when available, and convert it to Longident
   when needed -- even if the Typedtree already carries the longident.
   The path is preferred because it is fully qualified for
   external identifiers and it is unambiguous.
   If we open a module, its components can be referred to without
   qualification -- the path will be qualified nevertheless.
   When we build a Parsetree representing the generated code,
   we have to use fully qualified identifiers since the open statement
   in the original code won't be represented in the generated
   Parsetree.
*)

(* Check to see if a path refers to an identifier, exception, or
   constructor that is available from an external module. If so, the run-time
   compiler invoked by run can get the definition for the identifier from
   a .cmi file. The value of an external identifier can be obtained from
   a .cmo file.
   If a path containst several components like
   M1.M2.M3.ident, we should check if the top-most component, that is, M1,
   is external.
*)
(* XXX call Env.normalize_path first? *)

let rec is_external = function
  | Path.Pident id ->           (* not qualified *)
      Ident.persistent id || Ident.global id || Ident.is_predef_exn id
  | Path.Papply _     -> false
  | Path.Pdot(p, _,_) -> is_external p

(* Convert a path to an identifier. Since the path is assumed to be
   `global', time stamps don't matter and we can use just strings.
*)
let rec path_to_lid : Path.t -> Longident.t = function
  | Path.Pident i       -> Longident.Lident (Ident.name i)
  | Path.Pdot (p,s,_)   -> Longident.Ldot (path_to_lid p, s)
  | Path.Papply (p1,p2) ->
      Longident.Lapply(path_to_lid p1, path_to_lid p2)

(* Convert the path to lid but use the given str as the last component.
   This in effect qualifies 'str' with the given module path
*)
let path_to_lid_but_last : Path.t -> string -> Longident.t =
  fun p str ->
    match p with
    | Path.Pident _ -> Longident.Lident str
    | Path.Pdot (p,_,pos) -> path_to_lid (Path.Pdot (p,str,pos))
    | _ -> assert false

(* Replace the last component of p1 with p2, which should be a Pident
   path 
*)
let path_replace_last : Path.t -> Path.t -> Path.t = fun p1 p2 ->
 match (p1,p2) with
  | (Path.Pident _,x) -> x
  | (Path.Pdot(p1,_,s),Path.Pident id) -> Path.Pdot(p1,Ident.name id,s)
  | _ -> assert false


(* Check to make sure a constructor, label, exception, etc.
   have the name that we can put into AST (Parsetree).
   Local names can't be put into the Parsetree since the type env in which
   they are declared is not represented in the Parsetree.
*)
let check_path_quotable msg path =
  if not (is_external path) then
    trx_error @@ Location.errorf
        "%s %s cannot be used within brackets. Put into a separate file."
        msg (Path.name path)


(* Check to see that a constructor belongs to a type defined
   in a persistent module or in the initial environment.
   Return the fully qualified name to put into AST 
   (Pervasive constructors remain unqualified however).

   We have nothing to do if the constructor is already fully qualified
   with a persistent module identifier: for example, Scanf.Scan_failure.
   The major complexity comes from this scenario:
      open Scanf
      .<raise (Scan_failure "xx")>.
   The Texp_construct node of Typedtree contains the lid and (was: the
   path) that refer to "Scan_failure" without any module qualifications.
   We have to find the fully qualified path and check
   that it is external. We do that by finding the path for the _type_
   constructor, for the type of which the data constructor is a member.
   That type_path is fully qualified. We can ascertain the later fact
   from Env.constructors_of_type, which puts the complete path
   into the type of the constructor, which is always of the form
   Tconstr(ty_path,_,_). The function constructors_of_type is used
   within Env.store_type, which is used when opening a module.

   Alternatively we could've used Env.lookup_constuctor, which also
   returns the qualified path? Searching the environment is costly
   though.
   Actually, using Env.lookup_constuctor is a bad idea. Now labels and
   constructors don;t have to be unique. The type checker goes to
   a great length to disambiguate a constructor or a label. It records
   the eventually determined type of the label/constructor in
   label_description or constructor_description.
   So, we should only use information from these descriptions.

   Alas, the predefined types (with no module qualification) are
   not specially distinguished. So, we have to check the initial
   environment.
 *)
let qualify_ctor : 
    Longident.t loc -> constructor_description -> Longident.t loc = 
 fun lid cdesc ->
  let loc = lid.loc in
  match (cdesc.cstr_tag, Ctype.repr cdesc.cstr_res) with
  | (Cstr_extension (p,_),_) ->
      if is_external p then Location.mkloc (path_to_lid p) loc else
       trx_error @@ Location.errorf ~loc
       "Exception (extension) %s cannot be used within brackets. Put into a separate file."
        (Path.name p)
  | (_,{desc = Tconstr((Path.Pident _ as ty_path), _, _)}) ->
     begin
      try ignore (Env.find_type ty_path initial_env); lid
      with Not_found ->
        trx_error @@ Location.errorf ~loc
        "Unqualified constructor %s cannot be used within brackets. Put into a separate file."
          cdesc.cstr_name
     end
  | (_,{desc = Tconstr(ty_path, _, _)}) ->
      if is_external ty_path then
        Location.mkloc (path_to_lid_but_last ty_path cdesc.cstr_name) loc
      else
      trx_error @@ Location.errorf ~loc
      "Constructor %s cannot be used within brackets. Put into a separate file."
          cdesc.cstr_name
  | _ -> Printtyp.type_expr Format.err_formatter cdesc.cstr_res;
           failwith ("qualify_ctor: cannot determine type_ctor from data_ctor "^
                     cdesc.cstr_name)

(* Check to see that a record label belongs to a record defined
   in a persistent module or in the initial environment.
   This is a label version of qualify_ctor
*)
let qualify_label : Longident.t loc -> label_description -> Longident.t loc =
 fun lid ldesc ->
  let loc = lid.loc in
  match Ctype.repr ldesc.lbl_res with
  | {desc = Tconstr((Path.Pident _ as ty_path), _, _)} ->
    begin
      try ignore (Env.find_type ty_path initial_env); lid
      with Not_found ->
        trx_error @@ Location.errorf ~loc
        "Unqualified label %s cannot be used within brackets. Put into a separate file."
          ldesc.lbl_name
    end
  | {desc = Tconstr(ty_path, _, _)} ->
      if is_external ty_path then
        Location.mkloc 
          (path_to_lid_but_last ty_path ldesc.lbl_name) loc
      else
        trx_error @@ Location.errorf ~loc
          "Label %s cannot be used within brackets. Put into a separate file."
          ldesc.lbl_name
  | _ -> Printtyp.type_expr Format.err_formatter ldesc.lbl_res;
           failwith ("qualify_label: cannot determine type from label "^
                     ldesc.lbl_name)

(* Test if we should refer to a CSP value by name rather than by
   value
*)
(* Module identifiers for the modules that are expected to be
   present at run-time -- that is, will be available for
   dynamic linking of the run-time generated code.

TODO: check bytecomp/transclass.ml:const_path
Perhaps that's a hint which unqualified identifiers will be persistent
*)

let ident_can_be_quoted = is_external

(*}}}*)


(*{{{ Templates for building Parsetree/Typedtree components *)

(* Local reference: trx.cmi is available but location.cmi is not
   necessarily is in the current path.
*)
let loc_none = Location.none

let dummy_lid : string -> Longident.t loc = fun name ->
  Location.mknoloc (Longident.Lident name)

(* Exported. Used as a template for constructing lid expressions *)
let sample_lid = dummy_lid "*sample*"

(* Exported. Used as a template for constructing name expression *)
let sample_name : string loc = mknoloc "*sample*"

(* Exported. Used as a template for constructing pattern lists expressions *)
let sample_pat_list : Parsetree.pattern list = []
let sample_pats_names : Parsetree.pattern list * string loc list = ([],[])

(*}}}*)


(* ------------------------------------------------------------------------ *)
(* Building Texp nodes *)
(* initial_env is used for all look-ups. Unqualified identifiers
   must be found there. For qualified identifiers, Env.lookup
   functions look things up in the persistent structures, loading them
   up as needed.
*)

let mk_texp : ?env:Env.t -> ?attrs:Parsetree.attributes ->
              ?loc:Location.t ->
              Typedtree.expression_desc -> type_expr -> 
  Typedtree.expression =
  fun ?(env=initial_env) ?(attrs=[]) ?(loc=Location.none) desc ty ->
  { exp_desc = desc; exp_type = ty;
    exp_loc  = loc; exp_extra = [];
    exp_attributes = attrs;
    exp_env  = env }

let texp_int : int -> Typedtree.expression = fun n ->
  mk_texp ~env:Env.initial_safe_string (Texp_constant (Const_int n))
    (Ctype.instance_def Predef.type_int)

(* Make a bracket or an escape node
   Here, the attr argument is a bracket/escape attribute
*)
let texp_zero = (* TExp node for constant 0 *)
  texp_int 0

let texp_braesc : 
  attribute -> Typedtree.expression -> Env.t -> type_expr -> 
  Typedtree.expression =
  fun attr exp env ty ->
    mk_texp ~env ~attrs:(attr :: exp.exp_attributes)
            ~loc:exp.exp_loc (Texp_sequence (texp_zero, exp)) ty


(* A CSP is in essence a constant. So, we represent CSP as a constant,
   with an annotation that contains the name of the identifier
 *)

let texp_csp_raw : 
  attribute -> Asttypes.constant -> Env.t -> type_expr -> Typedtree.expression =
  fun attr cnt env ty ->
    {
     exp_desc = Texp_constant cnt;
     exp_loc = Location.none; exp_extra = [];
     exp_type = ty;
     exp_attributes = [attr];
     exp_env = env }


(* TODO: add memoization? *)

(* Compiling an identifier with a given (qualified) name *)
let texp_ident : string -> expression = fun name ->
  let lid     = Longident.parse name in
  let (p, vd) = try Env.lookup_value lid initial_env 
                with Not_found -> 
                  Misc.fatal_error ("Trx.find_value: " ^ name) in
  mk_texp (Texp_ident (p,mknoloc lid, vd))
          (Ctype.instance initial_env vd.val_type)


(* Building an application *)
let texp_apply : Typedtree.expression -> Typedtree.expression list -> 
 Typedtree.expression_desc = fun f args ->
   Texp_apply(f, List.map (fun arg -> ("",Some arg, Required)) args)

(* Compiling a string constant *)
(* The second argument of Const_string is the delimiter,
   the decorator in the {decorator| ... |decorator} notation.
*)
let texp_string : string -> Typedtree.expression = fun str ->
  mk_texp (Texp_constant (Const_string (str,None)))
          (Ctype.instance_def Predef.type_string)

(* Compiling a boolean *)
(* For prototype, see Typecore.option_none *)
let texp_bool : bool -> Typedtree.expression = fun b ->
  let lid = Longident.Lident (if b then "true" else "false") in
  let cdec = Env.lookup_constructor lid initial_env in
  mk_texp (Texp_construct(mknoloc lid, cdec, []))
          (Ctype.instance_def Predef.type_bool)

(* Given a value v, create a Typedtree node for an expression
   that will evaluate to v.
   This the the CSP used by the MetaOCaml itself.
   Since this is an internal CSP, we don't put any attributes.
*)
let texp_csp : Obj.t -> Typedtree.expression = fun v ->
  if Obj.is_int v then texp_int (Obj.obj v)
   (* We treat strings and bytes identically *)
  else if Obj.tag v = Obj.string_tag then texp_string (Obj.obj v)
  else 
    let vstr = Marshal.to_string v [] in
    let () = if false then debug_print ("texp_csp, marshall: size " ^ 
                string_of_int (String.length vstr)) in
    mk_texp
        (texp_apply (texp_ident "Marshal.from_string")
         [texp_string vstr; texp_zero])
        (Btype.newgenvar ())


(* Compiling location data *)
(* We could have made texp_loc an alias to texp_csp... We keep the
   type information for location though, just to be fully correct.
*)
let texp_loc : Location.t -> Typedtree.expression = fun loc ->
  let loc_exp = texp_ident "Trx.loc_none" in (* this fills in the type, etc.*)
  if loc == Location.none then loc_exp else
  {loc_exp with exp_desc = (texp_csp (Obj.repr loc)).exp_desc}

(* Compiling longident with location data *)
let texp_lid : Longident.t loc -> Typedtree.expression = fun lid ->
  let lid_exp = texp_ident "Trx.sample_lid" in (* this fills in the type, etc.*)
  {lid_exp with exp_desc = (texp_csp (Obj.repr lid)).exp_desc}

(* Compiling a string with a location *)
let texp_string_loc : string loc -> Typedtree.expression = fun name ->
  let name_exp = texp_ident "Trx.sample_name" in
  {name_exp with
   exp_desc = (texp_csp (Obj.repr name)).exp_desc}

(* Compiling an option *)
(* For prototype, see Typecore.option_none *)
let texp_option : Typedtree.expression option -> Typedtree.expression = 
  function
    | None -> 
        let lid = Longident.Lident "None" in
        let cnone = Env.lookup_constructor lid initial_env in
        mk_texp (Texp_construct(mknoloc lid, cnone, []))
                (Ctype.instance_def (Predef.type_option (Btype.newgenvar ())))
    | Some e ->
        let lid = Longident.Lident "Some" in
        let csome = Env.lookup_constructor lid initial_env in
        mk_texp (Texp_construct(mknoloc lid, csome, [e]))
                (Ctype.instance_def (Predef.type_option e.exp_type)) 
                ~env:e.exp_env

(* Compiling a tuple *)
let texp_tuple : Typedtree.expression list -> Typedtree.expression = fun el ->
  mk_texp (Texp_tuple el)
          (Ctype.newty (Ttuple (List.map (fun e -> e.exp_type) el)))

(* Compiling an array *)
(* We use this function for grouping trx_bracket-transformed expressions,
   which have the same representation type (but may be different
   code type). We ignore the differences in the code type, since
   the representation type is the same.

   We don't use lists since they are harder to compile, and more
   fragile. Texp_construct has more arguments, we have to locate
   constructor information, etc.
*)
let texp_array : Typedtree.expression list -> Typedtree.expression = function
  | [] -> 
      mk_texp (Texp_array []) 
	      (Ctype.instance_def (Predef.type_array (Btype.newgenvar ())))
  | (h::_) as el ->
      mk_texp (Texp_array el) 
	      (Ctype.instance_def (Predef.type_array h.exp_type))

(* Compiling patterns and the list of names bound by them *)
let texp_pats_names : Parsetree.pattern list -> string loc list -> 
  Typedtree.expression = fun pats names ->
    let pn_exp = texp_ident "Trx.sample_pats_names" in
    {pn_exp with
     exp_desc = (texp_csp (Obj.repr (pats,names))).exp_desc}

(* Utility function to build the case list *)
let texp_case : ?guard:expression -> pattern -> expression -> case =
  fun ?guard pat exp ->
    {c_lhs=pat; c_guard=guard; c_rhs=exp}

(* ------------------------------------------------------------------------ *)
(* Stack marks, a simple form of dynamic binding *)

(* In the earlier version, our stackmarks could be ordered.
   Alas, it is hard to dynamically replace the implementation
   below with the one adjusted for delimcc. The implementation below
   does not work when partial continuations can be captured and reinstated.
   Mainly, when delimited continuations are used, the order is
   not stable. Delimited control operators can reshuffle the order
   arbitrarily. Therefore, the fact that there is order among valid stackmarks
   is not helpful anyway.

module type STACKMARK = sig
  type t
  val is_valid : t -> bool
  (* compare is supposed to be called on stack marks that are
     checked to be valid
   *)
  val compare : t -> t -> int
  val with_stack_mark : (t -> 'w) -> 'w
end

(* Simple implementation with shallow dynamic binding *)
module StackMark : STACKMARK = struct
  type t = int ref

  (* The global counter of the nesting depth of with_stack_mark *)
  let stack_mark_cnt = ref 0

  (* A stack mark is ref n where n is the depth of the corresponding
     with_stack_mark form.
     The stack mark is invalid if the counter is 0
   *)
  let with_stack_mark body =
    incr stack_mark_cnt;
    let mark = ref !stack_mark_cnt in
    let finalize () =
      mark := 0;                         (* invalidate the mark *)
      assert (!stack_mark_cnt > 0);
      decr stack_mark_cnt
    in
    try 
      let r = body mark in finalize (); r
    with e -> finalize (); raise e

  let is_valid mark = !mark > 0
  let compare m1 m2 =
    assert (!m1 >0 && !m2 > 0);
    compare !m1 !m2
end

*)

(* A robust and truly minimalistic implementation of stack-marks.
   A stack-mark is created by 'with_stack_mark' function. Since
   the only operation on a stackmark is to test if it is valid,
   the stackmark is realized as a thunk unit -> bool.
*)
type stackmark = unit -> bool           (* true if valid *)

(* The type of the with_stack_mark operation *)
type stackmark_region_fn = 
    {stackmark_region_fn : 'w. (stackmark -> 'w) -> 'w}

(* The simple implementation of stackmark_region_fn, appropriate
   when no delimited control is used.
   The mark is a ref bool cell, containing true within
   stackmark_region_fn's dynamic region.
*)
let with_stack_mark_simple : stackmark_region_fn = 
  {stackmark_region_fn = fun body ->
    let mark = ref true in
    try
      let r = body (fun () -> !mark) in
      mark := false;                      (* invalidate the mark *)
      r
    with e -> mark := false; raise e
 }

let with_stack_mark : stackmark_region_fn ref = ref with_stack_mark_simple

(* Replace a with_stack_mark implementation, e.g., when delimcc is used *)
let set_with_stack_mark : stackmark_region_fn -> unit =
  fun smf -> with_stack_mark := smf

    
(* ------------------------------------------------------------------------ *)
(* Simple heap *)
(* A mapping of keys to values. Priority is used for the sake of
   efficient operations. Also, values with the same priority are
   considered equivalent (belong to the same binding region)
   and are collapsed, lazily. 

   The invariant: for each non-leaf
   node, the priority of the node is strictly greater than the priorities 
   of any of the child nodes. The order of priorities between 
   the children can be arbitrary.
*)
type prio = int
type 'v heap = Nil | HNode of prio * stackmark * 'v * 'v heap * 'v heap
let empty = Nil

let rec merge : 'v heap -> 'v heap -> 'v heap = fun h1 h2 ->
  match (h1,h2) with
  | (Nil,h) | (h,Nil)-> h
  | (HNode (p1,k1,v1,l1,r1), HNode (p2,k2,v2,l2,r2)) ->
      begin
        match p1 - p2 with
        | 0 -> HNode (p1,k1,v1, merge l1 l2, merge r1 r2) (* same keys *)
        | n when n < 0 -> HNode (p2,k2,v2, merge h1 l2, r2)
        | _ -> HNode (p1,k1,v1,l1,merge h2 r1)
      end

(* Remove the node with a given priority *)
let rec remove : prio -> 'v heap -> 'v heap = fun p -> function
  | Nil -> Nil
  | HNode (pn,k,v,h1,h2) as h -> 
      begin
        match p - pn with
        | 0 -> merge h1 h2              (* p cannot occur in h1 or h2 *)
        | n when n > 0 -> h             (* entire tree has the lower prio *)
        | _ -> HNode (pn,k,v, remove p h1, remove p h2)
      end

(* The representation of the possibly open code: AST plus the
   set of free identifiers, annotated with the marks
   of the corresponding with_binding_region forms
*)
type code_repr = Code of string loc heap * Parsetree.expression

(* The closed code is AST *)
type closed_code_repr = Parsetree.expression

(* Check that the code is closed and return the closed code *)

(* The same as close_code but return the closedness check as a thunk
   rather than performing it.
   This is useful for debugging and for showing the code
*)
let close_code_delay_check : code_repr -> closed_code_repr * (unit -> unit) =
 function
  | Code (Nil,ast) -> (ast,fun () -> ())
  | Code (HNode (_,_,var,_,_),ast) ->
    (ast, fun () ->
      Format.fprintf Format.str_formatter
      "The code built at %a is not closed: identifier %s bound at %a is free"
      Location.print ast.pexp_loc var.txt Location.print var.loc;
      failwith (Format.flush_str_formatter ()))

let close_code_repr : code_repr -> closed_code_repr = fun cde ->
  let (ast, check) = close_code_delay_check cde in
  check (); ast

let open_code : closed_code_repr -> code_repr = fun ast ->
  Code (Nil,ast)

(* Compiling a closed code value: a structural constant of
   type code_repr
   This constant is transported via CSP (although we could have
   built a Typedtree node for that purpose.
 *)
let texp_code : ?node_id:string ->
  Location.t -> Parsetree.expression_desc -> Typedtree.expression_desc =
  fun ?(node_id="") loc desc ->
  let ast = Ast_helper.Exp.mk ~loc desc in
  (texp_csp (Obj.repr (open_code ast))).exp_desc


(* ------------------------------------------------------------------------ *)
(* Bindings in the future stage *)
(* Recall, all bindings at the future stage are introduced by
   patterns, and hence are simple names, without any module qualifications.
*)
let gensym_count = ref 0

(* Generate a fresh name with a given base name *)
let gensym : string -> string = fun s ->
  incr gensym_count;
  s ^ "_" ^ string_of_int !gensym_count

let reset_gensym_counter () = gensym_count := 0

(* Make a simple identifier unique *)
let genident : string loc -> string loc = fun name ->
  {name with txt = gensym name.txt}

(* This is a run-time error, rather than a translation-time error *)
let scope_extrusion_error : 
  detected:Location.t -> occurred:Location.t -> string loc -> 'a = 
  fun ~detected ~occurred var ->
  Format.fprintf Format.str_formatter
    "Scope extrusion detected at %a for code built at %a for the identifier %s bound at %a"
    Location.print detected Location.print occurred
    var.txt Location.print var.loc;
  failwith (Format.flush_str_formatter ())

(* Check to make sure that free variables in the potentially open
   code fragment are valid.
   If it weren't for delimited control, the order of stack marks is
   stable; therefore, if the maximal mark is valid then all
   smaller marks are valid as well.
   Delimited control spoils all that. 
   When we capture some of the inner-bidings
   in a continuation and then reinstall that continuation at the
   top level, the `latest' free variable is valid but earlier are
   no longer valid:

  let r = ref ... in
  .<fun x1 x2 -> .~(reset .<fun y1 y2 -> 
                              .~(shift k (r := k; k .<0>.))>.)>.
  .r .<2>.
  Here, y1 and y2 are valid but x1 and x2 are not.
*)
let validate_vars : Location.t -> code_repr -> code_repr = 
  fun l -> function
  | Code (Nil,_) as cde -> cde
  | Code (h, ast) as cde -> begin
      let rec check = function
        | Nil -> ()
        | HNode (_,sm,var,h1,h2) ->
            if sm () then (check h1; check h2)
            else scope_extrusion_error ~detected:l ~occurred:ast.pexp_loc var 
      in check h; cde
  end

let validate_vars_option : Location.t -> code_repr option -> 
  Parsetree.expression option * string loc heap = 
  fun l -> function
  | None -> (None,Nil)
  | Some e -> let Code (vars, e) = validate_vars l e in (Some e, vars)

let validate_vars_map : Location.t -> 
  (Location.t -> 'a -> 'b * string loc heap) -> 'a list ->
  'b list * string loc heap = fun loc f xs ->
  map_accum (fun acc x -> 
      let (y,vars) = f loc x in
      (y, merge vars acc))
    Nil xs

let validate_vars_list : Location.t -> code_repr list -> 
  Parsetree.expression list * string loc heap = fun l cs ->
  validate_vars_map l 
      (fun l c -> let Code (vars,e) = validate_vars l c in (e,vars)) cs

(* Generate a fresh name off the given name, enter a new binding region
   and evaluate a function passing it the generated name as code_repr.
   Remove the generated name from the annotation on the resulting code_expr.
   Return that result and the generated name.
   This function embodies the translation of simple functions, for-loops,
   simple let-expressions, etc.
*)
      (* Counter for assiging priorities to vars heap nodes. *)
      (* Keep in mind the invariant that variables of the same priority
         comes from the same binding location. So, we must keep the
         priorities unique to binders. Giving binders monotonically
         increasing priorities is helpful: the innermost binding
         has the highest priority and it will be at the top of the heap,
         the easiest to remove.
       *)
let prio_counter = ref 0

let with_binding_region : 
  Location.t -> string loc -> (code_repr -> code_repr) -> 
  string loc * string loc heap * Parsetree.expression = fun l name f -> 
  let new_name = genident name in
  let (vars,e) = 
   !with_stack_mark.stackmark_region_fn (fun mark ->
     incr prio_counter;
     let prio = !prio_counter in
     let var_code = (* code that corresponds to the bound variable *)
       Code (HNode (prio,mark,new_name,Nil,Nil),
          Ast_helper.Exp.mk ~loc:name.loc   (* the loc of the binder *)
           (Pexp_ident (mkloc (Longident.Lident new_name.txt) new_name.loc))) in
     let Code (vars,e) = validate_vars l (f var_code) in
     (remove prio vars, e)) in
  (new_name, vars, e)

(* The most general version with several bindings and several expressions 
   that use the bindings
 *)
let with_binding_region_gen : 
  Location.t -> string loc list -> 
  (Location.t -> 'a -> 'b * string loc heap) -> (code_repr array -> 'a array) ->
  string loc list * string loc heap * 'b list
  = fun l names tr f -> 
  let new_names = List.map genident names in
  let (vars,es) = 
   !with_stack_mark.stackmark_region_fn (fun mark ->
     incr prio_counter;
     let prio = !prio_counter in
     let vars_code = Array.of_list (List.map (fun new_name ->
                      (* code that corresponds to a bound variable *)
       Code (HNode (prio,mark,new_name,Nil,Nil),
          Ast_helper.Exp.mk ~loc:new_name.loc    (* the loc of the binder *)
            (Pexp_ident (mkloc (Longident.Lident new_name.txt) new_name.loc))))
       new_names) in
     let cs = Array.to_list (f vars_code) in
     let (es,vars) = map_accum (fun vars c -> 
                      let (e,var) = tr l c in
                      (e,merge var vars)) Nil cs in
     (remove prio vars, es)) in
  (new_names, vars, es)

(* ------------------------------------------------------------------------ *)
(* Building Parsetree nodes *)

(* Handle timestamp for builders of the type 
      Parsetree.expression -> Parsetree.expression
*)
let code_wrapper : 
    (Location.t -> Parsetree.expression -> Parsetree.expression) ->
    (Location.t -> code_repr -> code_repr) =
fun f l e ->
  let Code (vars,e) = validate_vars l e in
  Code (vars, f l e)

(* building a typical Parsetree node: Pexp_assert of expression*)
let build_assert : Location.t -> code_repr -> code_repr = 
  code_wrapper
  (fun loc e -> Ast_helper.Exp.assert_ ~loc e)

(* When we translate the typed-tree, we have to manually compile
   the above code 
First, to see the AST for the phrase, invoke the top-level with the flag
-dparsetree. Then
   {pexp_loc  = l; pexp_desc = Pexp_assert e}

gives the parsetree:
let build_assert_ast : Location.t -> Parsetree.expression -> Parsetree.expression = 
{pexp_loc = l1;
 pexp_desc = 
  Pexp_record
        ([(Location.mknoloc (Longident.parse "Parsetree.pexp_loc"), 
           Pexp_ident "l");
         (Location.mknoloc (Longident.parse "Parsetree.pexp_desc"),
           {pexp_loc  = Location.none;
            pexp_desc = Pexp_construct 
                          ((Location.mknoloc (Longident.parse 
                                                "Parsetree.Pexp_assert")),
              Some {pexp_loc = Location.none;
                    pexp_desc = Pexp_ident "e"},
              false)})
        ],
        None)}
type_expression

If building the parsetree on our own, beware! For example, labels in
Texp_record must be sorted, in their declared order!
*)


(* Other similar builders *)
let build_lazy : Location.t -> code_repr -> code_repr = 
  code_wrapper @@
    fun loc e -> Ast_helper.Exp.lazy_ ~loc e
let build_bracket : Location.t -> code_repr -> code_repr = 
  code_wrapper @@
    fun _ e -> {e with pexp_attributes = 
                   attr_bracket :: e.pexp_attributes }
let build_escape : Location.t -> code_repr -> code_repr = 
  code_wrapper @@
    fun _ e -> {e with pexp_attributes = 
                        attr_escape :: e.pexp_attributes}

let build_sequence : Location.t -> code_repr -> code_repr -> code_repr = 
  fun loc e1 e2 -> 
    let Code (vars1,e1) = validate_vars loc e1 in
    let Code (vars2,e2) = validate_vars loc e2 in
    Code (merge vars1 vars2,
          Ast_helper.Exp.sequence ~loc e1 e2)
let build_while : Location.t -> code_repr -> code_repr -> code_repr = 
  fun loc e1 e2 -> 
    let Code (vars1,e1) = validate_vars loc e1 in
    let Code (vars2,e2) = validate_vars loc e2 in
    Code (merge vars1 vars2,
          Ast_helper.Exp.while_ ~loc e1 e2)

(* Build the application. The first element in the array is the
   function. The others are arguments. *)
let build_apply : Location.t -> (label * code_repr) array -> code_repr = 
  fun loc ea -> 
    assert (Array.length ea > 1);
    match map_accum (fun vars (lbl,e) -> 
                   let Code (var,e) = validate_vars loc e in
                   ((lbl,e),merge var vars))
          Nil (Array.to_list ea) with
    | (("",eh)::elt,vars) ->
       Code (vars, 
             Ast_helper.Exp.apply ~loc eh elt)
    | _ -> assert false


let build_tuple : Location.t -> code_repr array -> code_repr =
 fun loc ea -> 
  let (els,vars) = validate_vars_list loc (Array.to_list ea) in
  Code (vars, 
        Ast_helper.Exp.tuple ~loc els)

let build_array : Location.t -> code_repr array -> code_repr =
 fun loc ea -> 
  let (els,vars) = validate_vars_list loc (Array.to_list ea) in
  Code (vars,
        Ast_helper.Exp.array ~loc els)

let build_ifthenelse : 
 Location.t -> code_repr -> code_repr -> code_repr option -> code_repr =
 fun loc e1 e2 eo -> 
    let Code (vars1,e1) = validate_vars loc e1 in
    let Code (vars2,e2) = validate_vars loc e2 in
    let (eo,varso)      = validate_vars_option loc eo in
    Code (merge vars1 (merge vars2 varso),
          Ast_helper.Exp.ifthenelse ~loc e1 e2 eo)

let build_construct :
 Location.t -> Longident.t loc -> code_repr array -> code_repr =
 fun loc lid args ->
  let (args,vars) = validate_vars_list loc (Array.to_list args) in
  Code (vars, 
        Ast_helper.Exp.construct ~loc lid
          begin
            match args with
            | []  -> None
            | [x] -> Some x
            | xl  -> Some (Ast_helper.Exp.tuple ~loc xl)
     end)

let build_record : Location.t -> (Longident.t loc * code_repr) array ->
 code_repr option -> code_repr =
 fun loc lel eo ->
   let (lel,vars) = map_accum (fun vars (lbl,e) -> 
                       let Code (var,e) = validate_vars loc e in
                       ((lbl,e),merge var vars))
        Nil (Array.to_list lel) in
   let (eo,varo) = validate_vars_option loc eo in
   Code (merge vars varo,
         Ast_helper.Exp.record ~loc lel eo)

let build_field : Location.t -> code_repr -> Longident.t loc -> code_repr =
 fun loc e lid ->
  let Code (vars,e) = validate_vars loc e in
  Code (vars,
        Ast_helper.Exp.field ~loc e lid)

let build_setfield :
 Location.t -> code_repr -> Longident.t loc -> code_repr -> code_repr =
 fun loc e1 lid e2 ->
  let Code (vars1,e1) = validate_vars loc e1 in
  let Code (vars2,e2) = validate_vars loc e2 in
  Code (merge vars1 vars2,
        Ast_helper.Exp.setfield ~loc e1 lid e2)

let build_variant : Location.t -> string -> code_repr option -> code_repr =
 fun loc l eo ->
  let (eo,vars) = validate_vars_option loc eo in
  Code (vars,
        Ast_helper.Exp.variant ~loc l eo)

let build_send : Location.t -> code_repr -> string -> code_repr =
 fun loc e l ->
  let Code (vars,e) = validate_vars loc e in
  Code (vars,
        Ast_helper.Exp.send ~loc e l)

let build_open :
 Location.t -> Longident.t loc -> override_flag -> code_repr -> code_repr =
 fun loc l ovf e ->
  let Code (vars,e) = validate_vars loc e in
  Code (vars,
        Ast_helper.Exp.open_ ~loc ovf l e)

(* Build a function with a non-binding pattern, such as fun () -> ... *)
let build_fun_nonbinding : 
  Location.t -> string -> Parsetree.pattern list -> 
  (code_repr option * code_repr) array -> code_repr =
  fun loc label pats gbodies -> 
  let (egbodies,vars) = 
    validate_vars_map loc 
      (fun loc (eo,e) ->
        let (eo,vo)        = validate_vars_option loc eo in
        let Code (vars,e)  = validate_vars loc e in
        ((eo,e),merge vo vars)) 
      (Array.to_list gbodies) in
  Code (vars,
        match (egbodies,pats) with
        | ([(None,e)],[p]) ->
            Ast_helper.Exp.fun_ ~loc label None p e
        | _ when label="" ->
          Ast_helper.Exp.function_ ~loc 
            (List.map2 (fun p (eo,e) -> {pc_lhs=p;pc_guard=eo;pc_rhs=e}) 
              pats egbodies)
        | _ -> assert false)

(* Build a Parsetree for a future-stage identifier
   It is always in scope of with_binding_region:
   Bound variables are always in scope of their binders;
   A well-typed code has no unbound variables.
let build_ident : Location.t -> string loc -> code_repr =
 fun loc l ->
  not_supported loc "vars not supported"
  Code (add_timestamp (Some l)
   {pexp_loc  = loc;
    pexp_desc = Pexp_ident (mkloc (Longident.Lident l.txt) l.loc)}
*)

(* Build a simple one-arg function, as described in the the title comments *)
(* 'name' is the name of the variable from Ppat_var of the fun x -> ...
   form. It is the real name with the location within the function pattern.
   Use name.loc to identify the binder in the source code.
*)
let build_fun_simple : 
  Location.t -> string -> string loc -> (code_repr -> code_repr) -> code_repr =
  fun loc label old_name fbody -> 
  let (name, vars, ebody) = with_binding_region loc old_name fbody in
  let pat = Ast_helper.Pat.var ~loc:name.loc name in
  Code (vars,
        Ast_helper.Exp.fun_ ~loc label None pat ebody)

let build_for : 
  Location.t -> string loc -> code_repr -> code_repr -> 
  bool -> (code_repr -> code_repr) -> code_repr =
  fun loc old_name elo ehi dir fbody -> 
  let (name, varsb, ebody) = with_binding_region loc old_name fbody in
  let Code (varsl,elo) = validate_vars loc elo in
  let Code (varsh,ehi) = validate_vars loc ehi in
  Code (merge varsb (merge varsl varsh),
        Ast_helper.Exp.for_ ~loc 
          (Ast_helper.Pat.var ~loc:name.loc name) elo ehi 
            (if dir then Upto else Downto) ebody)

(*
(* deflt_flag = True, the let was Default (auto-geneterated by the type
   checker for the default function argument)
*)
let build_let_simple_nonrec : 
  Location.t -> string loc -> bool -> code_repr -> (code_repr -> code_repr) -> 
    code_repr = fun l old_name deflt_flag e fbody -> 
  let (name, varsb, ebody) = with_binding_region l old_name fbody in
  let pat = {ppat_loc  = name.loc; ppat_desc = Ppat_var name} in
  let Code (varse,e) = validate_vars l e in
  Code (merge varsb varse,
  {pexp_loc = l; 
   pexp_desc = 
    Pexp_let ((if deflt_flag then Default else Nonrecursive), [(pat,e)],ebody)})

(*
 Recursive let is subject to additional well-formedness constraints, 
 see bytecomp/translcore.ml:transl_let.
 The first is that binding pattern should contain either Tpat_var
 or Tpat_alias. For build_let_simple_rec, this constraint is
 satisfied automatically. 
 The second check is performed by check_recursive_lambda in 
 bytecomp/translcore.ml. We use a simpler version of the test:
 we allow only letrec experssions of the form
   let rec f = fun x -> ....
 that is, 
   let rec f x y ... =
*)
let build_letrec : 
  Location.t -> string loc array -> 
    (code_repr array -> code_repr array) -> code_repr = 
  fun l old_names fbodies -> 
  let (names,vars,ebodies) = 
    with_binding_region_gen l (Array.to_list old_names) fbodies in
  let (ebody,es) = 
    match ebodies with body::es -> (body,es) | _ -> assert false in
  let pel = List.map2 (fun name e ->
     ({ppat_loc  = name.loc; ppat_desc = Ppat_var name},e)) names es in
  let check_rhs e =
    match e.pexp_desc with
    | Pexp_function (_,_,_) -> ()
    | _ ->     
        Format.fprintf Format.str_formatter
          "Recursive let binding %a must be to a function %a"
          Location.print l Location.print e.pexp_loc;
        failwith (Format.flush_str_formatter ()) in
  List.iter check_rhs es;
  Code (vars,
  {pexp_loc = l; 
   pexp_desc = Pexp_let (Recursive, pel, ebody)})

 XXXXX 
*)

(*{{{ CSP *)

(* ------------------------------------------------------------------------ *)
(* Dealing with CSP *)

exception CannotLift

(* Analyze the type of the expression and figure out if we can lift it.
   Raise CannotLift if cannot (e.g., the type is polymorphic), or it is too
   much to bother.
   TODO: lists, arrays, option types of liftable types are themselves
   liftable. We can lift many more types. For arrays, check their length.
   If the array is short, it should be lifted. For long arrays,
   building a CSP is better (although it make take a bit longer since
   we will have to invoke dyn_quote at run-time).

   TODO: currently we generate calls to run-time functions like 
   lift_constant_int to do the Parsetree generation. In the future
   we should `inline' those functions -- that is, obtain the Typedtree
   for them and use the tree for building Texp_apply.
*)
let lift_as_literal : 
  Typedtree.expression -> Longident.t loc -> Typedtree.expression_desc = 
  fun exp li ->
  let exp_ty =
        Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
  match Ctype.repr exp_ty with
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
        texp_apply (texp_ident "Trx.lift_constant_int") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
        texp_apply (texp_ident "Trx.lift_constant_char") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
        texp_apply (texp_ident "Trx.lift_constant_bool") [exp]
          (* double and string are handled by dyn_quote *)
          (* which hence handles polymorphic functions instantiated
             to double and string.
           *)
          (* Deal with code type *)
    | _ -> raise CannotLift

(* TODO: similarly handle Const_nativeint, Const_int32, Const_int64 *)
let lift_constant_int : int -> code_repr = fun x -> 
  open_code @@ Ast_helper.Exp.constant (Const_int x)

let lift_constant_char : char -> code_repr = fun x -> 
  open_code @@ Ast_helper.Exp.constant (Const_char x)

let lift_constant_bool : bool -> code_repr = fun x -> 
  let b = if x then "true" else "false" in 
  open_code @@ Ast_helper.Exp.construct 
                 (Location.mknoloc (Longident.Lident b)) None


(* Lift the run-time value v into a Parsetree for the code that, when
   run, will produce v.
   We do not have the type information for v, but we can examine
   its run-time representation, to decide if we lift it is a source
   literal or as a CSP.
   We attach the CSP attribute to an expression, for the sake of better
   printing (also to simplify translation when CSP occurs within nested
   brackets).

  TODO: also check for double_array_tag
   and create a (structured) constant for a double array
*)
let obj_magic_exp = 
  Ast_helper.Exp.ident (Location.mknoloc @@
   (Longident.Ldot (Longident.Lident "Obj","magic")))

(* Check to see if a value is easy to serialize *)
let easy_to_serialize : Obj.t -> bool =
  let depth_bound = 5 in
  let rec loop n v = 
    Obj.is_int v || 
    let tag = Obj.tag v in
    tag = Obj.string_tag ||
    tag = Obj.double_tag ||
    tag = Obj.double_array_tag ||
    if n <= 0  ||
      tag = Obj.closure_tag ||
      tag >= Obj.no_scan_tag
    then false
    else let rec inner i = 
      if i < 0 then true else
      loop (n-1) (Obj.field v i) && inner (i-1) 
      in inner (Obj.size v - 1)
  in loop depth_bound


let dyn_quote : Obj.t -> Longident.t loc -> code_repr =
  fun v li ->
   let csp_attr = attr_csp li in
   open_code @@   
   match Obj.is_int v with
    | true ->   (* Looks like an integer: coerce from it using Obj.magic *)
        Ast_helper.Exp.apply ~attrs:[csp_attr] ~loc:li.loc
          obj_magic_exp [("",Ast_helper.Exp.constant (Const_int (Obj.obj v)))]
    | false when Obj.tag v = Obj.double_tag ->
      Ast_helper.Exp.constant (Const_float (string_of_float (Obj.obj v)))
    | false when Obj.tag v = Obj.string_tag ->
      Ast_helper.Exp.constant (Const_string (Obj.obj v,None))
    | _   ->           (* general case *)
        let () =
          if not @@ easy_to_serialize v then
            debug_print ~loc:li.loc 
             "The CSP value is a closure or too deep to serialize" in
        Ast_helper.Exp.apply ~attrs:[csp_attr] ~loc:li.loc
          obj_magic_exp [("",Ast_helper.Exp.constant 
                               (Const_string (Obj.obj v,None)))]

       
(* Build the Typedtree that lifts the variable with the given path and type.
   Since this code receives the type of the variable, we use the
   type to generate the lifting code for that particular type.
   For example, we build the code to convert a float
   0.1 to the Parsetree node Pexp_constant(Const_float "0.1")).
   If we cannot or would not do the type-dependent lifting and we cannot
   refer to the variable by name (e.g., because it is local),
   we generate the call to the dynamic quoter, dyn_quote.
   The latter will receive the actual value to quote and will generate,
   at run-time, a Parsetree constant or CSP, based on that value.
 *)
let trx_csp : 
  Typedtree.expression -> Path.t -> Longident.t loc ->
  Typedtree.expression_desc = fun exp p li ->
  (* First we try lifting as a constant *)
  try lift_as_literal exp li 
  with CannotLift ->
  (* Then check if we can pass by reference *)
  if ident_can_be_quoted p then
    texp_code ~node_id:"*id*" exp.exp_loc
          (Pexp_ident (Location.mkloc (path_to_lid p) li.loc))
  else
  (* Otherwise, do the lifting at run-time *)
  texp_apply (texp_ident "Trx.dyn_quote") [exp; texp_lid li]

(*{{{ Historical: hints on native mode CSP *)

(* Native mode is moved out to the `userland'

let remove_texp_cspval exp =
  if !native_mode = false then exp else
  failwith "native mode CSP are not impemented yet"

old code
  match exp.exp_desc with
  | Texp_cspval (v,l) ->
      let i = add_csp_value (v,l) in
      let exp' = {exp with exp_desc = Texp_constant (Const_int i)} in
      let desc = if !initial_native_compilation
        then (Texp_apply (trx_array_get exp, [(Some !local_csp_arr_texp, Required);(Some exp', Required)]))
	else (Texp_apply (trx_get_csp_value exp, [(Some exp', Required)])) in
      {exp with exp_desc = desc}
  | _ -> assert false
*)

(*}}}*)

(*}}}*)


(*{{{ Translating patterns and expressions using patterns *)


(* Analyze and translate a pattern:
         Typedtree.pattern -> Parsetree.pattern
  The function is somewhat similar to tools/untypeast.ml:untype_pattern

  However, we also determine and return the list of bound variables.
  The list is in the reverse of the order of variables occurring in the pattern.
  Finally, we check that labels and constructors may be quoted.

  The algorithm of determining the names of bound variables is based
  on Typedtree.pat_bound_idents. There is one subtle issue.
  Normally all variables within a pattern are unique (patterns are
  always linear). Identically named variables within a list of patterns, like 
      match ... with
      | [x] -> 
      | [x;y] ->
  are _distinct_ variables. They have different Ident.t values, even though
  their names may be the same. However, components of an OR pattern 
  bind exactly the same identifiers. Don't count them twice!
*)


(* The first argument is a list of identifiers. Found identifiers are
   prepended to that list. The order of identifiers is important!
   If you change the traversal order, be sure to modify pattern_subst below!
*)
let rec trx_pattern : 
    (Ident.t * string loc) list -> Typedtree.pattern -> 
     Parsetree.pattern * (Ident.t * string loc) list = fun acc pat ->
  let (pd,acc) = match pat with
  |  { pat_extra=[Tpat_unpack, _, _attrs]; pat_desc = Tpat_var (_,name); _ } ->
        (Ppat_unpack name,acc)          (* name must have been upperase *)
  | { pat_extra=[Tpat_type (_path, lid), _, _attrs]; _ } -> (Ppat_type lid,acc)
  | { pat_extra= (Tpat_constraint ct, _, _attrs) :: rem; _ } ->
      not_supported pat.pat_loc
        "patterns with constraints, and other pat_extra";
      (*
        Ppat_constraint (untype_pattern { pat with pat_extra=rem },
                         untype_core_type ct)
       *)
  | _ -> match pat.pat_desc with
  | Tpat_any -> (Ppat_any, acc)
  | Tpat_var (id, name) when 
      (match (Ident.name id).[0] with 'A'..'Z' -> true | _ -> false) ->
        (Ppat_unpack name,acc)        (* We don't handle modules though...*)
  | Tpat_var (id, name) ->
      (Ppat_var name, (id,name)::acc)
  | Tpat_alias (p, id, name) ->
      let (p,acc) = trx_pattern acc p in
      (Ppat_alias (p, name),(id,name)::acc)
  | Tpat_constant cst -> (Ppat_constant cst, acc)
  | Tpat_tuple lst ->
    let (pl,acc) = map_accum trx_pattern acc lst
    in (Ppat_tuple pl, acc)
  | Tpat_construct (li, cdesc, args) ->
      let lid = qualify_ctor li cdesc in
      let (args,acc) = map_accum trx_pattern acc args in
      (Ppat_construct (lid,
          (match args with
          | []  -> None 
          | [x] -> Some x 
          | _   -> Some (Ast_helper.Pat.tuple ~loc:pat.pat_loc args))),
       acc)
  | Tpat_variant (label, None, _) -> (Ppat_variant (label,None),acc)
  | Tpat_variant (label, Some p, _) ->
      let (p,acc) = trx_pattern acc p 
      in (Ppat_variant (label,Some p),acc)
  | Tpat_record (lst, closed) ->
      let dolab acc (li,ldesc,pat) =
        let lid = qualify_label li ldesc in
        let (pat,acc) = trx_pattern acc pat in
        ((lid,pat),acc)
      in
      let (lpl,acc) = map_accum dolab acc lst in
      (Ppat_record (lpl,closed),acc)
  | Tpat_array lst -> 
    let (pl,acc) = map_accum trx_pattern acc lst
    in (Ppat_array pl, acc)
  | Tpat_or (p1, p2, _) -> 
      (* Invariant : both arguments bind the same variables *)
      let (p1,acc) = trx_pattern acc p1 in
      let (p2,_)   = trx_pattern acc p2 in (* ignore vars in p2 *)
      (Ppat_or (p1,p2),acc)
  | Tpat_lazy p -> 
      let (p,acc) = trx_pattern acc p in (Ppat_lazy p,acc)
  in
  (Ast_helper.Pat.mk ~loc:pat.pat_loc ~attrs:pat.pat_attributes pd, acc)


(* Process all patterns in the case list *)
(* Patterns are processed left-to-right. The result is the processed
   pattern list plus the list of names of the bound variables.
   The variables are listed in the order they occur in the pattern.
   Thus the following should hold:
      let (pats,names,_) = trx_cl cl in
      let (pats',acc) =  pattern_subst_list names pats in
      assert (pats = pats');
      assert (acc = [])
   The final result of trx_cl is the pattern binding the names.
   We build an array pattern rather than a more appropriate tuple.
   Using array forces a single type to all arguments. Although
   it is phantom anyway, it is still a bummer. But with the tuple
   we can't generically write build_fun.
   The second argument, typ_expr, should normally be a code type.

   This function is used when translating a future-stage function as the 
   present-stage whose argument is an array of variables.
   See trx_bracket for functions, let, match and try
*)
let trx_cl : case list -> type_expr ->
     Parsetree.pattern list * string loc list * Typedtree.pattern
   = fun cl typ -> 
   let (pats, lst) = 
     map_accum (fun acc {c_lhs} -> trx_pattern acc c_lhs) [] cl in
   let idnames = List.rev lst in
   let (loc,env) = 
     match cl with {c_lhs=p}::_ -> (p.pat_loc, p.pat_env) |_ -> assert false in
    (* Pattern representing one binding variable *)
   let var_pat (id,name) =
    {pat_loc = loc; pat_extra = []; pat_env = env;
     pat_desc = Tpat_var (id,name);
     pat_attributes=[];
     pat_type = typ} in
   (pats, List.map snd idnames,
    {pat_loc = loc; pat_extra = []; pat_env = env;
     pat_attributes=[];
     pat_desc = Tpat_array (List.map var_pat idnames);
     pat_type = Ctype.instance_def (Predef.type_array typ)})

(* Substitute the names of bound variables in the pattern.
   The new names are given in the string loc list. We
   take advantage of the fact that patterns are linear and
   the list of new names is ordered, in the order the bound
   variables occur in the pattern. Therefore, we substitute based
   on position.
   OR-patterns bring complexity however: both branches of an OR
   pattern bind exactly the same variables (but the order of
   variable occurrence within branches may be different).
   So for OR patterns we substitute by name, taking advantage
   of the fact the new names differ from the old ones in _nnn
   suffix. OR patterns are uncommon, so the complication of their processing
   is not that bad.

   This function is closely related to trx_pattern; It relies on the
   same pattern traversal order as trx_pattern.
 *)

         (* two strings are the same up to (and including) n *)
let rec same_upto s1 s2 n =
  n < 0 || (s1.[n] = s2.[n] && same_upto s1 s2 (n-1))

let rec pattern_subst : ?by_name:bool ->
    string loc list -> Parsetree.pattern -> 
     Parsetree.pattern * string loc list = fun ?(by_name=false) acc pat ->
 if acc = [] then (pat,acc) else           (* no more variables to subst *)
 let subst old_name acc =
   if by_name then begin
     let new_name =
       try List.find (fun n -> 
         same_upto old_name.txt n.txt (String.rindex n.txt '_' - 1)) acc 
       with _ ->
         begin
           Format.fprintf Format.str_formatter "old_name %s %a\n"
             old_name.txt Location.print old_name.loc;
           List.iter (fun n -> Format.fprintf Format.str_formatter
               "new name %s %a\n" n.txt Location.print n.loc) acc;
           failwith (Format.flush_str_formatter ())
         end
     in
     (new_name, acc)                       (* don't bother removing from acc*)
   end
   else match acc with
   | h::t -> (h,t)
   | _    -> assert false
 in
 let (desc,acc) = match pat.ppat_desc with
  | Ppat_any as x -> (x,acc)
  | Ppat_var old_name ->
      let (new_name,acc) = subst old_name acc in (Ppat_var new_name,acc)
  | Ppat_alias (p,old_name) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     let (new_name,acc) = subst old_name acc in 
     (Ppat_alias (p,new_name),acc)
  | Ppat_constant _ as x -> (x,acc)
  | Ppat_tuple pl ->
      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
      (Ppat_tuple pl,acc)
  | Ppat_construct (_,None) as x -> (x,acc)
  | Ppat_construct (lid,Some p) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_construct (lid,Some p),acc)
  | Ppat_variant (_,None) as x -> (x,acc)
  | Ppat_variant (l,Some p) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_variant (l,Some p),acc)
  | Ppat_record (pl,cf) ->
      let (pl,acc) = map_accum (fun acc (l,p) -> 
          let (p,acc) = pattern_subst ~by_name acc p in ((l,p),acc)) acc pl in
      (Ppat_record (pl,cf),acc)
  | Ppat_array pl ->
      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
      (Ppat_array pl,acc)
  | Ppat_or (p1,p2) ->
     let (p1,acc') = pattern_subst ~by_name acc p1 in
     let (p2,_)   = pattern_subst ~by_name:true acc p2 in
     (Ppat_or (p1,p2), acc')
  | Ppat_constraint (p,cty) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_constraint (p,cty), acc)
  | Ppat_type _ as x -> (x,acc)
  | Ppat_lazy p ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_lazy p, acc)
  | Ppat_unpack _ as x -> (x,acc)
  | _ -> assert false (* we do not create other forms of Ppat *)
 in
 ({pat with ppat_desc = desc}, acc)


let pattern_subst_list :
    string loc list -> Parsetree.pattern list -> 
     Parsetree.pattern list * string loc list = fun acc pl ->
 map_accum (pattern_subst ~by_name:false) acc pl



(* Build the general fun Parsetree *)

(* Build the fresh variable name for cases and build the Parsetree
   case list
*)
let prepare_cases : Location.t -> 
  string loc heap ->     (* extra free variables used in kontinuation *)
  (* The following argument is a pair: a pattern list for the clauses
     of the function, and the list of names of bound variables, in order.
  *)
  (Parsetree.pattern list * string loc list) -> 
  (* The following function returns the list of pairs of guards and bodies,
     for each clause of the function
   *)
  (code_repr array -> (code_repr option * code_repr) array) -> 
  (* The continuation *)
  (Parsetree.case list -> Parsetree.expression) -> code_repr =
  fun loc evars (pats,old_names) fgbodies k -> 
    let tr loc (eo,e) = 
        let (eo,vo)        = validate_vars_option loc eo in
        let Code (vars,e)  = validate_vars loc e in
        ((eo,e),merge vo vars) in
    let (names,vars,egbodies) = 
         with_binding_region_gen loc old_names tr fgbodies in
    let pats = 
      if names = [] then pats else
      let (pats,acc) = pattern_subst_list names pats in
      assert (acc = []); pats
    in
    Code(merge evars vars,
         k @@ List.map2 (fun p (eo,e) -> {pc_lhs=p;pc_guard=eo;pc_rhs=e}) 
              pats egbodies)

let build_fun : 
  Location.t -> string -> 
  (Parsetree.pattern list * string loc list) -> 
  (code_repr array -> (code_repr option * code_repr) array) -> code_repr =
  fun loc label pon fgbodies -> 
  prepare_cases loc Nil pon fgbodies @@ function
    | [{pc_lhs=p; pc_guard=None; pc_rhs=e}] ->
        Ast_helper.Exp.fun_ ~loc label None p e
    | cases when label="" -> 
        Ast_helper.Exp.function_ ~loc cases
    | _ -> assert false

(*
(* Build the general let-Parsetree (like the fun-Parsetree) *)
let build_let : 
  Location.t -> bool -> 
  (Parsetree.pattern list * string loc list) -> code_repr array ->
  (code_repr array -> code_repr array) -> code_repr =
  fun l recf (pats,old_names) ecs fbodies ->
    let (names,bvars,ebodies) = with_binding_region_gen l old_names fbodies in
    let ebody = match ebodies with [x] -> x | _ -> assert false in
    let pats = 
      if names = [] then pats else
      let (pats,acc) = pattern_subst_list names pats in
      assert (acc = []); pats
    in
    let (es,evars) = validate_vars_list l (Array.to_list ecs) in
    Code (merge evars bvars,
          {pexp_loc = l; 
           pexp_desc = 
             Pexp_let ((if recf then Default else Nonrecursive), 
                       List.map2 (fun p e -> (p,e)) pats es,ebody)})
*)

(* build match and try: both are very similar and similar to build_fun *)
let build_match : 
  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
  int ->
  (code_repr array -> (code_repr option * code_repr) array) -> code_repr =
  fun loc pon ec nregular fgbodies ->
    let Code (evars,exp) = validate_vars loc ec in
    let split : int -> 'a list -> 'a list * 'a list = fun n lst ->
      let rec loop n acc lst = match (n,lst) with
      | (0,lst)  -> (List.rev acc,lst)
      | (n,h::t) -> loop (n-1) (h::acc) t
      | _        -> assert false
      in loop n [] lst
    in
    prepare_cases loc evars pon fgbodies @@ fun cases ->
      Ast_helper.Exp.match_ ~loc exp
      (let (rc,ec) = split nregular cases in
       rc @ List.map 
          (fun c ->
            let pat = {c.pc_lhs with ppat_desc = Ppat_exception c.pc_lhs}
            in {c with pc_lhs = pat}) ec)


(* Essentially the same as build_match.
   TODO: implement the same check on the timestamp of the expression to try
*)
let build_try : 
  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
  (code_repr array -> (code_repr option * code_repr) array) -> code_repr =
  fun loc pon ec fgbodies ->
    let Code (evars,exp) = validate_vars loc ec in
    prepare_cases loc evars pon fgbodies @@ fun cases ->
      Ast_helper.Exp.try_ ~loc exp cases

(*}}}*)


(* ------------------------------------------------------------------------ *)
(* The main function to translate away brackets. It receives
   an expression at the level n > 0.

   Since bracket-translation is somewhat similar to un-typechecking,
   see tools/untypeast.ml for hints on mapping Typedtree.expression
   to Parsetree.expression.

TODO: an optimization idea. Consider <assert e> as a typical expression.
We translate it to the invocation of build_assert that will construct
the Parsetree node at run-time. However, if 'e' is simple (e.g., a constant)
then we can construct the Parsetree node at compile time and pass it
as a CSP. There are no longer any functions calls to make at run-time.
So, we can modify the translation of <assert e> below to detect
if the translation of e produced Texp_cspval. We extract the CSP value,
invoke build_assert (at compile time, when trx.ml is run) to build
the Pexp_assert node, and wrap it as a CSP.

Essentially the result of trx_bracket should be like
   Transl_bracket of Parsetree.expression option * Typedtree.expression
The first part of the result is the code built-in at compile time.
This part is None of the expression to translate contains an escape
or a true CSP (global id is OK). Sometimes we need both parts: consider
       <fun x -> x + ~(...)>
When we translate x we don't know if we can take a shortcut and
build the function code at translation time. So, we have to account
for both possibilities. If we can build the function at compile time,
we don't even need to rename the bound variable!

*)

(* Given a type [ty], return [ty code code ... code] (n times code).
   When we push the bracket in, expressions that had type ty before
   will have the type ty code.
   Here, ty code is an abstract type whose concrete representation
   is code_repr.
   Generally speaking we don't have to adjust the types since the
   type checking is finished. However, code generator may look
   at types; it's better if we don't lie. Thus, as trx_bracket
   translates the expression, it should also adjust the types.
*)

let rec wrap_ty_in_code : int -> type_expr -> type_expr = fun n ty ->
  if n=0 then ty else
  (* let clsfier = Btype.newgenvar () in *)
  wrap_ty_in_code (n-1) (Predef.type_code ty)

let map_option : ('a -> 'b) -> 'a option -> 'b option = fun f -> function
  | None   -> None
  | Some x -> Some (f x)


let rec trx_bracket : int -> expression -> expression = fun n exp ->
  (*
      let _ = debug_print "Texp_bracket" in
      let rec prattr = function
        | [] -> ()
        | ({txt=name},_) :: t -> 
            debug_print ("attr: " ^ name); prattr t
      in prattr   exp.exp_attributes;
      let _ = Location.print Format.err_formatter (exp.exp_loc) in
  *)
  (* Handle staging constructs, which are distinguished solely by
     attributes *)
  match what_stage_attr exp.exp_attributes with
  | Stage0 -> trx_bracket_ n exp
        (* see texp_braesc for the representation of brackets and escapes
           in the Typedtree *)
  | Bracket(_,attrs) -> 
  begin
    match exp.exp_desc with
    | Texp_sequence (_,exp) ->
      {exp with exp_type = wrap_ty_in_code n exp.exp_type;
                exp_attributes = attrs;
                exp_desc =
                 texp_apply (texp_ident "Trx.build_bracket")
                   [texp_loc exp.exp_loc; trx_bracket (n+1) exp]}
    | _ -> assert false   (* corrupted representation of bracket *)
  end
  | Escape(_,attrs) -> 
  begin
    match exp.exp_desc with
    | Texp_sequence (_,exp) ->
        if n = 1 then exp	               (* switch to 0 level *)
        else
        {exp with 
          exp_type = wrap_ty_in_code n exp.exp_type;
          exp_attributes = attrs;
          exp_desc = texp_apply (texp_ident "Trx.build_escape")
                      [texp_loc exp.exp_loc; trx_bracket (n-1) exp]}
    | _ -> assert false   (* corrupted representation of escape *)
  end
  | CSP(_,li,attrs) -> (* For CSP, we only need to propagate the CSP attr *)
     {exp with 
         exp_type = wrap_ty_in_code n exp.exp_type;
         exp_attributes = attrs;
         exp_desc = texp_apply 
                     (texp_ident "Trx.dyn_quote") [exp; texp_lid li]}

  (* convert the case list to the function that receives the sequence
     of bound variables and returns the array of translated guards and
     bodies
   *)
and trx_case_list_body : int -> Typedtree.pattern -> 
  expression ->  (* used as the template for the result: we use
                    the env, location info *)
  case list -> expression = fun n binding_pat exp cl ->
  (* Translate the future-stage function as the present-stage 
     function whose argument is an array of variables 
     (should be a tuple, really) and the type
     some_targ code array -> tres code array
     Using array forces a single type to all arguments. Although
     it is phantom anyway, it is still a bummer. Instead of
     array, we should have used a tuple. But then we can't
     generically write build_fun.
   *)
  (* Pattern representing the function's argument:
     array of variables bound by the original pattern, in order.
   *)
  let body = 
    texp_array (List.map (fun {c_guard;c_rhs;_} -> 
      texp_tuple [texp_option @@ map_option (trx_bracket n) c_guard;
                  trx_bracket n c_rhs])
      cl) in
  { exp with
    exp_desc = Texp_function ("",[texp_case binding_pat body],Total);
    exp_type = {exp.exp_type with desc =
                   Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
  }


and trx_bracket_ : int -> expression -> expression = fun n exp ->
  let new_desc = match exp.exp_desc with
    (* Don't just do only for vd.val_kind = Val_reg 
       because (+) or Array.get are Val_prim *)
  | Texp_ident (p,li,vd)  ->
    let stage = get_level vd.val_attributes in
    (* We make CSP only if the variable is bound at the stage 0.
       Variables bound at stage > 0 are subject to renaming.
       They are translated into stage 0 variable but of a different
       type (t code), as explained in the title comments.
     *)
    if stage = 0 then trx_csp exp p li 
    else
         (* Future-stage bound variable becomes the present-stage
            bound-variable, but at a different type.
          *)
      let () = assert (vd.val_kind = Val_reg) in
      (* The drawback is that exp.exp_loc disappears. If the scope extrusion
         is reported for a simple expression like <x>, we can no longer
         print in the error message the location that <x> appeared.
         We can only print the location x was bound.
      *)
      Texp_ident (p,li,{vd with val_type = wrap_ty_in_code n vd.val_type})

  | Texp_constant cst -> 
      texp_code ~node_id:"*cst*" exp.exp_loc (Pexp_constant cst)

(*
     (* Recursive let: 
         let rec f = e1 [and g = e2 ...] in body
        According to transl_let in bytecomp/translcore.ml,
        the patterns in recursive let are very restrictive: elther
          let rec var = ...
        or
          let rec _ as var = ...
       For instance, let rec (x1,x2) = ... is not allowed.
       We do this test here. For simplicity, we are not going to support
          let rec _ as var = ...
       pattern.
      *)
  | Texp_let (Recursive,pel,ebody) ->
      let names =                       (* in the order of appearance *)
        let rec loop = function
          | [] -> []
          | ({pat_desc = Tpat_var (_,name)},_) :: rest -> name :: loop rest
          | _ -> trx_error @@ Location.errorf ~loc:exp.exp_loc
                "Only variables are allowed as left-hand side of `let rec'"
        in loop pel
      in
      (* code for body followed by the code for e's *)
      let es_body = texp_array (
        trx_bracket trx_exp n ebody ::
          (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel)) in
      texp_apply (texp_ident "Trx.build_letrec") 
        [texp_loc exp.exp_loc;
         texp_array (List.map texp_string_loc names);
             (* Translate the future-stage function as the present-stage 
                function whose argument is an array of variables 
                (should be a tuple, really) and the type
                   some_targ code array -> tres code array
                See the comment at Texp_function below for details.
              *)
         let pats = List.map (fun (p,_) -> 
                      {p with pat_type = wrap_ty_in_code n p.pat_type}) pel in
         let p1 = (match pats with h::_ -> h | _ -> assert false) in
         let pat = {p1 with
                    pat_desc = Tpat_array pats;
                    pat_type = 
                        Ctype.instance_def (Predef.type_array p1.pat_type)} in
         { exp with
           exp_desc = Texp_function ("",[(pat, es_body)],Total);
           exp_type = {exp.exp_type with desc =
                           Tarrow ("",pat.pat_type, es_body.exp_type, Cok)}
         }
       ]

     (* The most common case of let-expressions: non-recursive
        let x = e in body *)
     (* recf = Default for a let auto-generated by the type
        checker for the default function argument.
      *)
  | Texp_let (recf,[({pat_desc = Tpat_var (_,name)} as pat,e)],ebody) ->
      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
      texp_apply (texp_ident "Trx.build_let_simple_nonrec") 
        [texp_loc exp.exp_loc;
         texp_string_loc name;
         texp_bool (recf = Default);
         trx_bracket trx_exp n e;
         { exp with
           exp_desc = 
             Texp_function ("",[(pat, trx_bracket trx_exp n ebody)],Total);
           exp_type = 
            {exp.exp_type with desc =
               Tarrow ("",pat.pat_type, wrap_ty_in_code n ebody.exp_type, Cok)}
         }
       ]

    (* General-case, non-recursive let General case. Like Texp_function *)
  | Texp_let (recf,pel,body) ->
      let (pl,names,binding_pat) = 
        trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) in
      texp_apply (texp_ident "Trx.build_let") 
        [texp_loc exp.exp_loc;
         texp_bool (recf = Default);
         texp_pats_names pl names;
         texp_array (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel);
         (* See the comment at Texp_function below *)
         let body = texp_array [trx_bracket trx_exp n body] in
         { exp with
           exp_desc = Texp_function ("",[(binding_pat, body)],Total);
           exp_type = {exp.exp_type with desc =
                       Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
         }
       ]
*)
     (* The most common case of functions: fun x -> body *)
  | Texp_function (l,[{c_guard=None; 
                       c_lhs={pat_extra=[]; 
                              pat_desc = Tpat_var (_,name)} as pat;
                       c_rhs=ebody}],_) ->
      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
      texp_apply (texp_ident "Trx.build_fun_simple") 
        [texp_loc exp.exp_loc;
         texp_string l;
         texp_string_loc name;
         (* Translate the future-stage function as present-stage function;
            with the same variables, but with a different type,
            targ code -> tres code
          *)
         { exp with
           exp_desc = 
             Texp_function
               ("",[texp_case pat (trx_bracket n ebody)],Total);
           exp_type = 
            {exp.exp_type with desc =
               Tarrow ("",pat.pat_type, wrap_ty_in_code n ebody.exp_type, Cok)}
         }
       ]

  | Texp_function (l,cl,_) ->
      begin
      match trx_cl cl (wrap_ty_in_code n (Btype.newgenvar ())) with
      | (pl, [], _) ->                    (* non-binding pattern *)
          texp_apply (texp_ident "Trx.build_fun_nonbinding")
            [texp_loc exp.exp_loc; 
             texp_string l;
             begin 
               let pl_exp = texp_ident "Trx.sample_pat_list" in
               {pl_exp with
                exp_desc = (texp_csp (Obj.repr pl)).exp_desc}
             end;
             texp_array (List.map (fun {c_guard;c_rhs;_} -> 
                 texp_tuple [texp_option @@ 
                              map_option (trx_bracket n) c_guard;
                             trx_bracket n c_rhs]) 
                 cl)
           ]
      | (pl, names, binding_pat) ->
          texp_apply (texp_ident "Trx.build_fun") 
            [texp_loc exp.exp_loc;
             texp_string l;
             texp_pats_names pl names;
             trx_case_list_body n binding_pat exp cl
           ]
      end

  | Texp_apply (e, el) ->
     (* first, we remove from el the information added by the type-checker *)
     let lel = List.fold_right (function                 (* keep the order! *)
                | (_,None,_)   -> fun acc -> acc
                | (l,Some e,_) -> fun acc -> (l,e)::acc) el [] in
     let lel = ("",e) :: lel in          (* Add the operator *)
      texp_apply (texp_ident "Trx.build_apply")
        [texp_loc exp.exp_loc; 
         texp_array (List.map (fun (l,e) ->
           texp_tuple [texp_string l;trx_bracket n e]) lel)]

  (* Pretty much like a function *)
  (* rcl: regular cases; ecl: exceptional cases *)
  | Texp_match (e,rcl,ecl,_) ->
      let cl = rcl @ ecl in     (* handle all cases uniformly *)
      let (pl,names,binding_pat) = 
        trx_cl cl (wrap_ty_in_code n (Btype.newgenvar ())) in
      texp_apply (texp_ident "Trx.build_match") 
        [texp_loc exp.exp_loc;
         texp_pats_names pl names;
         trx_bracket n e;
         texp_int @@ List.length rcl;
         trx_case_list_body n binding_pat exp cl
       ]

  | Texp_try (e,cl) ->                 (* same as Texp_match *)
      let (pl,names,binding_pat) = 
        trx_cl cl (wrap_ty_in_code n (Btype.newgenvar ())) in
      texp_apply (texp_ident "Trx.build_try") 
        [texp_loc exp.exp_loc;
         texp_pats_names pl names;
         trx_bracket n e;
         trx_case_list_body n binding_pat exp cl
       ]

  | Texp_tuple el ->
      texp_apply (texp_ident "Trx.build_tuple")
        [texp_loc exp.exp_loc; 
	 texp_array (List.map (trx_bracket n) el)]

  | Texp_construct (li, cdesc, args) ->
      let lid = qualify_ctor li cdesc in
      texp_apply (texp_ident "Trx.build_construct")
        [texp_loc exp.exp_loc; 
         texp_lid lid;
	 texp_array (List.map (trx_bracket n) args)]

  | Texp_variant (l,eo) ->              (* polymorphic variant *)
      texp_apply (texp_ident "Trx.build_variant")
        [texp_loc exp.exp_loc; 
         texp_string l;
	 texp_option (map_option (trx_bracket n) eo)]

  | Texp_record (lel,eo) ->
      texp_apply (texp_ident "Trx.build_record")
        [texp_loc exp.exp_loc; 
         texp_array (List.map (fun (li,ldesc,e) ->
           texp_tuple [texp_lid (qualify_label li ldesc);
                       trx_bracket n e]) lel);
         texp_option (map_option (trx_bracket n) eo)]

  | Texp_field (e,li,ldesc) ->
      texp_apply (texp_ident "Trx.build_field")
        [texp_loc exp.exp_loc; 
         trx_bracket n e;
         texp_lid (qualify_label li ldesc)]

  | Texp_setfield (e1,li,ldesc,e2) ->
      texp_apply (texp_ident "Trx.build_setfield")
        [texp_loc exp.exp_loc; 
         trx_bracket n e1;
         texp_lid (qualify_label li ldesc);
         trx_bracket n e2]

  | Texp_array el ->
      texp_apply (texp_ident "Trx.build_array")
        [texp_loc exp.exp_loc; 
	 texp_array (List.map (trx_bracket n) el)]

  | Texp_ifthenelse (e,et,efo) ->
      texp_apply (texp_ident "Trx.build_ifthenelse")
        [texp_loc exp.exp_loc; 
         trx_bracket n e;
         trx_bracket n et;
	 texp_option (map_option (trx_bracket n) efo)]

  | Texp_sequence (e1,e2) ->
      texp_apply (texp_ident "Trx.build_sequence")
        [texp_loc exp.exp_loc; 
	 trx_bracket n e1; trx_bracket n e2]
  | Texp_while (e1,e2) ->
      texp_apply (texp_ident "Trx.build_while")
        [texp_loc exp.exp_loc; 
	 trx_bracket n e1; trx_bracket n e2]

  | Texp_for (id, pat, elo, ehi, dir, ebody) ->
      let name =
        begin
          match pat.ppat_desc with
          | Ppat_any -> mknoloc "_for"  (* the typechecker also makes a dummy*)
          | Ppat_var x -> x
          | _  -> assert false
        end
      in
      texp_apply (texp_ident "Trx.build_for") 
        [texp_loc exp.exp_loc;
         texp_string_loc name;
         trx_bracket n elo;
         trx_bracket n ehi;
         texp_bool (dir = Upto);
         let var_typ = wrap_ty_in_code n (Ctype.instance_def Predef.type_int) in
         let pat = {pat_loc = exp.exp_loc; pat_extra = [];
                    pat_attributes = [];
                    pat_type = var_typ; pat_env = exp.exp_env;
                    pat_desc = Tpat_var (id,name)} in
         { exp with
           exp_desc = 
             Texp_function ("",[texp_case pat (trx_bracket n ebody)],Total);
           exp_type = 
            {exp.exp_type with desc =
               Tarrow ("",var_typ, wrap_ty_in_code n ebody.exp_type, Cok)}
         }
       ]

  | Texp_send (e,m,_) ->
      (* We don't check the persistence of the method: after all,
         a method name is somewhat like a polymorphic variant.
         It's perfectly OK to have a function fun x -> x # foo
      *)
      texp_apply (texp_ident "Trx.build_send")
        [texp_loc exp.exp_loc; 
	 trx_bracket n e;
         texp_string (match m with
                        | Tmeth_name name -> name
                        | Tmeth_val id -> Ident.name id)]

  | Texp_new (p,li,_) ->
      check_path_quotable "Class" p;
      texp_code ~node_id:"*new*" exp.exp_loc 
        (Pexp_new (Location.mkloc (path_to_lid p) li.loc))

  | Texp_instvar (p1,p2,s) ->
      not_supported exp.exp_loc "Objects (Texp_instvar)"
        (* Alternatively: since instance variables are always bound 
           at level 0 (for now)
           so this is like a csp variable 
        call_trx_mkcsp exp None (path_to_lid p2)
        *)
  | Texp_setinstvar _ -> not_supported exp.exp_loc "Objects (Texp_setinstvar)"
  | Texp_override  _  -> not_supported exp.exp_loc "Objects (Texp_override)"
  | Texp_letmodule (id,s,me,e) -> not_supported exp.exp_loc "let module"

  | Texp_assert e ->
      texp_apply (texp_ident "Trx.build_assert")
        [texp_loc exp.exp_loc; trx_bracket n e]

  | Texp_lazy e ->
      texp_apply (texp_ident "Trx.build_lazy")
        [texp_loc exp.exp_loc; trx_bracket n e]

  | Texp_object (cl,fl) -> not_supported exp.exp_loc "Objects"
  | Texp_pack _         -> not_supported exp.exp_loc "First-class modules"
  | _ -> not_supported exp.exp_loc "not yet supported"
  in                               
  (* See untype_extra in tools/untypeast.ml *)
  let trx_extra (extra, loc, attr) exp =  (* TODO: take care of attr *)
   let desc =
    match extra with
      (* Should check that cty1 and cty2 contain only globally declared
         type components
       *)
    | Texp_constraint cty -> 
        not_supported loc "Texp_constraint"
    | Texp_coerce (cto,ct) ->
        not_supported loc "Texp_coerce"
    | Texp_open (ovf, path, lid, _) -> 
       (* I don't need local open since all the constructors
          and identifiers are qualified anyway.
        *)
        exp.exp_desc
          (*
       check_path_quotable "Texp_open" path;
       texp_apply (texp_ident "Trx.build_open")
        [texp_loc exp.exp_loc;
         texp_lid (mkloc (path_to_lid path) lid.loc);
         texp_csp (Obj.repr ovf);
         exp]      (* exp is the result of trx_bracket *)
           *)
    | Texp_poly cto  -> not_supported loc "Texp_poly"
    | Texp_newtype s -> not_supported loc "Texp_newtype"
    in {exp with exp_loc = loc; exp_desc = desc} (* type is the same: code *)
  in
  List.fold_right trx_extra exp.exp_extra
  {exp with exp_type = wrap_ty_in_code n exp.exp_type;
            exp_desc = new_desc}



(*{{{ Typedtree traversal to eliminate bracket/escapes *)

(* This part is obsolete *)

(* ------------------------------------------------------------------------ *)
(* Typedtree traversal to eliminate bracket/escapes *)

(* Functions to help traverse and transform a tree.
   We assume that every tree mapping function of the type 'a -> 'a
   throws the exception Not_modified if the tree has not been
   modified.
   This protocol helps minimize garbage and prevent useless tree
   duplication.

   We do not traverse attributes.
*)

exception Not_modified

let replace_list : ('a -> 'a) -> 'a list -> 'a list = fun f l ->
  let rec loop mdf = function
  | [] -> if mdf then [] else raise Not_modified
  | h::t -> match (try Some (f h) with Not_modified -> None) with
             | Some h -> h :: loop true t
             | None   -> h :: loop mdf  t
  in loop false l

let replace_pair : ('a -> 'a) -> ('b -> 'b) -> 'a * 'b -> 'a * 'b =
  fun f g (x,y) ->
  match ((try Some (f x) with Not_modified -> None),
         (try Some (g y) with Not_modified -> None)) with
  | (None,None)      -> raise Not_modified
  | (Some x, None)   -> (x,y)
  | (None, Some y)   -> (x,y)
  | (Some x, Some y) -> (x,y)

let replace_opt : ('a -> 'a) -> 'a option -> 'a option = fun f -> function
  | Some e -> Some (f e)
  | None   -> raise Not_modified

(* The main function to scan the typed tree at the 0 level and
   detect brackets 
*)

let rec trx_struct str =
  {str with str_items = 
  replace_list (fun si -> {si with str_desc = trx_struct_item si.str_desc})
           str.str_items}

and trx_vb_list l = 
  replace_list (fun vb -> {vb with vb_expr = trx_exp vb.vb_expr}) l

and trx_struct_item = function
| Tstr_eval (e,a) -> Tstr_eval (trx_exp e,a)
| Tstr_value (rf,vbl) ->
    Tstr_value(rf, trx_vb_list vbl)
| Tstr_primitive _
| Tstr_type _
| Tstr_typext _
| Tstr_exception _   -> raise Not_modified
| Tstr_module mb     -> Tstr_module (trx_mb mb)
| Tstr_recmodule mbl -> Tstr_recmodule (replace_list trx_mb mbl)
| Tstr_modtype _
| Tstr_open _ -> raise Not_modified
| Tstr_class l ->
    Tstr_class (replace_list (fun (dcl,sl,vf) -> (trx_cdcl dcl,sl,vf)) l)
| Tstr_class_type _ -> raise Not_modified
| Tstr_include id ->
    Tstr_include {id with incl_mod = trx_me id.incl_mod}
| Tstr_attribute _ -> raise Not_modified

and trx_mb mb = 
  {mb with mb_expr = trx_me mb.mb_expr}

and trx_me me = 
  {me with mod_desc = trx_me_desc me.mod_desc} 

and trx_me_desc = function
| Tmod_ident _ -> raise Not_modified
| Tmod_structure str -> Tmod_structure (trx_struct str)
| Tmod_functor (i,l,t,me) -> Tmod_functor (i,l,t, trx_me me)
| Tmod_apply (me1,me2,mc) ->
  let (me1,me2) = replace_pair trx_me trx_me (me1,me2) in
  Tmod_apply (me1, me2, mc)
| Tmod_constraint (me,mt,mtc,mc) -> Tmod_constraint (trx_me me, mt, mtc, mc)
| Tmod_unpack (e,mt) -> Tmod_unpack (trx_exp e,mt)

and trx_cdcl class_decl =
  {class_decl with ci_expr = trx_ce class_decl.ci_expr}

and trx_ce class_expr =
  {class_expr with cl_desc = trx_ce_desc class_expr.cl_desc}

and trx_cl_struct cs =
  {cs with cstr_fields = 
     replace_list (fun cf -> {cf with cf_desc = trx_cf cf.cf_desc})
                  cs.cstr_fields}

and trx_ce_desc = function
| Tcl_ident (_,_,_) -> raise Not_modified
| Tcl_structure cs  -> Tcl_structure (trx_cl_struct cs)
| Tcl_fun (l,p,el,ce,pa) ->
  let (el,ce) = 
        replace_pair (replace_list (fun (i,l,e) -> (i,l,trx_exp e)))
                     trx_ce (el,ce) in
  Tcl_fun (l,p,el,ce,pa)
| Tcl_apply (ce,el) ->
  let repel (l,eo,o) = (l,replace_opt trx_exp eo,o) in
  let (ce,el) = replace_pair trx_ce (replace_list repel) (ce,el) in
  Tcl_apply (ce,el)
| Tcl_let (rf,vbl,el2,ce) ->
  let repel2 = replace_list (fun (i,l,e) -> (i,l,trx_exp e)) in
  let ((vbl,el2),ce) = replace_pair (replace_pair trx_vb_list repel2) trx_ce
                        ((vbl,el2),ce)
  in Tcl_let (rf,vbl,el2,ce)
| Tcl_constraint (ce,ct,sl1,sl2,cty) ->
  Tcl_constraint (trx_ce ce,ct,sl1,sl2,cty)

and trx_cf = function
| Tcf_inherit (ofl,ce,so,sl1,sl2) ->
  Tcf_inherit (ofl,trx_ce ce,so,sl1,sl2)
| Tcf_val (_,_,_,Tcfk_virtual _,_) -> raise Not_modified
| Tcf_val (sl,mf,i,Tcfk_concrete (ovf,e),b) ->
  Tcf_val (sl,mf,i,Tcfk_concrete (ovf,trx_exp e),b)
| Tcf_method (sl,pf,Tcfk_virtual _) -> raise Not_modified
| Tcf_method (sl,pf,Tcfk_concrete (ovf,e)) ->
  Tcf_method (sl,pf,Tcfk_concrete (ovf,trx_exp e))
| Tcf_constraint (_,_) -> raise Not_modified
| Tcf_initializer e -> Tcf_initializer (trx_exp e)
| Tcf_attribute _ -> raise Not_modified

and trx_exp exp =
  {exp with exp_desc = trx_expression exp.exp_desc}

and trx_caselist l = replace_list (fun cas -> 
   let (g,rhs) = replace_pair (replace_opt trx_exp) trx_exp 
                     (cas.c_guard,cas.c_rhs) in
   {cas with c_guard = g; c_rhs = rhs}) 
 l

and trx_expression = function
| Texp_ident (_,_,_)
| Texp_constant _ -> raise Not_modified
| Texp_let (rf, vbl, e) ->
  let (vbl,e) = replace_pair trx_vb_list trx_exp (vbl,e)
  in Texp_let (rf, vbl, e)
| Texp_function (l,cl,p) ->
  Texp_function (l,trx_caselist cl,p)
| Texp_apply (e,el) ->
  let repl (l,eo,op) = (l,replace_opt trx_exp eo,op) in
  let (e,el) = replace_pair trx_exp (replace_list repl) (e,el)
  in Texp_apply (e,el)
| Texp_match (e,cl1,cl2,p) ->
  let (e,(cl1,cl2)) = replace_pair 
     trx_exp (replace_pair trx_caselist trx_caselist) (e,(cl1,cl2))
  in Texp_match (e,cl1,cl2,p)
| Texp_try (e,cl) ->
  let (e,cl) = replace_pair trx_exp trx_caselist (e,cl)
  in Texp_try (e,cl)
| Texp_tuple l -> Texp_tuple (replace_list trx_exp l)
| Texp_construct (l,cd,el) ->
  Texp_construct (l,cd,replace_list trx_exp el)
| Texp_variant (l,eo) -> Texp_variant (l,replace_opt trx_exp eo)
| Texp_record (ll,eo) ->
  let repll (l,ld,e) = (l,ld,trx_exp e) in
  let (ll,eo) = replace_pair (replace_list repll) (replace_opt trx_exp) (ll,eo)
  in Texp_record (ll,eo)
| Texp_field (e,l,ld) -> Texp_field (trx_exp e,l,ld)
| Texp_setfield (e1,l,ld,e2) ->
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_setfield (e1,l,ld,e2)
| Texp_array el -> Texp_array (replace_list trx_exp el)
| Texp_ifthenelse (e1,e2,eo) ->
  let ((e1,e2),eo) = replace_pair (replace_pair trx_exp trx_exp) 
                                  (replace_opt trx_exp) ((e1,e2),eo)
  in Texp_ifthenelse (e1,e2,eo)
| Texp_sequence (e1,e2) -> 
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_sequence (e1,e2)
| Texp_while (e1,e2) ->
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_while (e1,e2)
| Texp_for (i,p,e1,e2,df,e3) ->
  let ((e1,e2),e3) = replace_pair (replace_pair trx_exp trx_exp) 
                                  trx_exp ((e1,e2),e3)
  in Texp_for (i,p,e1,e2,df,e3)
| Texp_send (e1,m,eo) ->
  let (e1,eo) = replace_pair trx_exp (replace_opt trx_exp) (e1,eo)
  in Texp_send (e1,m,eo)
| Texp_new (_,_,_)
| Texp_instvar (_,_,_) -> raise Not_modified
| Texp_setinstvar (p1,p2,l,e) -> Texp_setinstvar (p1,p2,l,trx_exp e)
| Texp_override (p, el) ->
  Texp_override (p, replace_list (fun (p,l,e) -> (p,l,trx_exp e)) el)
| Texp_letmodule (i,l,me,e) ->
  let (me,e) = replace_pair trx_me trx_exp (me,e)
  in Texp_letmodule (i,l,me,e)
| Texp_assert e -> Texp_assert (trx_exp e)
| Texp_lazy e -> Texp_lazy (trx_exp e)
| Texp_object (cs,sl) -> Texp_object (trx_cl_struct cs,sl)
| Texp_pack me -> Texp_pack (trx_me me)
(* XXXXX
| Texp_bracket e -> 
   let trx_exp e = try trx_exp e with Not_modified -> e in
  (trx_bracket trx_exp 1 e).exp_desc

| Texp_escape _ -> assert false         (* Not possible in well-typed code *)
| Texp_cspval (_,_) -> raise Not_modified
*)


(* public interface *)
let trx_structure str = 
  try trx_struct str with Not_modified -> str

(*}}}*)

  
