(* Converting a simple subset of OCaml to an intermediate language 
   designed to be easily translatable to C, openCL, LLVM, etc.

   We handle only an (imperative) subset of OCaml, as typical in offshoring.

   We take advantage of the fact that the our OCaml source is presumed
   to have been generated by MetaOCaml: All identifiers
   have unique names and all types are fully qualified.

   Simple OCaml code may be considered as C written in different syntax.
   The following helps bring OCaml closer to C.

   One notable difference from C is the treatment of references and
   reference types. To avoid subtle putfalls, we only permit
   t ref types where t is a base type. Further, a let-statement binding
   a variable of a referencee type must have the form
     let x = function-application in ...
   (normally, let x = ref e in ...). That is, let x = y is prohibited
  if y has a reference type.

*)

(* 
   The OCaml implementation is there to make the code run in OCaml,
   for testing. The C translation will look at the names themeselves,
   as `float32', 'forloop', etc.
#directory "+compiler-libs";;
*)

type float32 = float

let float32_of_float : float -> float32 = fun x -> x

(* For-loop with a step, like the for-loop in C (upper bound is exclusive) *)
let forloop : int -> int -> int -> (int -> unit) -> unit =
 fun lwb upb step body ->
   let rec loop i = if i >= upb then () else (body i; loop (i+step))
   in loop lwb


(* Types that we currently support
   It is a subset of the very simplified OCaml type representation
   It is much easier to deal with than OCaml compiler type representation
*)

type typ = ..
type typ +=
  | TUnit
  | TInt
  | TBool
  | TFloat                              (* 32-bit *)
  | TDouble                             (* 64-bit *)
  | TArray1 of typ                      (* Usual array or Bigarray.Array1 *)
  | TArray2 of typ                      (* Bigarray.Array2 *)
  | TRef of typ
  | TVariable                           (* sometimes inevitably occurs
                                           We do not do any substitutions, etc*)

let base_type : typ -> bool = function
   | TUnit | TInt | TBool | TFloat | TDouble -> true
   | _ -> false

(* We don't timestamp the variable names since MetaOCaml already
   renamed all the identifiers
*)
type varname = string 
		 
(* The AST of the intermediate language (IR)
   It reflects the simple subset of OCaml that we handle *)

type attribute = ..
type constant_t = 
  | Const_unit
  | Const_int    of int
  | Const_float  of float
  | Const_bool   of bool
  | Const_char   of char
  | Const_string of string

type exp =
  | Const    of constant_t              (* Constant/literal: int, bool,...*)
  | LocalVar of varname * typ           (* Locally-bound variable *)
  | KnownVar of varname                 (* Global/library function,... *)
  | FunCall  of varname * exp list      (* Calls only to known identifiers *)
  | Let      of {id: varname; ty: typ; bind: exp; body: exp;
                 attrs: attribute list}
  | IfE      of exp * exp * exp
  | SeqE     of cmd * exp
  | ArrayE   of exp list                (* immediate array *)
 and cmd =
  | FunCallC of varname * exp list      (* Calls only to known identifiers *)
  | LetC      of {id: varname; ty: typ; bind: exp; body: cmd;
                 attrs: attribute list}
  | If       of exp * cmd * cmd option
  | For      of {id: varname; ty:typ;
                 lwb: exp; upb: exp; step: exp; body: cmd}
  | While    of exp * cmd 
  | Seq      of cmd * cmd
  | UnitC                               (* empty statement *)
 
(* User-defined converters-helpers *)
module type converters = sig
  type pathname = string                (* a fully-qualified name *)
  (* Convert a type, with the head constructor of the given qualified
     name and the given parameters
   *)
  val type_conv : pathname -> typ list -> typ
  (* Convert a qualified id, given the module path and the name,
     into something that, say, a C code generator may use for a name.
     Some module names like Opencl may be known to the C generator
     and treated specially.
   *)
  val id_conv : pathname -> varname -> string
end

(* Convert an OCaml type to the simpler representation typ,
   raising exception on the types we do not handle
*)
			
let typ_of : (module converters) -> Types.type_expr -> Env.t -> typ 
 = fun (module Conv) typ env ->
  let open Types in
  let typ = Ctype.correct_levels typ in
  let rec loop typ =
    let exp_ty = Ctype.expand_head env typ in
    match Ctype.repr exp_ty with
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_unit ->
        TUnit
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
        TInt
    (*
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
        "char" *)
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
        TBool
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_float ->
        TDouble
    | {desc = Tconstr(p, [t], _)} when Path.same p Predef.path_array ->
        TArray1 (loop t)
    | {desc = Tconstr(p, [t;_;_], _)} when 
           Path.name p = "Bigarray.Array1.t" ->
             TArray1 (loop t)
    | {desc = Tconstr(p, [t;_;_], _)} when 
           Path.name p = "Stdlib__bigarray.Array1.t" ->
             TArray1 (loop t)
    (*
    | {desc = Tconstr(p, [t;_;_], _)} when 
           Path.name p = "Bigarray.Array2.t" ->
             TArray2 (loop t)
    *)
    | {desc = Tconstr (p,[t], _)} when Path.name p = "Stdlib.ref" ->
        let t = loop t in
        if base_type t then TRef t
        else Format.kasprintf failwith
          "typ_of: the OCaml type %a is (not yet) supported: \
          only base-type ref types are allowed"
          Printtyp.type_expr typ
    | {desc = Tconstr (p,[], _)} when Path.name p = "OffshoringIR.float32" ->
        TFloat
    | {desc = Tconstr (p,ts, _)} ->
        Conv.type_conv (Path.name p) (List.map loop ts)
    | {desc = Tvar _} -> TVariable
    | _ -> 
       Format.kasprintf failwith
          "typ_of: the OCaml type %a is (not yet) supported"
          Printtyp.type_expr typ
  in loop typ
	  

(* Alas, Printtyped only exports functions for printing structures and
   signatures. If we want to print an expression, we have to wrap it
   into a signature
*)
let print_texp : Format.formatter -> Typedtree.expression -> unit =
  fun ppf exp ->
   let open Typedtree in
   let stru = 
    {str_items =
      [{str_desc = Tstr_eval(exp,[]);
        str_loc  = exp.exp_loc;
        str_env  = exp.exp_env}];
     str_type = [];
     str_final_env = exp.exp_env}
    in
    Printtyped.implementation ppf stru

(* Report an expression we aren't handling *)
let fail_exp : string -> Typedtree.expression -> 'a = fun msg exp ->
  Format.kasprintf failwith "%s: @,%a@." msg print_texp exp

(* Handle the top-level function and determine its arguments and their types *)

let analyze_function: 
    (module converters) ->
    Typedtree.expression -> 
      (varname * typ) list *            (* arguments names and types, may be
                                           empty if the funnction is a thunk
                                         *)
      typ *                             (* the type of the result *)
      Typedtree.expression =            (* the function body *)
  fun conv ->
  let open Typedtree in
  let open Asttypes in
  let rec loop acc = function       
    | { Typedtree.exp_desc = 
        Texp_function{arg_label=Nolabel;
                      cases=[
                        {c_lhs = 
                         {pat_desc =Tpat_var (x,_); 
                          pat_type=typ; pat_env=env};
                         c_guard = None;
                         c_rhs   = body}]}} -> 
        loop ((Ident.name x,typ_of conv typ env)::acc) body
    | { Typedtree.exp_desc = 
        Texp_function{arg_label=Nolabel;
                      cases=[
                        {c_lhs = 
                         {pat_desc =
                          Tpat_construct ({txt=Longident.Lident "()"},_,[])};
                         c_guard = None;
                         c_rhs   = body}]}} -> 
        if acc = [] then
          loop (("",TUnit)::acc) body
        else failwith "unit argument must be the only argument of a function"
    | { Typedtree.exp_desc = Texp_function _ } as e ->
        fail_exp "the code is not a simple function" e
    | e when acc = [] -> fail_exp "the code is not a simple function" e
    | e ->
        let tp = e.exp_type and env = e.exp_env in
        ((if acc = [("",TUnit)] then [] else List.rev acc), 
         typ_of conv tp env, e)
  in loop []


(* Convert from the full OCaml AST to the simplified subset *)

(* Classify an identifier *)
type id_class = 
    | Known of varname                 (* Global function, variable, etc *)
    | Local of varname                 (* Locally bound variable *)

let class_of_path : (module converters) -> Path.t -> id_class = 
  let open Path in
  fun (module Conv) -> function
  | Pdot (Pident p, x) when
         Ident.name p = "Stdlib" &&
	 List.mem x ["+";"-";"*";"/";"+.";"-.";"*.";"/.";":=";"ref";"!"] ->
     Known x
  | Pdot (p,"make") when Path.name p = "Stdlib.Array" ->
     Known "array1_make"
  | Pdot (p,"get") when Path.name p = "Stdlib.Array" ->
     Known "array1_get"
  | Pdot (p,"set") when Path.name p = "Stdlib.Array" ->
     Known "array1_set"
  | Pdot (p,"get") when Path.name p = "Bigarray.Array1" ->
     Known "array1_get"
  | Pdot (p,"set") when Path.name p = "Bigarray.Array1" ->
     Known "array1_set"
  (*
  | Pdot (p,"get") when Ident.name p = "Bigarray.Array2" ->
     Known "array2_get"
  *)
  | Pdot (p,"forloop") when Path.name p = "OffshoringIR" ->
     Known "forloop"
  (* Ask the user *)  
  | Pdot (p, x) -> Known (Conv.id_conv (Path.name p) x)
  | Pident x     -> Local (Ident.name x)
  | p -> failwith @@ "class_of_path unknown id: " ^ Path.name p


let rec exp_of : (module converters) -> Typedtree.expression -> exp = 
 fun conv e ->
  let open Typedtree in 
  let open Asttypes in 
  let tp = e.exp_type and env = e.exp_env in
  match e.exp_desc with
  | Texp_ident (p,_,_) -> begin
      match class_of_path conv p with
      | Known x -> KnownVar x
      | Local x -> LocalVar (x, typ_of conv tp env)
      end
  | Texp_constant Asttypes.(Const_int x)   -> Const (Const_int x)
  | Texp_constant Asttypes.(Const_char x)  -> Const (Const_char x)
  | Texp_constant Asttypes.(Const_float x) -> 
      Const (Const_float (float_of_string x))
  | Texp_constant Asttypes.(Const_string (x,_,_)) -> Const (Const_string x)

 (* Get rid of @@ and replace with the ordinary application *)
  | Texp_apply ({exp_desc = Texp_ident (p,_,_)},
                [(Nolabel, Some e1);e2]) when Path.name p = "Stdlib.@@" ->
    begin
      match e1 with
      | {exp_desc = Texp_apply (e11,args)} ->
           exp_of conv {e with exp_desc = Texp_apply (e11,args @ [e2])}
      | _ -> exp_of conv {e with exp_desc = Texp_apply (e1,[e2])}
    end

  (* General application *)
  | Texp_apply (eo,args) ->
      let op = match exp_of conv eo with
      | KnownVar x -> x
      | _  -> fail_exp "Only calls to global functions are allowed" e
      in
      let args = List.map (function 
        | (Nolabel,Some e) -> exp_of conv e
        | _ -> fail_exp "unsupported labeled or default args" e) args in
      FunCall (op,args)
  | Texp_let (Nonrecursive,
               [{vb_pat=
                 {pat_desc =Tpat_var (x,_);pat_type;pat_env};
                 vb_expr}],body)
    -> let ty=typ_of conv pat_type pat_env in
       let bind=exp_of conv vb_expr in
       check_let e ty bind;
       Let {id=Ident.name x; ty; bind; body=exp_of conv body; attrs=[]}
  | Texp_ifthenelse (etest,eth,Some eel) ->
      IfE (exp_of conv etest, exp_of conv eth, exp_of conv eel)
  | Texp_sequence(e1,e2) ->
      SeqE (cmd_of conv e1, exp_of conv e2)
  | Texp_array xs -> ArrayE (List.map (exp_of conv) xs)
  | Texp_construct({txt=Longident.Lident "true"},_,_) ->
      Const (Const_bool true)
  | Texp_construct({txt=Longident.Lident "false"},_,_) ->
      Const (Const_bool false)
  | Texp_construct ({txt=Longident.Lident "()"},_,[]) -> Const Const_unit
  | _ -> fail_exp "unhandled expression" e
 and 
 cmd_of : (module converters) -> Typedtree.expression -> cmd = 
 fun conv e ->
  let open Typedtree in 
  let open Asttypes in 
  let tp = e.exp_type and env = e.exp_env in
  assert (typ_of conv tp env = TUnit);
  match e.exp_desc with
  (* Special applications *)
  | Texp_apply (e,
                [(Nolabel,Some lwb);(Nolabel,Some upb);(Nolabel,Some step);
                 (Nolabel,Some {exp_desc = 
                  Texp_function 
                       {arg_label=Nolabel;
                        cases = [
                         {c_lhs = 
                           {pat_desc =Tpat_var (x,_);
                            pat_env;pat_type};
                          c_guard = None;
                          c_rhs   = body}]}})])
    when
      exp_of conv e = KnownVar "forloop" ->
        For {id=Ident.name x; ty=typ_of conv pat_type pat_env;
             lwb=exp_of conv lwb;
             upb=exp_of conv upb;
             step=exp_of conv step;
             body=cmd_of conv body}
  | Texp_apply _ -> begin
      match exp_of conv e with
      | FunCall (op,args) -> FunCallC (op,args)
      | _ -> assert false
  end
  | Texp_for (x,_,elow,ehigh,Upto,body) ->
      let one = Const (Const_int 1) in
      (* Make the upper bound exclusive *)
      let upb = match exp_of conv ehigh with
      | FunCall ("-", [x;one']) when one'=one -> x
      | x -> FunCall ("+",[one;x]) in
      For {id=Ident.name x; ty=TInt;
             lwb=exp_of conv elow;
             upb;
             step=one;
             body=cmd_of conv body}
  | Texp_while (et,body) ->
      While (exp_of conv et, cmd_of conv body)
  | Texp_ifthenelse (etest,eth,None) ->
      If (exp_of conv etest, cmd_of conv eth, None)
  | Texp_ifthenelse (etest,eth,Some eel) ->
      If (exp_of conv etest, cmd_of conv eth, Some (cmd_of conv eel))
  | Texp_sequence(e1,e2) ->
      Seq (cmd_of conv e1, cmd_of conv e2)
  | Texp_let (Nonrecursive,
               [{vb_pat=
                 {pat_desc =Tpat_var (x,_);pat_type;pat_env};
                 vb_expr}],body)
    -> let ty=typ_of conv pat_type pat_env in
       let bind=exp_of conv vb_expr in
       check_let e ty bind;
       LetC {id=Ident.name x; ty; bind; body=cmd_of conv body; attrs=[]}
  | Texp_construct ({txt=Longident.Lident "()"},_,[]) -> UnitC
  | _ -> fail_exp "unhandled command" e
 and 
  check_let : Typedtree.expression -> typ -> exp -> unit = fun e ty bind -> 
  match (ty,bind) with
   | (TRef _, FunCall _) -> ()
   | (TRef _, _) ->
       fail_exp "When binding variables of ref types, the RHS must be \
         a function call (normally, a ref-function call)" e
   | _ -> ()

(* Default conversion module. The programmer is supposed to
   include it and override what is needed
*)
module DefaultConv : converters = struct
  type pathname = string                (* a fully-qualified name *)
  let type_conv : pathname -> typ list -> typ = fun path _args ->
    failwith @@ "Unknown type: " ^ path
  (* Convert a qualified id, given the module path and the name,
     into something that, say, a C code generator may use for a name.
     Some module names like Opencl may be known to the C generator
     and treated specially.
   *)
  let id_conv : pathname -> varname -> varname = fun path name ->
    failwith @@ "Don't know what to do with " ^ path ^ "." ^ name
end

(* Main offshoring function: convert from the code in the supported 
   subset of OCaml to the intermediate language.
   Return either cmd (for procedure with no result) or exp and the
   result type.
*)
type args_t = (varname * typ) list
type proc_t = 
  | Fun  of args_t * typ * exp           (* Function with the result *)
  | Proc of args_t * cmd                 (* Procedure, no result     *)
let offshore : (module converters) -> 'a Codelib.code -> proc_t = 
 fun conv cde ->
  let (args,typ,body) = 
    analyze_function conv @@
    Runcode.typecheck_code @@ Codelib.close_code cde
  in
  if typ = TUnit then Proc (args, cmd_of conv body)
      else Fun (args, typ, exp_of conv body)



