(*
  This file is to post-process the Typedtree built by the type checker
  when it finished parsing the present-stage bracket expression.
  (Unlike versions before N102, the full Typedtree is not traversed;
  only the bracket expressions are traversed and lifted.) The
  transformation is done by trx_bracket.

  For example,
     <succ 1> 
  gets transformed to 
     mkApp <succ> <1> 
  and eventually to
     mkApp (mkIdent "succ") (mkConst 1)
  One may say that we `push the brackets inside'.  We replace brackets
  with calls to functions that will construct, at run-time, a
  Parsetree, which is the representation of values of the code type.

  Generally, the Parsetree is constructed when the program is run.
  In some cases we can construct the Parsetree at compile time,
  that is, when this trx.ml is run. Constants like <1> is such a case.
  If we see <1>, or, in terms of trees,
      Texp_bracket (Texp_constant (Constant_int 1))
  we can immediately construct the Parsetree:
      Pexp_constant (Constant_int 1)
  After we construct the Parsetree at compile time, we use CSP to
  pass it over to run-time. At run-time, we merely use the compiled constant.
  This mechanism of building Parsetree at compile-time whenever possible
  is one of the large differences from the previous versions of MetaOCaml.

  Future-stage Bindings.
  Future-stage bindings are introduced by patterns in let, fun,
  match, try and for forms. Global bindings are always at present-stage.
  Since local modules in brackets are not allowed, all future bindings are
  unqualified (i.e., simple names, without the module path).
  The principal rule of translating binding forms is
     <fun x -> e> ---> let x = gensym "x" in mkLAM x <e>
  Emphatically, gensym cannot be run at compile time!
  Reason: consider the recursive invocation:
     let rec f z = <fun y -> ~( ... f 1 ... )>

  Thus, at run-time, we generate new names for bound variables and
  use the OCaml's evaluator (the `run-time') to substitute these
  new names in <e>. Therefore, a future-stage bound variable after
  the translation becomes a present-stage bound variable,
  but at a different type: string loc. We use string loc rather
  than Longident.t loc since all, at present, future-stage bindings
  are simple names.

  We now check for scope extrusion: we enforce the region discipline
  for generated identifiers. To make it easier to impose checks,
  the translation rule is modified as follows
     <fun x -> e> ---> build_simple_fun "x" (fun x -> <e>)
  One can say that <fun x -> e> of the type (a->b) code is translated
  into (fun x -> <e>) of the type a code -> b code. This looks quite
  like the HOAS syntax for lambda (see the code-generation approach
  with code combinators. The function build_simple_fun generates a gensym
  and establishes a region for the gensym variable.

  OCaml has more complicated functions, <function pattern -> body> with
  complex patterns. If the patterns contain no binding variables,
  there is no need to go into the gensym generation. The translation is
  no more complex than that of <lazy e>. 
  For more complicated binding patterns, we generalize, for example
     <fun (x1,true,x2) as x3 -> e1 | _ -> e2> ---> 
       build_fun ["x1";"x2"] (fun (x1,x2,x3) -> [<e1>;<e2>])
  That is, we pick all binding variables from the pattern and build a
  function that receives the code for these variables and produces the
  array of code for all alternatives.

  Here are the main patterns of scope extrusion
  let r = <0> in 
  <fun x -> ~(r := <x + 1>; <()>)>

  let r = <0> in
  <fun x -> .~(<fun x -> ~(let v = <x> in r := <fun x -> ~v>; <()>)>; !r)>

  exception E of int code
  try <fun x -> ~(raise (E <x>)> with E x -> x
  (actually we need a local polymorphic exception, but the idea is the same)

  and similar using control effects.

  The most obvious method of detecting the scope extrusion is traversing
  the generated code looking for unbound identifiers. We can do
  such a check when we are about to show or run the code, or
  about to splice (in the latter case, we have to maintain
  the dynamic environment of gensym'ed names generated by 
  build_fun_). However, reporting the scope
  extrusion upon printing or running the code is reporting it too
  late. Doing the check on each escape (since only splices can incorporate
  scope-extruded code) means many repeated traversals of the generated
  code.

  We use a different method: we mark each piece of the generated code
  with the list of free variable the code contains. Each variable
  is associated with a `stackmark', which identifiers the region
  with which the variable is associated. All valid stackmarks form
  a total order. Alas, delimited control can reshuffle that order.
  The function build_simple_fun and others enter a new region
  and then check that the generated body contains only valid stackmarks
  (that is, stackmarks that correspond to active regions). 
  Every code building function ( build_* ) checks to see that the stackmarks
  in the incorporated fragments are all valid, that is,
  correspond currently alive variables. These code building function
  merge the free variable lists (heaps actually) from the incorporated
  fragments.

This file was based on trx.ml from the original MetaOCaml, but it is
completely re-written from scratch and has many comments. The
traversal algorithm, the way of compiling Parsetree builders, dealing
    with CSP and many other algorithms are all different.

Special sorts of brackets

MetaOCaml brackets .<e>. (as well as escapes .~e and CSP expressions)
are internally represented as ordinary OCaml expressions annotated
with the attributes metaocaml.bracket (corr. metaocaml.escape). That is,
.<e>. is just the syntactic sugar for e [@metaocaml.bracket].
An expreession may have several MetaOCaml attributes, corresponding to
nested brackets and escapes.

Besides metaocaml.bracket, there are two other bracket-related
attributes. They are meant to be attached to a bracket expression; it
is an error to use them otherwise. The attributes, together with the
bracket expression they are attached to, may be regarded as a special
sort of bracket. Currently we provide no syntax sugar for these
`special' brackets (to be less disruptive of the baseline OCaml
syntax). Only one of the following bracket-modifying attributes may be
attached to a bracket.

The first bracket-modifying attribute is metaocaml.functionliteral.
It is an assertion that the bracketed expression is actually a literal
function, like .<function p1 -> e1 | ... pn -> en>. or .<fun p -> e>.
Such function literals act as first-class patterns.  The type-checker
checks that the bracketed expression is really the function literal,
and if so, gives it a more refined type: pat_code.  See make_match for
more detail.

The other bracket-modifying attribute is metaocaml.value.
It is also an assertion that a bracketed expression actually
represents a value: a constant, variable reference, constant tuple, etc.
If this is indeed the case, the typechecker gives the bracketed 
expression a more refined type: val_code. Otherwise, an error is reported.
For more detail, see the section on let-insertion below.


Let-insertion

Since we are already tracking free variables, we may just as well implement
let-insertion, the primitive genlet.

First, we introduce the type 'a val_code, which is a sort of `subtype'
of 'a code. It represents a code expression that is syntactically a value
(such as an identifier reference, a constant, a lambda-expression).
Code values of 'a val_code type can be freely spliced as many times as
needed without worrying about duplicating effects or evaluation order.
We now can write code-generator-functions that take arguments of 'a val_code
type, which behave as call-by-value functions when the staging annotations are
erased. One can always convert val_code to code, using
      code_of_val_code : 'a val_code -> 'a code

One way of producing 'a val_code values is using brackets with
metaocaml.value attribute, as in

     fun x -> .<(1,function y -> y + .~x)>. [@metaocaml.value]
  (whose inferred type is: int code -> (int * (int -> int)) val_code)

If the annotated bracketed expression is not actually a value, syntactically,
a type error is rased. Another way of producing 'a val_code is by
   letlv   : ?name:string -> 'a code -> (('a val_code -> 'w code) -> 'w code)
   genletv : 'a code -> 'a val_code

This function first checks that its argument is already a (future-stage)
value [see note below] 
If so, it is returned as it is, but of the 'a val_code type.
If the argument is not syntactically a value, genlet generates 
the let-statement, binding the argument to a fresh future-stage
variable and returning the code that refers to that variable. 
Variable references are clearly values.
That is, genlet exp inserts let freshname = exp in ... somewhere
in the generated code and returns .<freshname>.
The `let' is inserted right under the binder for the `latest' free variable
contained in `exp'.
Previously genlet performed no let-insertion if the argument is a code
of a value -- any value. However, not all values are equal: literal
integers like 1 are cheap to duplicate. However, values like
lambda-expressions are actually effectful since they create a closure.
Duplicating them is expensive. If the user used genlet, such values should
really be shared. The function is_too_cheap_to_let_bind decides that.

Let-insertion is an instance of delimited control. Rather than using
delimcc or other such library, we implement a sort of a buble-up
semantics.  We have already annotated generated code with the list
(heap) of free variables cointained therein. We add another
annotation: the set (list) of (varname_i,exp_i) pairs describing (to
be) let-bound variables and the expressions they are to be bound. Each
binder (build_fun_simple, etc) will check if one of exp_i contains the
free variable bound by the binder. If so, the let-statement will be
generated. Each (varname_i,exp_i) pair is independent so the order in
the list is immaterial.

Thus the (potentially open) code is represented as a triple
  heap * [(var_i, exp_i)...] * exp
Here heap is the list (heap, actually) of free variables of the overall
expression, that is, of exp as well as of all exp_i.

The last two components can be thought of as a virtual `let' statement
    let var_1 = exp_1 and ... var_i = exp_i in exp
The exp may have free occurrences of var_i, which are however bound
by the virtual let and therefore are not counted as free variables of
the overall expression and are not reflected in heap.

Keep in mind however that exp_i may itself contain the list of
(varname_j,exp_j). Such a situation arises from nested genlet. For example,
genlet <x+1> (where x is some variable in scope) corresponds to
     (heap ["x"], [("var1",(heap ["x"],[],<x+1>))], <var1>)
then
   <z + ~(genlet <y + ~(genlet <x+1>)>)>
corresponds to
     (heap ["x","y","z"],
       [("var2", (heap ["x","y"], 
                  [("var1",(heap ["x"],[],<x+1>))], <y+var1>))],
       <z + var2>)
When the variable y is going to be bound off, var2 binding must be actualized:
     (heap ["x","y","z"],
       [("var1",(heap ["x"],[],<x+1>))],
       <let var2 = y + var1 in z + var2>)
but "var1" may float.

When "x" is retracted, we first actualize var2, and then var1. The dependency
comes out automatically; we actualize var2 because its heap contains "x"
as well; the heap of the code value contains the free variables mentioned
within its virtual bindings as well. So, actualizing the bindings outside-in
is not only natural: it is exactly the right strategy.

Since the same code value may be spliced in multiple times, it could be that
the list of virtual bindings has duplicates. for example:
    let x = genlet <1+2> in
    x + x
    let x = genlet <1+2> in
    x + genlet (x+1)

If the let-bound name is duplicated, then the corresponding expression is
an exact replica. So, it is OK to keep only one copy...

There are times where we want to limit the scope of let-insertion. For example,
consider
        <fun x -> ... ~(let sum = genlet <ref 0> in <~sum := !~sum + x>)>
Since (ref 0) does not have any free variables, its let-insertion happens at the
very top, outside the function. All invocations of the functions will share
(and accumulate to) the same sum, which may be undesirable. We thus introduce
      with_locus : (locus -> 'w code) -> 'w code
and make genlet take the locus as an argument. To limit the let-insertion of
ref 0 within the function, we would write
        <fun x -> 
          ~(with_locus @@ fun locus -> 
            <... ~(let sum = genlet locus <ref 0> in <~sum := !~sum + x>)>)>
The idea of scope restriction is to introduce a dummy free variable, which
and made it to be `virtually' present within the genlet expression. That is,
with_locus k is essentially
  let locus = dummy_expression in k (<locus>)
and genlet adds locus as a free variable in the heap correspondng to the
expression to bind (as if that variable has indeed occurred within the 
expression). That is all what is needed: the existing machinery tracking the
scope of virtual bindngs and materializing them does all the job. The
implementation thus is very simple, because we already built the infrastructure.

Inserting (mutually) recursive lets is described in PEPM 2019 and related
papers. Unlike the ordinary
    .<let rec f1 x1 = e1 and f2 x2 = e2 ... in e>.
in letrec-insertion, the bindings (variable names and the corresponding 
expressions) are not known beforehand but rather computed during code
generation. Thus we need a facility to generate arbitrary variable names,
and then bind them. Most of the existing infrastructure applies: the key 
observation is that arbitrary generated names for let-rec bound expressions
all share the same scope (all pertain to the same binding location, the location
of the to-be-generated let rec expression). Thus letrec-insertion is processed
quite similarly to the ordinary let rec bracketed expression (entering a new
binding region, etc).

*)

open Parsetree
open Asttypes
open Typedtree
open Types
module Const = Ast_helper.Const

(*{{{ Preliminaries, common functions *)

(* BER MetaOCaml version string *)
let meta_version  = "N 111"

(* Co-opt the Preprocessor class of warnings *)
let debug_print ?(loc = Location.none) : string -> unit = fun msg ->
  Location.prerr_warning loc (Warnings.Preprocessor msg)

(* Emit a translation-time error *)
exception Error of Location.error

let trx_error loc_err = raise @@ Error loc_err

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some err
      | _         -> None
    )

let not_supported loc msg =
  trx_error @@ Location.errorf ~loc
      "%s is not yet supported within brackets" msg

(* left-to-right accumulating map *)
let rec map_accum : ('accum -> 'a -> 'b * 'accum) -> 'accum -> 'a list ->
  'b list * 'accum = fun f acc -> function
    | []   -> ([],acc)
    | h::t -> 
        let (h,acc) = f acc h in
        let (t,acc) = map_accum f acc t in
        (h::t, acc)

let initial_env = Env.initial_safe_string


(* Attributes *)
(* In a Parsetree, brackets, escape and CSPs are attributes on 
   the corresponding nodes. 
*)

let rec get_attr : string -> attributes -> Parsetree.structure option =
  fun name -> function
    | [] -> None
    | {attr_name= {txt=n}; attr_payload= PStr str} :: _ when n = name -> 
        Some str
    | _ :: t -> get_attr name t


let attr_csp : Longident.t loc -> attribute = fun lid ->
  let open Ast_helper in
  Attr.mk ~loc:Location.none (Location.mknoloc "metaocaml.csp") 
    (PStr [Str.eval (Exp.ident lid)])

(* If the attribute is present, the expression is non-expansive 
   We use physical equality comparison, to speed things up
*)
let attr_nonexpansive : attribute = 
  Ast_helper.Attr.mk ~loc:Location.none 
    (Location.mknoloc "metaocaml.nonexpansive") (PStr [])


(* The result of what_stage_attr *)
type stage_attr_elim = 
  | Stage0
  | Bracket of attributes * (* bracket attribute *)
               attributes   (* other attributes  *)
  | FunBracket 
            of attributes * (* Literal function bracket attribute *)
               attributes   (* other attributes  *)
  | ValBracket 
            of attributes * (* Value bracket attribute *)
               attributes   (* other attributes  *)
  | Escape  of attribute * (* escape attribute *)
               attributes  (* other attributes  *)
  | CSP     of attribute * Longident.t loc * (* CSP attribute and lid *)
               attributes  (* other attributes  *)

(* Determining if an AST node bears a staging attribute *)
(* FunBracket is the metaocaml.bracket followed by metaocaml.functionliteral
   And similar for metaocaml.value *)
let what_stage_attr : attributes -> stage_attr_elim =
  let rec loop acc = function
    | [] -> Stage0
    | {attr_name= {txt="metaocaml.functionliteral"} as l} :: _
    | {attr_name= {txt="metaocaml.value"} as l} :: _ -> 
        trx_error @@ Location.errorf ~loc:l.loc 
         "attribute %s is misplaced. It must follow the closing bracket"
         l.txt
    | ({attr_name= {txt="metaocaml.bracket"}} as ab) :: t -> 
        (* Now check if any modifier attribute is to follow *)
        let rec get_specials specials acc = function 
          | ([] as rest)
          | (({attr_name= {txt="metaocaml.bracket"}} :: _) as rest)
          | (({attr_name= {txt="metaocaml.escape"}}  :: _) as rest) -> 
              (specials,List.rev_append acc rest)
          | ({attr_name= {txt="metaocaml.functionliteral"}} as a) :: t -> 
            get_specials (a::specials) acc t
          | ({attr_name= {txt="metaocaml.value"}} as a) :: t -> 
            get_specials (a::specials) acc t
          | a :: t -> get_specials specials (a::acc) t
        in
        let (specials, rest) = get_specials [] acc t in
        begin
          match specials with
          | [] -> Bracket ([ab],rest)  (* no special attributes *)
          | [{attr_name= {txt="metaocaml.functionliteral"}}] ->
              FunBracket (ab::specials,rest)
          | [{attr_name= {txt="metaocaml.value"}}] ->
              ValBracket (ab::specials,rest)
          | _ -> 
              trx_error @@ Location.errorf ~loc:ab.attr_loc 
                  "bracket is followed by inconsistent metaocaml attributes"
        end
    | ({attr_name= {txt="metaocaml.escape"}} as a) :: t -> 
        Escape (a,List.rev_append acc t)
    | ({attr_name= {txt="metaocaml.csp"}; attr_payload=PStr [{pstr_desc = 
            Pstr_eval ({pexp_desc=Pexp_ident lid},_)}]} as a) :: t -> 
        CSP (a,lid,List.rev_append acc t)
    | a :: t -> loop (a::acc) t
  in loop []

(* Staging level 
   It is set via an attribute on the value_description in the Typedtree 
*)
type stage = int                        (* staging level *)

let attr_level n = 
  let open Ast_helper in
  Attr.mk ~loc:Location.none 
  (Location.mknoloc "metaocaml.level")
  (PStr [Str.eval (Exp.constant (Const.int n))])

let get_level : Parsetree.attributes -> stage = fun attrs ->
  match get_attr "metaocaml.level" attrs with
  | None -> 0
  | Some [{pstr_desc = 
        Pstr_eval ({pexp_desc=Pexp_constant (Pconst_integer (ns,None))},_)}] ->
     let n = int_of_string ns in
     assert (n>=0); n
  | _ -> assert false  (* Invalid level attribute *)

(*}}}*)


(*{{{ Path and location utilities *)

(* ------------------------------------------------------------------------ *)
(* Path utilities *)

(* We always use path when available, and convert it to Longident
   when needed -- even if the Typedtree already carries the longident.
   The path is preferred because it is fully qualified for
   external identifiers and it is unambiguous.
   If we open a module, its components can be referred to without
   qualification -- the path will be qualified nevertheless.
   When we build a Parsetree representing the generated code,
   we have to use fully qualified identifiers since the open statement
   in the original code won't be represented in the generated
   Parsetree.
*)

(* Check to see if a path refers to an identifier, exception, or
   constructor that is available from an external module. If so, the run-time
   compiler invoked by run can get the definition for the identifier from
   a .cmi file. The value of an external identifier can be obtained from
   a .cmo file.
   If a path contains several components like
   M1.M2.M3.ident, we should check if the top-most component, that is, M1,
   is external.
*)
(* XXX call Env.normalize_path first? *)

let rec is_external = function
  | Path.Pident id ->           (* not qualified *)
      Ident.global id
  | Path.Papply _   -> false
  | Path.Pdot(p, _) -> is_external p

(* Convert a path to an identifier. Since the path is assumed to be
   `global', time stamps don't matter and we can use just strings.
*)
let rec path_to_lid : Path.t -> Longident.t = function
  | Path.Pident i       -> Longident.Lident (Ident.name i)
  | Path.Pdot (p,s)     -> Longident.Ldot (path_to_lid p, s)
  | Path.Papply (p1,p2) ->
      Longident.Lapply(path_to_lid p1, path_to_lid p2)

(* Convert the path to lid but use the given str as the last component.
   This in effect qualifies 'str' with the given module path
*)
let path_to_lid_but_last : Path.t -> string -> Longident.t =
  fun p str ->
    match p with
    | Path.Pident _   -> Longident.Lident str
    | Path.Pdot (p,_) -> path_to_lid (Path.Pdot (p,str))
    | _ -> assert false

(* Replace the last component of p1 with p2, which should be a Pident
   path 
*)
(*
let path_replace_last : Path.t -> Path.t -> Path.t = fun p1 p2 ->
 match (p1,p2) with
  | (Path.Pident _,x) -> x
  | (Path.Pdot(p1,_),Path.Pident id) -> Path.Pdot(p1,Ident.name id)
  | _ -> assert false
*)

(* Check to make sure a constructor, label, exception, etc.
   have the name that we can put into AST (Parsetree).
   Local names can't be put into the Parsetree since the type env in which
   they are declared is not represented in the Parsetree.
*)
let check_path_quotable msg path =
  if not (is_external path) then
    trx_error @@ Location.errorf
        "%s %s cannot be used within brackets. Put into a separate file."
        msg (Path.name path)


(* Check to see that a constructor belongs to a type defined
   in a persistent module or in the initial environment.
   Return the fully qualified name to put into AST 
   (Stdlib constructors remain unqualified however).

   We have nothing to do if the constructor is already fully qualified
   with a persistent module identifier: for example, Scanf.Scan_failure.
   The major complexity comes from this scenario:
      open Scanf
      .<raise (Scan_failure "xx")>.
   The Texp_construct node of Typedtree contains the lid and (was: the
   path) that refer to "Scan_failure" without any module qualifications.
   We have to find the fully qualified path and check
   that it is external. We do that by finding the path for the _type_
   constructor, for the type of which the data constructor is a member.
   That type_path is fully qualified. We can ascertain the later fact
   from Env.constructors_of_type, which puts the complete path
   into the type of the constructor, which is always of the form
   Tconstr(ty_path,_,_). The function constructors_of_type is used
   within Env.store_type, which is used when opening a module.

   Alternatively we could've used Env.lookup_constructor, which also
   returns the qualified path? Searching the environment is costly
   though.
   Actually, using Env.lookup_constructor is a bad idea. Now labels and
   constructors don't have to be unique. The type checker goes to
   a great length to disambiguate a constructor or a label. It records
   the eventually determined type of the label/constructor in
   label_description or constructor_description.
   So, we should only use information from these descriptions.

   Alas, the predefined types (with no module qualification) are
   not specially distinguished (XXX Is this still the case?). 
   So, we have to check the initial environment.

 *)
let qualify_ctor : 
    Longident.t loc -> constructor_description -> Longident.t loc = 
 fun lid cdesc ->
  let loc = lid.loc in
  match (cdesc.cstr_tag, Ctype.repr cdesc.cstr_res) with
  | (Cstr_extension (p,_),_) ->
      if is_external p then Location.mkloc (path_to_lid p) loc else
       trx_error @@ Location.errorf ~loc
       "Exception (extension) %s cannot be used within brackets. Put into a separate file."
        (Path.name p)
  | (_,{desc = Tconstr((Path.Pident _ as ty_path), _, _)}) ->
     begin
      try ignore (Env.find_type ty_path initial_env); lid
      with Not_found ->
        trx_error @@ Location.errorf ~loc
        "Unqualified constructor %s cannot be used within brackets. Put into a separate file."
          cdesc.cstr_name
     end
  | (_,{desc = Tconstr(ty_path, _, _)}) ->
      if is_external ty_path then
        Location.mkloc (path_to_lid_but_last ty_path cdesc.cstr_name) loc
      else
      trx_error @@ Location.errorf ~loc
      "Constructor %s cannot be used within brackets. Put into a separate file."
          cdesc.cstr_name
  | _ -> Printtyp.type_expr Format.err_formatter cdesc.cstr_res;
           failwith ("qualify_ctor: cannot determine type_ctor from data_ctor "^
                     cdesc.cstr_name)

(* Check to see that a record label belongs to a record defined
   in a persistent module or in the initial environment.
   This is a label version of qualify_ctor
*)
let qualify_label : Longident.t loc -> label_description -> Longident.t loc =
 fun lid ldesc ->
  let loc = lid.loc in
  match Ctype.repr ldesc.lbl_res with
  | {desc = Tconstr((Path.Pident _ as ty_path), _, _)} ->
    begin
      try ignore (Env.find_type ty_path initial_env); lid
      with Not_found ->
        trx_error @@ Location.errorf ~loc
        "Unqualified label %s cannot be used within brackets. Put into a separate file."
          ldesc.lbl_name
    end
  | {desc = Tconstr(ty_path, _, _)} ->
      if is_external ty_path then
        Location.mkloc 
          (path_to_lid_but_last ty_path ldesc.lbl_name) loc
      else
        trx_error @@ Location.errorf ~loc
          "Label %s cannot be used within brackets. Put into a separate file."
          ldesc.lbl_name
  | _ -> Printtyp.type_expr Format.err_formatter ldesc.lbl_res;
           failwith ("qualify_label: cannot determine type from label "^
                     ldesc.lbl_name)

(* Test if we should refer to a CSP value by name rather than by
   value
*)
(* Module identifiers for the modules that are expected to be
   present at run-time -- that is, will be available for
   dynamic linking of the run-time generated code.

TODO: check bytecomp/transclass.ml:const_path
Perhaps that's a hint which unqualified identifiers will be persistent
*)

let ident_can_be_quoted = is_external

(*}}}*)


(*{{{ Templates for building Parsetree/Typedtree components *)

(* Local reference: trx.cmi is always in the library path 
   but location.cmi is not necessarily is in the current path.
*)
let loc_none = Location.none

let label_none = Asttypes.Nolabel

let dummy_lid : string -> Longident.t loc = fun name ->
  Location.mknoloc (Longident.Lident name)

(* Exported. Used as a template for constructing lid expressions *)
let sample_lid = dummy_lid "*sample*"

(* Exported. Used as a template for constructing name expression *)
let sample_name : string loc = mknoloc "*sample*"

(* Exported. Used as a template for constructing brackets and escapes *)
let sample_attributes  : Parsetree.attributes = []

(* Exported. Used as a template for constructing pattern lists expressions *)
let sample_pat_list : Parsetree.pattern list = []
let sample_pats_names : Parsetree.pattern list * string loc list = ([],[])

(* Exported. Used as a template for constructing records *)
let sample_record_repr : Types.record_representation = Record_regular

(*}}}*)


(* ------------------------------------------------------------------------ *)
(* Building Texp nodes *)

(* The types of code, pat_code and val_code, which are defined in trx.mli 
   The code type used to be Predef.
*)
let typecode_path =
  let path =
    Path.(Pdot (Pident (Ident.create_persistent "Trx"), "code")) in
     (* check to make sure pat_code is really the type 'a code
        that we declared in Trx.mli
      *)
  lazy (match Env.find_type path initial_env with
  | {type_params = [_]} -> path
  | _                   -> assert false)

let mk_type_code : type_expr -> type_expr =
  fun ty -> Btype.newgenty (Tconstr(Lazy.force typecode_path, [ty], ref Mnil))


let typepat_code_path =
  let path =
    Path.(Pdot (Pident (Ident.create_persistent "Trx"), "pat_code")) in
     (* check to make sure pat_code is really the type 'a pat_code
        that we declared in Trx.mli
      *)
  lazy (match Env.find_type path initial_env with
  | {type_params = [_]} -> path
  | _                   -> assert false)

let mk_type_pat_code : type_expr -> type_expr =
  fun ty -> 
    Btype.newgenty (Tconstr(Lazy.force typepat_code_path, [ty], ref Mnil))

let typeval_code_path =
  let path =
    Path.(Pdot (Pident (Ident.create_persistent "Trx"), "val_code")) in
     (* check to make sure pat_code is really the type 'a val_code
        that we declared in Trx.mli
      *)
  lazy (match Env.find_type path initial_env with
  | {type_params = [_]} -> path
  | _                   -> assert false)

let mk_type_val_code : type_expr -> type_expr =
  fun ty -> 
    Btype.newgenty (Tconstr(Lazy.force typeval_code_path, [ty], ref Mnil))



(* initial_env is used for all look-ups. Unqualified identifiers
   must be found there. For qualified identifiers, Env.lookup
   functions look things up in the persistent structures, loading them
   up as needed.
*)

let mk_texp : ?env:Env.t -> ?attrs:Parsetree.attributes ->
              ?loc:Location.t ->
              Typedtree.expression_desc -> type_expr -> 
  Typedtree.expression =
  fun ?(env=initial_env) ?(attrs=[]) ?(loc=Location.none) desc ty ->
  { exp_desc = desc; exp_type = ty;
    exp_loc  = loc; exp_extra = [];
    exp_attributes = attrs;
    exp_env  = env }

let texp_int : int -> Typedtree.expression = fun n ->
  mk_texp (Texp_constant (Const_int n)) (Ctype.instance Predef.type_int)

(* Make a bracket or an escape node
   Here, the attr argument is a bracket/escape attribute
*)
(* In a Typedtree, <e> is represented as a sequence
        begin 0; e end
   again, with the corresponding attribute.
   I chose 0 rather than () because if we forget to handle
   bracket/escape properly, we get a warning. Still, begin 0; e end
   is syntactically and type-correct .
   Ditto for Escape.
*)
let texp_zero = (* TExp node for constant 0 *)
  texp_int 0

let texp_braesc : 
  attributes -> Typedtree.expression -> Env.t -> type_expr -> 
  Typedtree.expression =
  fun attrs exp env ty ->
    mk_texp ~env ~attrs:(attrs @ exp.exp_attributes)
            ~loc:exp.exp_loc (Texp_sequence (texp_zero, exp)) ty


(* A CSP is in essence a constant. So, we represent CSP as a constant,
   with an annotation that contains the name of the identifier
 *)

let texp_csp_raw : 
  attribute -> Asttypes.constant -> Env.t -> type_expr -> Typedtree.expression =
  fun attr cnt env ty ->
    {
     exp_desc = Texp_constant cnt;
     exp_loc = Location.none; exp_extra = [];
     exp_type = ty;
     exp_attributes = [attr];
     exp_env = env }


(* TODO: add memoization? *)

(* Compiling an identifier with a given (qualified) name *)
let texp_ident : string -> expression = fun name ->
  let lid = 
    Parse.longident Lexing.(from_string ~with_positions:false name) in
  let (p, vd) = try Env.find_value_by_name lid initial_env 
                with Not_found -> 
                  Misc.fatal_error ("Trx.find_value: " ^ name) in
  mk_texp (Texp_ident (p,mknoloc lid, vd))
          (Ctype.instance vd.val_type)


(* Building an application *)
let texp_apply : Typedtree.expression -> Typedtree.expression list -> 
 Typedtree.expression_desc = fun f args ->
   Texp_apply(f, List.map (fun arg -> (Nolabel,Some arg)) args)

(* Compiling a string constant *)
(* The second argument of Const_string is the delimiter,
   the decorator in the {decorator| ... |decorator} notation.
*)
let texp_string : string -> Typedtree.expression = fun str ->
  mk_texp (Texp_constant (Const_string (str,Location.none,None)))
          (Ctype.instance Predef.type_string)


(* Compiling a boolean *)
(* For prototype, see Typecore.option_none *)
let texp_bool : bool -> Typedtree.expression = fun b ->
  let lid = Longident.Lident (if b then "true" else "false") in
  let cdec = Env.find_ident_constructor 
                 (if b then Predef.ident_true else Predef.ident_false) 
                 initial_env in
  mk_texp (Texp_construct(mknoloc lid, cdec, []))
          (Ctype.instance Predef.type_bool)

(* Given a value v, create a Typedtree node for an expression
   that will evaluate to v.
   This the the CSP used by the MetaOCaml itself.
   Since this is an internal CSP, we don't put any attributes.
*)
let texp_csp : Obj.t -> Typedtree.expression = fun v ->
  if Obj.is_int v then texp_int (Obj.obj v)
   (* We treat strings and bytes identically *)
  else if Obj.tag v = Obj.string_tag then texp_string (Obj.obj v)
  else 
    let vstr = Marshal.to_string v [] in
    let () = if false then debug_print ("texp_csp, marshall: size " ^ 
                string_of_int (String.length vstr)) in
    mk_texp
        (texp_apply (texp_ident "Stdlib__marshal.from_string")
         [texp_string vstr; texp_zero])
        (Btype.newgenvar ())


(* Compiling location data *)
(* We could have made texp_loc an alias to texp_csp... We keep the
   type information for location though, just to be fully correct.
*)
let texp_loc : Location.t -> Typedtree.expression = fun loc ->
  let loc_exp = texp_ident "Trx.loc_none" in (* this fills in the type, etc.*)
  if loc = Location.none then loc_exp else
  {loc_exp with exp_desc = (texp_csp (Obj.repr loc)).exp_desc}

(* Compiling an arg_label value *)
let texp_label : arg_label -> Typedtree.expression = fun lab ->
  let lab_exp = texp_ident "Trx.label_none" in (* this fills in the type, etc.*)
  if lab = Nolabel then lab_exp else
  {lab_exp with exp_desc = (texp_csp (Obj.repr lab)).exp_desc}

(* Compiling longident with location data *)
let texp_lid : Longident.t loc -> Typedtree.expression = fun lid ->
  let lid_exp = texp_ident "Trx.sample_lid" in (* this fills in the type, etc.*)
  {lid_exp with exp_desc = (texp_csp (Obj.repr lid)).exp_desc}

(* Compiling record-representation *)
(*
let texp_record_repr : Types.record_representation -> Typedtree.expression = 
 fun recr ->
  let recr_exp = texp_ident "Trx.sample_record_repr" in 
                (* this fills in the type, etc.*)
  {recr_exp with exp_desc = (texp_csp (Obj.repr recr)).exp_desc}
*)

(* Compiling a string with a location *)
let texp_string_loc : string loc -> Typedtree.expression = fun name ->
  let name_exp = texp_ident "Trx.sample_name" in
  {name_exp with
   exp_desc = (texp_csp (Obj.repr name)).exp_desc}

(* Compiling a list of attributes *)
let texp_attributes : attributes -> Typedtree.expression = fun attrs ->
  let attrs_exp = texp_ident "Trx.sample_attributes" in
  {attrs_exp with
   exp_desc = (texp_csp (Obj.repr attrs)).exp_desc}

(* Compiling an option *)
(* For prototype, see Typecore.option_none *)
let texp_option : Typedtree.expression option -> Typedtree.expression = 
  function
    | None -> 
        let lid = Longident.Lident "None" in
        let cnone = Env.find_ident_constructor Predef.ident_none initial_env in
        mk_texp (Texp_construct(mknoloc lid, cnone, []))
                (Ctype.instance (Predef.type_option (Btype.newgenvar ())))
    | Some e ->
        let lid = Longident.Lident "Some" in
        let csome = Env.find_ident_constructor Predef.ident_some initial_env in
        mk_texp (Texp_construct(mknoloc lid, csome, [e]))
                (Ctype.instance (Predef.type_option e.exp_type)) 
                ~env:e.exp_env

(* Compiling a tuple *)
let texp_tuple : Typedtree.expression list -> Typedtree.expression = fun el ->
  mk_texp (Texp_tuple el)
          (Ctype.newty (Ttuple (List.map (fun e -> e.exp_type) el)))

(* Compiling an array *)
(* We use this function for grouping trx_bracket-transformed expressions,
   which have the same representation type (but may be different
   code type). We ignore the differences in the code type, since
   the representation type is the same.

   We don't use lists since they are harder to compile, and more
   fragile. Texp_construct has more arguments, we have to locate
   constructor information, etc.
*)
let texp_array : Typedtree.expression list -> Typedtree.expression = function
  | [] -> 
      mk_texp (Texp_array []) 
	      (Ctype.instance (Predef.type_array (Btype.newgenvar ())))
  | (h::_) as el ->
      mk_texp (Texp_array el) 
	      (Ctype.instance (Predef.type_array h.exp_type))

(* Compiling patterns and the list of names bound by them *)
let texp_pats_names : Parsetree.pattern list -> string loc list -> 
  Typedtree.expression = fun pats names ->
    let pn_exp = texp_ident "Trx.sample_pats_names" in
    {pn_exp with
     exp_desc = (texp_csp (Obj.repr (pats,names))).exp_desc}

(* Utility function to build the case list *)
let texp_case : 
  ?guard:expression -> 'k general_pattern -> expression -> 'k case =
  fun ?guard pat exp ->
    {c_lhs=pat; c_guard=guard; c_rhs=exp}

(* ------------------------------------------------------------------------ *)
(* Stack marks, a simple form of dynamic binding *)

(* In the earlier version, our stackmarks could be ordered.
   Alas, it is hard to dynamically replace the implementation
   below with the one adjusted for delimcc. The implementation below
   does not work when partial continuations can be captured and reinstated.
   Mainly, when delimited continuations are used, the order is
   not stable. Delimited control operators can reshuffle the order
   arbitrarily. Therefore, the fact that there is order among valid stackmarks
   is not helpful anyway.

module type STACKMARK = sig
  type t
  val is_valid : t -> bool
  (* compare is supposed to be called on stack marks that are
     checked to be valid
   *)
  val compare : t -> t -> int
  val with_stack_mark : (t -> 'w) -> 'w
end

(* Simple implementation with shallow dynamic binding *)
module StackMark : STACKMARK = struct
  type t = int ref

  (* The global counter of the nesting depth of with_stack_mark *)
  let stack_mark_cnt = ref 0

  (* A stack mark is ref n where n is the depth of the corresponding
     with_stack_mark form.
     The stack mark is invalid if the counter is 0
   *)
  let with_stack_mark body =
    incr stack_mark_cnt;
    let mark = ref !stack_mark_cnt in
    let finalize () =
      mark := 0;                         (* invalidate the mark *)
      assert (!stack_mark_cnt > 0);
      decr stack_mark_cnt
    in
    try 
      let r = body mark in finalize (); r
    with e -> finalize (); raise e

  let is_valid mark = !mark > 0
  let compare m1 m2 =
    assert (!m1 >0 && !m2 > 0);
    compare !m1 !m2
end

*)

(* A robust and truly minimalistic implementation of stack-marks.
   A stack-mark is created by 'with_stack_mark' function. Since
   the only operation on a stackmark is to test if it is valid,
   the stackmark is realized as a thunk unit -> bool.
*)
type stackmark = unit -> bool           (* true if valid *)

(* The type of the with_stack_mark operation *)
type stackmark_region_fn = 
    {stackmark_region_fn : 'w. (stackmark -> 'w) -> 'w}

(* The simple implementation of stackmark_region_fn, appropriate
   when no delimited control is used.
   The mark is a ref bool cell, containing true within
   stackmark_region_fn's dynamic region.
*)
let with_stack_mark_simple : stackmark_region_fn = 
  {stackmark_region_fn = fun body ->
    let mark = ref true in
    try
      let r = body (fun () -> !mark) in
      mark := false;                      (* invalidate the mark *)
      r
    with e -> mark := false; raise e
 }

let with_stack_mark : stackmark_region_fn ref = ref with_stack_mark_simple

(* Replace a with_stack_mark implementation, e.g., when delimcc is used *)
let set_with_stack_mark : stackmark_region_fn -> unit =
  fun smf -> with_stack_mark := smf

    
(* ------------------------------------------------------------------------ *)
(* Simple heap *)
(* A mapping of keys to values. Priority is used for the sake of
   efficient operations. Also, values with the same priority are
   considered equivalent (belong to the same binding region)
   and are collapsed, lazily. 

   The invariant: for each non-leaf
   node, the priority of the node is strictly greater than the priorities 
   of any of the child nodes. The order of priorities between 
   the children can be arbitrary.
*)
type prio = int
type 'v heap = Nil | HNode of prio * stackmark * 'v * 'v heap * 'v heap
let empty_heap = Nil

let rec merge_heap : 'v heap -> 'v heap -> 'v heap = fun h1 h2 ->
  match (h1,h2) with
  | (Nil,h) | (h,Nil)-> h
  | (HNode (p1,k1,v1,l1,r1), HNode (p2,k2,v2,l2,r2)) ->
      begin
        match p1 - p2 with
        | 0 -> 
            HNode (p1,k1,v1, merge_heap l1 l2, merge_heap r1 r2) (* same keys *)
        | n when n < 0 -> HNode (p2,k2,v2, merge_heap h1 l2, r2)
        | _ -> HNode (p1,k1,v1,l1,merge_heap h2 r1)
      end

(* Remove the node with a given priority *)
let rec remove : prio -> 'v heap -> 'v heap = fun p -> function
  | Nil -> Nil
  | HNode (pn,k,v,h1,h2) as h -> 
      begin
        match p - pn with
        | 0 -> merge_heap h1 h2         (* p cannot occur in h1 or h2 *)
        | n when n > 0 -> h             (* entire tree has the lower prio *)
        | _ -> HNode (pn,k,v, remove p h1, remove p h2)
      end

(* Quickly check to see if the heap has a node with the given priority.
   We rely on the heap invariant to avoid the full heap traversal
 *)
let rec member_heap : prio -> 'v heap -> bool = fun p -> function
  | Nil -> false
  | HNode (pn,_,_,h1,h2) -> 
      begin
        match p - pn with
        | 0            -> true
        | n when n > 0 -> false             (* entire tree has the lower prio *)
        | _ -> member_heap p h1 || member_heap p h2
      end

(* Check to see if the heap has a value that satisfies a given predicate *)
let rec any_heap : ('v -> bool) -> 'v heap -> bool = fun pred -> function
  | Nil -> false
  | HNode (_,_,v,l,r) -> pred v || any_heap pred l || any_heap pred r


(* The representation of the possibly open code: AST plus annotations
   plus the set of free identifiers, annotated with the marks
   of the corresponding with_binding_region forms
*)
type code_repr = 
  Code of flvars * Parsetree.expression
and flvars =                 (* virtually let-bound and free vars *)
  string loc heap * vletbindings
and
  vletbindings = (string * code_repr) list

type +'a code = private code_repr


let empty : flvars = (empty_heap, [])

let merge : flvars -> flvars -> flvars = fun (h1,vl1) (h2,vl2) ->
  (merge_heap h1 h2, vl1 @ vl2)

(* Actualize all virtual let-bindings. Except for the let-bound variables
   (which are not reflected in the heap), there should be no other free
   variables. This function is called upon conversion to closed code.
   Bindings may be duplicated! To detect the duplication, phisical equality
   is ok.
   However, simply eliminating the duplication is complicated: condider
   let x = 1+2 in let y = 1 + x in let x = 1 + 2 in ...
   We have to eliminate the last duplication but not the first.
   So, we first compute the list of bindings, from outer to inner,
   elimitate inner, and then perform the let-bindings
 *)
let vlet_bind_all : 
  vletbindings -> Parsetree.expression -> Parsetree.expression =
  let bind exp (vi,expi) =             (* do the let-bindings *)
    let open Ast_helper in
    Exp.let_ Nonrecursive [Vb.mk (Pat.var (mknoloc vi)) expi] exp
  in
  let rec compute_bind (vi,codi) bs =  (* from outer to inner *)
    if List.mem_assq vi bs then bs else
    (* bind from outside in *)
    match codi with
    | Code((Nil,vls'),expi) -> 
        (vi,expi) :: List.fold_right compute_bind vls' bs
    | _  -> assert false                (* heap is supposed to be empty *)
  in fun vl exp -> 
  List.fold_left bind exp @@
  List.fold_right compute_bind vl []    (* The innermost is at the top *)


(* The closed code is AST *)
type closed_code_repr = Parsetree.expression

(* Check that the code is closed and return the closed code *)

(* The same as close_code but return the closedness check as a thunk
   rather than performing it.
   This is useful for debugging and for showing the code
*)

let close_code_delay_check : code_repr -> closed_code_repr * (unit -> unit) =
 function
  | Code ((Nil,vls),ast) -> (vlet_bind_all vls ast,fun () -> ())
  | Code ((HNode (_,_,var,_,_),_),ast) ->
    (ast, fun () ->                     (* TODO? somehow show vls? *)
      Format.kasprintf failwith
      "The code built at %a is not closed: identifier %s bound at %a is free"
      Location.print_loc ast.pexp_loc var.txt Location.print_loc var.loc)


let close_code_repr : code_repr -> closed_code_repr = fun cde ->
  let (ast, check) = close_code_delay_check cde in
  check (); ast

let open_code : closed_code_repr -> code_repr = fun ast ->
  Code (empty,ast)

(* The type of the code expression that represents a literal function. Such
   code expression is essentially a pattern clause *)
type 'a pat_code  = private 'a code

(* The type of the code expression that represents a value in the generated
   code. Such code expressions can be freely duplicated without affecting
   the behavior of the code.
 *)
type 'a val_code = private 'a code


(* Compiling a closed code value: a structural constant of
   type code_repr
   This constant is transported via CSP (although we could have
   built a Typedtree node for that purpose.
 *)
let texp_code : ?node_id:string ->
  Location.t -> Parsetree.expression_desc -> Typedtree.expression_desc =
  fun ?(node_id="") loc desc ->
  let ast = Ast_helper.Exp.mk ~loc desc in
  (texp_csp (Obj.repr (open_code ast))).exp_desc
  [@@warning "-27"]

(* ------------------------------------------------------------------------ *)
(* Bindings in the future stage *)
(* Recall, all bindings at the future stage are introduced by
   patterns, and hence are simple names, without any module qualifications.
*)
let gensym_count = ref 0

(* Generate a fresh name with the given base name *)
let gensym : string -> string = fun s ->
  incr gensym_count;
  s ^ "_" ^ string_of_int !gensym_count

(* Don't reset! Otherwise, variable names aren't guaranteed to be unique!
let reset_gensym_counter () = gensym_count := 0
*)

(* Make a simple identifier unique *)
let genident : string loc -> string loc = fun name ->
  {name with txt = gensym name.txt}

(* Produce the name of the fresh variable that certainly does not
   occur in flvars.
   The first argument name gives a hint about the name to produce
*)
let rec get_fresh_name : string -> flvars -> string = 
  fun name ((heap,lvs) as flvars) ->
  let fresh = gensym name in
  if any_heap (function {txt} -> txt = fresh) heap ||
     List.exists (fun (n,_) -> n = fresh) lvs 
    then get_fresh_name name flvars   (* try again, choose a different name *)
    else fresh

(* This is a run-time error, rather than a translation-time error *)
let scope_extrusion_error : 
  detected:Location.t -> Parsetree.expression -> string loc -> 'a = 
  fun ~detected ast var ->
  Format.kasprintf failwith
    "Scope extrusion detected at %a for code built at %a \
    for the identifier %s bound at %a\
    \nThe problematic code is shown below\n%a"
    Location.print_loc detected Location.print_loc ast.pexp_loc
    var.txt Location.print_loc var.loc
    Pprintast.expression ast

(* Check to make sure that free variables in the potentially open
   code fragment are valid.
   If it weren't for delimited control, the order of stack marks is
   stable; therefore, if the maximal mark is valid then all
   smaller marks are valid as well.
   Delimited control spoils all that. 
   When we capture some of the inner-bindings
   in a continuation and then reinstall that continuation at the
   top level, the `latest' free variable is valid but earlier are
   no longer valid:

  let r = ref ... in
  .<fun x1 x2 -> .~(reset .<fun y1 y2 -> 
                              .~(shift k (r := k; k .<0>.))>.)>.
  .r .<2>.
  Here, y1 and y2 are valid but x1 and x2 are not.
*)
let validate_vars : Location.t -> code_repr -> code_repr = 
  fun l -> function
  | Code ((Nil,_),_) as cde -> cde
  | Code ((h,_),ast) as cde -> begin
      let rec check = function
        | Nil -> ()
        | HNode (_,sm,var,h1,h2) ->
            if sm () then (check h1; check h2)
            else scope_extrusion_error ~detected:l ast var 
      in check h; cde
  end

let validate_vars_option : Location.t -> code_repr option -> 
  Parsetree.expression option * flvars = 
  fun l -> function
  | None -> (None,empty)
  | Some e -> let Code (vars, e) = validate_vars l e in (Some e, vars)

let validate_vars_map : Location.t -> 
  (Location.t -> 'a -> 'b * flvars) -> 'a list -> 'b list * flvars = 
  fun loc f xs ->
  map_accum (fun acc x -> 
      let (y,vars) = f loc x in
      (y, merge vars acc))
    empty xs

let validate_vars_list : Location.t -> code_repr list -> 
  Parsetree.expression list * flvars = fun l cs ->
  validate_vars_map l 
      (fun l c -> let Code (vars,e) = validate_vars l c in (e,vars)) cs

(* Remove the mentioning of all variables with the given priority
   from the code, in preparation for binding off those variables.
   If those variables appear in virtual let-bidings, actualize those bindings
   and their dependent bindings.
   We also validate the code as a matter of course.
   Bindings may be duplicated! To detect the duplication, phisical equality
   is ok.
   See the comments to vlet_bind_all for the complications...
*)
let vlet_bind : Location.t -> prio -> code_repr -> code_repr = fun l p ->
  let bind exp (vi,expi) =             (* do the let-bindings *)
    let open Ast_helper in
    Exp.let_ Nonrecursive [Vb.mk (Pat.var (mknoloc vi)) expi] exp
  in
  (* partition the bindings into to be performed and the ones that can
     stay virtual. The order of virtual is irrelevant. But the bindings
     to perform are ordered so that the innermost is at the top.
  *)
  let rec compute_bind ((vi,cdi) as vl) ((vls,actual) as z) =
    if List.mem_assq vi actual then z else
    let Code ((h,vli),expi) = validate_vars l cdi in
    if member_heap p h then
      let (vls,actual) = List.fold_right compute_bind vli (vls,actual) in
      (vls, (vi,expi) :: actual)
    else  (* keep vl as virtual *)
      (vl::vls,actual)
  in fun cde ->
    let Code ((h,vls),exp) = validate_vars l cde in
    let (vls,actual) = List.fold_right compute_bind vls ([],[]) in
    let exp = List.fold_left bind exp actual in
    Code ((remove p h,vls),exp)

(* Generate a fresh name off the given name, enter a new binding region
   and evaluate a function passing it the generated name as code_repr.
   Remove the generated name from the annotation on the resulting code_expr.
   Return that result and the generated name.
   This function embodies the translation of simple functions, for-loops,
   simple let-expressions, etc.
*)
      (* Counter for assigning priorities to vars heap nodes. *)
      (* Keep in mind the invariant that variables of the same priority
         come from the same binding location. So, we must keep the
         priorities unique to binders. Giving binders monotonically
         increasing priorities is helpful: the innermost binding
         has the highest priority and it will be at the top of the heap,
         the easiest to remove.
       *)
let prio_counter = ref 0

(* An auxiliary function to build the code representing a free variable
   of the given name (which is assumed fresh)
 *)
let make_free_var : prio -> stackmark -> string loc -> code_repr =
  fun prio mark name ->
  Code ((HNode (prio,mark,name,Nil,Nil),[]),
          Ast_helper.Exp.ident ~loc:name.loc   (* the loc of the binder *)
              (mkloc (Longident.Lident name.txt) name.loc))

(* Make a new fresh variable name, with the same binding scope as the given
   one. This is the function to dynamically produce variables.
   The first argument is the hint for the name
*)
let clone_free_var : string -> code_repr -> code_repr = fun name -> function
  | Code ((HNode (prio,mark,old_name,Nil,Nil),[]),_) ->
      make_free_var prio mark (mkloc (gensym name) old_name.loc)
  | _ -> assert false

let with_binding_region : 
    Location.t -> string loc -> (code_repr -> code_repr) -> 
    string loc * flvars * Parsetree.expression = 
 fun l name f -> 
  let new_name = genident name in
  let (vars,e) = 
   !with_stack_mark.stackmark_region_fn (fun mark ->
     incr prio_counter;
     let prio = !prio_counter in
     let var_code = make_free_var prio mark new_name in
     let Code (vars,e) = vlet_bind l prio (f var_code) in
     (vars,e)) in
  (new_name, vars, e)

(* The most general version with several bindings and several expressions 
   that use the bindings
 *)
let with_binding_region_gen : 
  Location.t -> string loc list -> 
  (code_repr array ->                         (* freshly bound variables *)
    (code_repr -> code_repr) ->               (* callback to clean-up code *)
    flvars * 'a list) ->
  string loc list * flvars * 'a list = 
 fun l names f -> 
  let new_names = List.map genident names in
  let (vars,es) = 
   !with_stack_mark.stackmark_region_fn (fun mark ->
     incr prio_counter;
     let prio = !prio_counter in
     let vars_code = new_names |> 
      List.map (fun new_name -> make_free_var prio mark new_name) |> 
      Array.of_list
     in
     f vars_code (fun cde -> vlet_bind l prio cde))
   in
  (new_names, vars, es)

(* ------------------------------------------------------------------------ *)
(* Building Parsetree nodes *)

(* Handle timestamp for builders of the type 
      Parsetree.expression -> Parsetree.expression
*)
let code_wrapper : 
    (Location.t -> Parsetree.expression -> Parsetree.expression) ->
    (Location.t -> code_repr -> code_repr) =
fun f l e ->
  let Code (vars,e) = validate_vars l e in
  Code (vars, f l e)

(* building a typical Parsetree node: Pexp_assert of expression*)
let build_assert : Location.t -> code_repr -> code_repr = 
  code_wrapper
  (fun loc e -> Ast_helper.Exp.assert_ ~loc e)

let build_unreachable : Location.t -> code_repr = fun loc ->
  open_code
  (Ast_helper.Exp.unreachable ~loc ())

(* When we translate the typed-tree, we have to manually compile
   the above code 
First, to see the AST for the phrase, invoke the top-level with the flag
-dparsetree. Then
   {pexp_loc  = l; pexp_desc = Pexp_assert e}

gives the parsetree:
let build_assert_ast : Location.t -> Parsetree.expression -> Parsetree.expression = 
{pexp_loc = l1;
 pexp_desc = 
  Pexp_record
        ([(Location.mknoloc (Longident.parse "Parsetree.pexp_loc"), 
           Pexp_ident "l");
         (Location.mknoloc (Longident.parse "Parsetree.pexp_desc"),
           {pexp_loc  = Location.none;
            pexp_desc = Pexp_construct 
                          ((Location.mknoloc (Longident.parse 
                                                "Parsetree.Pexp_assert")),
              Some {pexp_loc = Location.none;
                    pexp_desc = Pexp_ident "e"},
              false)})
        ],
        None)}
type_expression

If building the parsetree on our own, beware! For example, labels in
Texp_record must be sorted, in their declared order!
*)

(*
Need location!
let check_generated_attributes : attributes -> attributes = fun attrs ->
  let check_structure = function
    | {pstr_desc=
       Pstr_eval ({pexp_attributes=[];pexp_desc=Pexp_constant _},[])} -> ()
    | {pstr_loc}  -> not_supported pstr_loc 
                       "this form of structure item in an attribute"
  in
  let check_payload loc = function
    | PStr strs -> List.iter check_structure strs
    | _         -> not_supported loc "this form of attribute payload"
  in
  let is_prefix pat str = 
    let rec loop i =
      if i >= String.length pat then true else
      if i >= String.length str then false else
      pat.[i] = str.[i] && loop (i+1)
    in loop 0
  in
  let attrs = 
    attrs |> 
    List.filter (function {attr_name={txt=name}} -> 
                  not @@ is_prefix "metaocaml." name)
  in List.iter (function a -> check_payload a.attr_loc a.attr_payload) attrs;
  attrs
*)

(* Other similar builders *)
let build_lazy : Location.t -> code_repr -> code_repr = 
  code_wrapper @@
    fun loc e -> Ast_helper.Exp.lazy_ ~loc e
let build_braesc : Location.t -> attributes -> code_repr -> code_repr = 
  fun l attrs exp ->
  code_wrapper
    (fun _ e -> {e with pexp_attributes = 
                   attrs @ e.pexp_attributes }) l exp

let build_sequence : Location.t -> code_repr -> code_repr -> code_repr = 
  fun loc e1 e2 -> 
    let Code (vars1,e1) = validate_vars loc e1 in
    let Code (vars2,e2) = validate_vars loc e2 in
    Code (merge vars1 vars2,
          Ast_helper.Exp.sequence ~loc e1 e2)
let build_while : Location.t -> code_repr -> code_repr -> code_repr = 
  fun loc e1 e2 -> 
    let Code (vars1,e1) = validate_vars loc e1 in
    let Code (vars2,e2) = validate_vars loc e2 in
    Code (merge vars1 vars2,
          Ast_helper.Exp.while_ ~loc e1 e2)

(* Build the application. The first element in the array is the
   function. The others are arguments. *)
let build_apply : Location.t -> (arg_label * code_repr) array -> code_repr = 
  fun loc ea -> 
    assert (Array.length ea > 1);
    match map_accum (fun vars (lbl,e) -> 
                   let Code (var,e) = validate_vars loc e in
                   ((lbl,e),merge var vars))
          empty (Array.to_list ea) with
    | ((Nolabel,eh)::elt,vars) ->
       Code (vars, 
             Ast_helper.Exp.apply ~loc eh elt)
    | _ -> assert false


let build_tuple : Location.t -> code_repr array -> code_repr =
 fun loc ea -> 
  let (els,vars) = validate_vars_list loc (Array.to_list ea) in
  Code (vars, 
        Ast_helper.Exp.tuple ~loc els)

let build_array : Location.t -> code_repr array -> code_repr =
 fun loc ea -> 
  let (els,vars) = validate_vars_list loc (Array.to_list ea) in
  Code (vars,
        Ast_helper.Exp.array ~loc els)

let build_ifthenelse : 
 Location.t -> code_repr -> code_repr -> code_repr option -> code_repr =
 fun loc e1 e2 eo -> 
    let Code (vars1,e1) = validate_vars loc e1 in
    let Code (vars2,e2) = validate_vars loc e2 in
    let (eo,varso)      = validate_vars_option loc eo in
    Code (merge vars1 (merge vars2 varso),
          Ast_helper.Exp.ifthenelse ~loc e1 e2 eo)

let build_construct :
 Location.t -> Longident.t loc -> code_repr array -> code_repr =
 fun loc lid args ->
  let (args,vars) = validate_vars_list loc (Array.to_list args) in
  Code (vars, 
        Ast_helper.Exp.construct ~loc lid
          begin
            match args with
            | []  -> None
            | [x] -> Some x
            | xl  -> Some (Ast_helper.Exp.tuple ~loc xl)
     end)


let build_record : Location.t -> (Longident.t loc * code_repr) array ->
 code_repr option -> code_repr =
 fun loc lel eo ->
   let (lel,vars) = map_accum (fun vars (lbl,e) -> 
                       let Code (var,e) = validate_vars loc e in
                       ((lbl,e),merge var vars))
        empty (Array.to_list lel) in
   let (eo,varo) = validate_vars_option loc eo in
   Code (merge vars varo,
         Ast_helper.Exp.record ~loc lel eo)


let build_field : Location.t -> code_repr -> Longident.t loc -> code_repr =
 fun loc e lid ->
  let Code (vars,e) = validate_vars loc e in
  Code (vars,
        Ast_helper.Exp.field ~loc e lid)

let build_setfield :
 Location.t -> code_repr -> Longident.t loc -> code_repr -> code_repr =
 fun loc e1 lid e2 ->
  let Code (vars1,e1) = validate_vars loc e1 in
  let Code (vars2,e2) = validate_vars loc e2 in
  Code (merge vars1 vars2,
        Ast_helper.Exp.setfield ~loc e1 lid e2)

let build_variant : Location.t -> string -> code_repr option -> code_repr =
 fun loc l eo ->
  let (eo,vars) = validate_vars_option loc eo in
  Code (vars,
        Ast_helper.Exp.variant ~loc l eo)

let build_send : Location.t -> code_repr -> string -> code_repr =
 fun loc e l ->
  let Code (vars,e) = validate_vars loc e in
  Code (vars,
        Ast_helper.Exp.send ~loc e (mknoloc l))

(*
let build_open :
 Location.t -> Longident.t loc -> override_flag -> code_repr -> code_repr =
 fun loc l ovf e ->
  let Code (vars,e) = validate_vars loc e in
  Code (vars,
        Ast_helper.Exp.open_ ~loc ovf l e)
*)

(* Build a function with a non-binding pattern, such as fun () -> ... *)
let build_fun_nonbinding : 
  Location.t -> arg_label -> Parsetree.pattern list -> 
  (code_repr option * code_repr) array -> code_repr =
  fun loc label pats gbodies -> 
  let (egbodies,vars) = 
    validate_vars_map loc 
      (fun loc (eo,e) ->
        let (eo,vo)        = validate_vars_option loc eo in
        let Code (vars,e)  = validate_vars loc e in
        ((eo,e),merge vo vars)) 
      (Array.to_list gbodies) in
  Code (vars,
        match (egbodies,pats) with
        | ([(None,e)],[p]) ->
            Ast_helper.Exp.fun_ ~loc label None p e
        | _ when label=Nolabel ->
          Ast_helper.Exp.function_ ~loc 
            (List.map2 (fun p (eo,e) -> {pc_lhs=p;pc_guard=eo;pc_rhs=e}) 
              pats egbodies)
        | _ -> assert false)

(* Build a Parsetree for a future-stage identifier
   It is always in scope of with_binding_region:
   Bound variables are always in scope of their binders;
   A well-typed code has no unbound variables.
let build_ident : Location.t -> string loc -> code_repr =
 fun loc l ->
  not_supported loc "vars not supported"
  Code (add_timestamp (Some l)
   {pexp_loc  = loc;
    pexp_desc = Pexp_ident (mkloc (Longident.Lident l.txt) l.loc)}
*)

(* Build a simple one-arg function, as described in the the title comments *)
(* 'name' is the name of the variable from Ppat_var of the fun x -> ...
   form. It is the real name with the location within the function pattern.
   Use name.loc to identify the binder in the source code.
*)
let build_fun_simple : 
  Location.t -> arg_label -> string loc -> 
    (code_repr -> code_repr) -> code_repr =
  fun loc label old_name fbody -> 
  let (name, vars, ebody) = with_binding_region loc old_name fbody in
  let pat = Ast_helper.Pat.var ~loc:name.loc name in
  Code (vars,
        Ast_helper.Exp.fun_ ~loc label None pat ebody)

let build_for : 
  Location.t -> string loc -> code_repr -> code_repr -> 
  bool -> (code_repr -> code_repr) -> code_repr =
  fun loc old_name elo ehi dir fbody -> 
  let (name, varsb, ebody) = with_binding_region loc old_name fbody in
  let Code (varsl,elo) = validate_vars loc elo in
  let Code (varsh,ehi) = validate_vars loc ehi in
  Code (merge varsb (merge varsl varsh),
        Ast_helper.Exp.for_ ~loc 
          (Ast_helper.Pat.var ~loc:name.loc name) elo ehi 
            (if dir then Upto else Downto) ebody)


let build_let_simple_nonrec : 
  Location.t -> string loc -> code_repr -> (code_repr -> code_repr) -> 
    code_repr = fun loc old_name e fbody -> 
  let (name, varsb, ebody) = with_binding_region loc old_name fbody in
  let pat = Ast_helper.Pat.var ~loc:name.loc name in
  let Code (varse,e) = validate_vars loc e in
  Code (merge varsb varse,
        Ast_helper.Exp.let_ ~loc Nonrecursive 
           [Ast_helper.Vb.mk ~loc pat e] ebody)

(*
let build_letrec : 
  Location.t -> string loc array -> 
    (code_repr array -> code_repr array) -> code_repr = 
  fun l old_names fbodies -> 
  let (names,vars,ebodies) = 
    with_binding_region_gen l (Array.to_list old_names) fbodies in
  let (ebody,es) = 
    match ebodies with body::es -> (body,es) | _ -> assert false in
  let pel = List.map2 (fun name e ->
     ({ppat_loc  = name.loc; ppat_desc = Ppat_var name},e)) names es in
  Code (vars,
  {pexp_loc = l; 
   pexp_desc = Pexp_let (Recursive, pel, ebody)})
*)

(*{{{ CSP *)

(* ------------------------------------------------------------------------ *)
(* Dealing with CSP *)

exception CannotLift

(* Analyze the type of the expression and figure out if we can lift it.
   Raise CannotLift if cannot (e.g., the type is polymorphic), or it is too
   much to bother.
   TODO: lists, arrays, option types of liftable types are themselves
   liftable. We can lift many more types. For arrays, check their length.
   If the array is short, it should be lifted. For long arrays,
   building a CSP is better (although it make take a bit longer since
   we will have to invoke dyn_quote at run-time).

   TODO: currently we generate calls to run-time functions like 
   lift_constant_int to do the Parsetree generation. In the future
   we should `inline' those functions -- that is, obtain the Typedtree
   for them and use the tree for building Texp_apply.
*)
let lift_as_literal : 
  Typedtree.expression -> Longident.t loc -> Typedtree.expression_desc = 
  fun exp _li ->
  let exp_ty =
        Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
  match Ctype.repr exp_ty with
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
        texp_apply (texp_ident "Trx.lift_constant_int") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
        texp_apply (texp_ident "Trx.lift_constant_char") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
        texp_apply (texp_ident "Trx.lift_constant_bool") [exp]
          (* We cannot leave those to dyn_quote *)
          (* since the latter deals only with run-time value. The same
             value, with the same run-time representation, may have
             different incompatible types, thanks to abstract types.
           *)
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_unit ->
        texp_apply (texp_ident "Trx.lift_constant_unit") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_float ->
        texp_apply (texp_ident "Trx.lift_constant_float") [exp]
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_string ->
        texp_apply (texp_ident "Trx.lift_constant_string") [exp]
          (* Deal with code type *)
    | _ -> raise CannotLift

(* TODO: similarly handle Const_nativeint, Const_int32, Const_int64 *)
let lift_constant_int : int -> code_repr = fun x -> 
  open_code @@ Ast_helper.Exp.constant (Const.int x)

let lift_constant_char : char -> code_repr = fun x -> 
  open_code @@ Ast_helper.Exp.constant (Const.char x)

let lift_constant_bool : bool -> code_repr = fun x -> 
  let b = if x then "true" else "false" in 
  open_code @@ Ast_helper.Exp.construct 
                 (Location.mknoloc (Longident.Lident b)) None

let lift_constant_unit : unit -> code_repr = fun () -> 
  open_code @@ Ast_helper.Exp.construct 
                 (Location.mknoloc (Longident.Lident "()")) None

let lift_constant_float : float -> code_repr = fun x -> 
  open_code @@ 
        Ast_helper.Exp.constant (Const.float (string_of_float x))

let lift_constant_string : string -> code_repr = fun x -> 
  open_code @@ 
        Ast_helper.Exp.constant (Const.string x)

(* Lift the run-time value v into a Parsetree for the code that, when
   run, will produce v.
   We do not have the type information for v, but we can examine
   its run-time representation, to decide if we lift it is a source
   literal or as a CSP.
   We attach the CSP attribute to an expression, for the sake of better
   printing (also to simplify translation when CSP occurs within nested
   brackets).

   We always have to put Obj.magic conversion, even if the value looks
   like a string or a double. It may be represented as a double but the type
   which it is used can be different: abstract. 
   See test/test_csp1 for an example. Reported and patched by Jeremy Yallop.

  TODO: also check for double_array_tag
   and create a (structured) constant for a double array
*)
let obj_magic_exp = 
  Ast_helper.Exp.ident (Location.mknoloc @@
   (Longident.Ldot (Longident.Lident "Obj","magic")))

(* Check to see if a value is easy to serialize *)
let easy_to_serialize : Obj.t -> bool =
  let depth_bound = 5 in
  let rec loop n v = 
    Obj.is_int v || 
    let tag = Obj.tag v in
    tag = Obj.string_tag ||
    tag = Obj.double_tag ||
    tag = Obj.double_array_tag ||
    if n <= 0  ||
      tag = Obj.closure_tag ||
      tag >= Obj.no_scan_tag
    then false
    else let rec inner i = 
      if i < 0 then true else
      loop (n-1) (Obj.field v i) && inner (i-1) 
      in inner (Obj.size v - 1)
  in loop depth_bound


let dyn_quote : Obj.t -> Longident.t loc -> code_repr =
  fun v li ->
   let csp_attr = attr_csp li in
   let exp = match Obj.is_int v with
    | true ->
        Ast_helper.Exp.constant (Const.int (Obj.obj v))
    | false when Obj.tag v = Obj.double_tag ->
        Ast_helper.Exp.constant (Const.float (string_of_float (Obj.obj v)))
    | false when Obj.tag v = Obj.string_tag ->
        Ast_helper.Exp.constant (Const.string (Obj.obj v))
    | _   ->           (* general case *)
        let () =
          if not @@ easy_to_serialize v then
            debug_print ~loc:li.loc 
             "The CSP value is a closure or too deep to serialize" in
        Ast_helper.Exp.constant  (Const.string (Obj.obj v))
   in
   open_code @@
   Ast_helper.Exp.apply ~attrs:[csp_attr] ~loc:li.loc
     obj_magic_exp [(Nolabel,exp)]

       
(* Build the Typedtree that lifts the variable with the given path and type.
   Since this code receives the type of the variable, we use the
   type to generate the lifting code for that particular type.
   For example, we build the code to convert a float
   0.1 to the Parsetree node Pexp_constant(Const_float "0.1")).
   If we cannot or would not do the type-dependent lifting and we cannot
   refer to the variable by name (e.g., because it is local),
   we generate the call to the dynamic quoter, dyn_quote.
   The latter will receive the actual value to quote and will generate,
   at run-time, a Parsetree constant or CSP, based on that value.
 *)
let trx_csp : 
  Typedtree.expression -> Path.t -> Longident.t loc ->
  Typedtree.expression_desc = fun exp p li ->
  (* First we try lifting as a constant *)
  try lift_as_literal exp li 
  with CannotLift ->
  (* Then check if we can pass by reference *)
  if ident_can_be_quoted p then
    texp_code ~node_id:"*id*" exp.exp_loc
          (Pexp_ident (Location.mkloc (path_to_lid p) li.loc))
  else
  (* Otherwise, do the lifting at run-time *)
  texp_apply (texp_ident "Trx.dyn_quote") [exp; texp_lid li]

(*{{{ Historical: hints on native mode CSP *)

(* Native mode is moved out to the `userland'

let remove_texp_cspval exp =
  if !native_mode = false then exp else
  failwith "native mode CSP are not impemented yet"

old code
  match exp.exp_desc with
  | Texp_cspval (v,l) ->
      let i = add_csp_value (v,l) in
      let exp' = {exp with exp_desc = Texp_constant (Const_int i)} in
      let desc = if !initial_native_compilation
        then (Texp_apply (trx_array_get exp, [(Some !local_csp_arr_texp, Required);(Some exp', Required)]))
	else (Texp_apply (trx_get_csp_value exp, [(Some exp', Required)])) in
      {exp with exp_desc = desc}
  | _ -> assert false
*)

(*}}}*)

(*}}}*)


(*{{{ Translating patterns and expressions using patterns *)


(* Analyze and translate a pattern:
         Typedtree.pattern -> Parsetree.pattern
  The function is somewhat similar to tools/untypeast.ml:untype_pattern

  However, we also determine and return the list of bound variables.
  The list is in the reverse of the order of variables occurring in the pattern.
  Finally, we check that labels and constructors may be quoted.

  The algorithm of determining the names of bound variables is based
  on Typedtree.pat_bound_idents. There is one subtle issue.
  Normally all variables within a pattern are unique (patterns are
  always linear). Identically named variables within a list of patterns, like 
      match ... with
      | [x] -> 
      | [x;y] ->
  are _distinct_ variables. They have different Ident.t values, even though
  their names may be the same. However, components of an OR pattern 
  bind exactly the same identifiers. Don't count them twice!
*)

let trx_const : Asttypes.constant -> Parsetree.constant = function
  | Const_int n            -> Const.int n
  | Const_char c           -> Const.char c
  | Const_string (s,l,del) -> Const.string ?quotation_delimiter:del ~loc:l s
  | Const_float s          -> Const.float s
  | Const_int32 n          -> Const.int32 n
  | Const_int64 n          -> Const.int64 n
  | Const_nativeint n      -> Const.nativeint n

(* The first argument is a list of identifiers. Found identifiers are
   prepended to that list. The order of identifiers is important!
   If you change the traversal order, be sure to modify pattern_subst below!
*)

let rec trx_pattern : 
    (Ident.t * string loc) list -> Typedtree.pattern -> 
     Parsetree.pattern * (Ident.t * string loc) list = fun acc pat ->
  let (pd,acc) = match pat with
  |  { pat_extra=[Tpat_unpack, _, _attrs]; pat_desc = Tpat_var (_,name); _ } ->
                  (* name must have been uppercase *)
        (Ppat_unpack (Location.mkloc (Some name.txt) name.loc),acc)
  | { pat_extra=[Tpat_type (_path, lid), _, _attrs]; _ } -> (Ppat_type lid,acc)
  | { pat_extra= (Tpat_constraint _ct, _, _attrs) :: _rem; _ } ->
      not_supported pat.pat_loc
        "patterns with constraints, and other pat_extra";
      (*
        Ppat_constraint (untype_pattern { pat with pat_extra=rem },
                         untype_core_type ct)
       *)
  | _ -> match pat.pat_desc with
  | Tpat_any -> (Ppat_any, acc)
  | Tpat_var (id, name) when 
      (match (Ident.name id).[0] with 'A'..'Z' -> true | _ -> false) ->
        (* We don't handle modules though...*)
        (Ppat_unpack (Location.mkloc (Some name.txt) name.loc),acc)
  | Tpat_var (id, name) ->
      (Ppat_var name, (id,name)::acc)
  | Tpat_alias (p, id, name) ->
      let (p,acc) = trx_pattern acc p in
      (Ppat_alias (p, name),(id,name)::acc)
  | Tpat_constant cst -> (Ppat_constant (trx_const cst), acc)
  | Tpat_tuple lst ->
    let (pl,acc) = map_accum trx_pattern acc lst
    in (Ppat_tuple pl, acc)
  | Tpat_construct (li, cdesc, args) ->
      if cdesc.cstr_generalized then
        trx_error @@ Location.errorf ~loc:pat.pat_loc
          "Patterns with implicit equality constraints \
           (aka, GADTs) `%s' \
           within brackets are generally unsound. They are not \
           supported" cdesc.cstr_name;
      let lid = qualify_ctor li cdesc in
      let (args,acc) = map_accum trx_pattern acc args in
      (Ppat_construct (lid,
          (match args with
          | []  -> None 
          | [x] -> Some x 
          | _   -> Some (Ast_helper.Pat.tuple ~loc:pat.pat_loc args))),
       acc)
  | Tpat_variant (label, None, _) -> (Ppat_variant (label,None),acc)
  | Tpat_variant (label, Some p, _) ->
      let (p,acc) = trx_pattern acc p 
      in (Ppat_variant (label,Some p),acc)
  | Tpat_record (lst, closed) ->
      let dolab acc (li,ldesc,pat) =
        let lid = qualify_label li ldesc in
        let (pat,acc) = trx_pattern acc pat in
        ((lid,pat),acc)
      in
      let (lpl,acc) = map_accum dolab acc lst in
      (Ppat_record (lpl,closed),acc)
  | Tpat_array lst -> 
    let (pl,acc) = map_accum trx_pattern acc lst
    in (Ppat_array pl, acc)
  | Tpat_or (p1, p2, _) -> 
      (* Invariant : both arguments bind the same variables *)
      let (p1,acc) = trx_pattern acc p1 in
      let (p2,_)   = trx_pattern acc p2 in (* ignore vars in p2 *)
      (Ppat_or (p1,p2),acc)
  | Tpat_lazy p -> 
      let (p,acc) = trx_pattern acc p in (Ppat_lazy p,acc)
  in
  (Ast_helper.Pat.mk ~loc:pat.pat_loc ~attrs:pat.pat_attributes pd, acc)


(* Process all patterns in the case list *)
(* Patterns are processed left-to-right. The result is the processed
   pattern list plus the list of names of the bound variables.
   The variables are listed in the order they occur in the pattern.
   Thus the following should hold:
      let (pats,names,_) = trx_cl cl in
      let (pats',acc) =  pattern_subst_list names pats in
      assert (pats = pats');
      assert (acc = [])
   The final result of trx_cl is the pattern binding the names.
   We build an array pattern rather than a more appropriate tuple.
   Using array forces a single type to all arguments. Although
   it is phantom anyway, it is still a bummer. But with the tuple
   we can't generically write build_fun.
   The second argument, typ_expr, should normally be a code type.

   This function is used when translating a future-stage function as the 
   present-stage whose argument is an array of variables.
   See trx_bracket for functions, let, match and try

  This function deals only with value pattern. Exception patterns
  should have been split up (see Typedtree.split_pattern)
*)
let trx_cl : value case list -> type_expr ->
     Parsetree.pattern list * string loc list * Typedtree.pattern
   = fun cl typ -> 
   let (pats, lst) = 
     map_accum (fun acc {c_lhs} -> trx_pattern acc c_lhs) [] cl in
   let idnames = List.rev lst in
   let (loc,env) = 
     match cl with {c_lhs=p}::_ -> (p.pat_loc, p.pat_env) |_ -> assert false in
    (* Pattern representing one binding variable *)
   let var_pat (id,name) =
    {pat_loc = loc; pat_extra = []; pat_env = env;
     pat_desc = Tpat_var (id,name);
     pat_attributes=[];
     pat_type = typ} in
   (pats, List.map snd idnames,
    {pat_loc = loc; pat_extra = []; pat_env = env;
     pat_attributes=[];
     pat_desc = Tpat_array (List.map var_pat idnames);
     pat_type = Ctype.instance (Predef.type_array typ)})

(* Substitute the names of bound variables in the pattern.
   The new names are given in the string loc list. We
   take advantage of the fact that patterns are linear and
   the list of new names is ordered, in the order the bound
   variables occur in the pattern. Therefore, we substitute based
   on position.
   OR-patterns bring complexity however: both branches of an OR
   pattern bind exactly the same variables (but the order of
   variable occurrence within branches may be different).
   So for OR patterns we substitute by name, taking advantage
   of the fact the new names differ from the old ones in _nnn
   suffix. OR patterns are uncommon, so the complication of their processing
   is not that bad.

   This function is closely related to trx_pattern; It relies on the
   same pattern traversal order as trx_pattern.
 *)

         (* two strings are the same up to (and including) n *)
let rec same_upto s1 s2 n =
  n < 0 || (s1.[n] = s2.[n] && same_upto s1 s2 (n-1))

let rec pattern_subst : ?by_name:bool ->
    string loc list -> Parsetree.pattern -> 
     Parsetree.pattern * string loc list = fun ?(by_name=false) acc pat ->
 if acc = [] then (pat,acc) else           (* no more variables to subst *)
 let subst old_name acc =
   if by_name then begin
     let new_name =
       try List.find (fun n -> 
         same_upto old_name.txt n.txt (String.rindex n.txt '_' - 1)) acc 
       with _ ->
         begin
           Format.fprintf Format.str_formatter "old_name %s %a\n"
             old_name.txt Location.print_loc old_name.loc;
           List.iter (fun n -> Format.fprintf Format.str_formatter
               "new name %s %a\n" n.txt Location.print_loc n.loc) acc;
           failwith (Format.flush_str_formatter ())
         end
     in
     (new_name, acc)                       (* don't bother removing from acc*)
   end
   else match acc with
   | h::t -> (h,t)
   | _    -> assert false
 in
 let (desc,acc) = match pat.ppat_desc with
  | Ppat_any as x -> (x,acc)
  | Ppat_var old_name ->
      let (new_name,acc) = subst old_name acc in (Ppat_var new_name,acc)
  | Ppat_alias (p,old_name) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     let (new_name,acc) = subst old_name acc in 
     (Ppat_alias (p,new_name),acc)
  | Ppat_constant _ as x -> (x,acc)
  | Ppat_tuple pl ->
      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
      (Ppat_tuple pl,acc)
  | Ppat_construct (_,None) as x -> (x,acc)
  | Ppat_construct (lid,Some p) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_construct (lid,Some p),acc)
  | Ppat_variant (_,None) as x -> (x,acc)
  | Ppat_variant (l,Some p) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_variant (l,Some p),acc)
  | Ppat_record (pl,cf) ->
      let (pl,acc) = map_accum (fun acc (l,p) -> 
          let (p,acc) = pattern_subst ~by_name acc p in ((l,p),acc)) acc pl in
      (Ppat_record (pl,cf),acc)
  | Ppat_array pl ->
      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
      (Ppat_array pl,acc)
  | Ppat_or (p1,p2) ->
     let (p1,acc') = pattern_subst ~by_name acc p1 in
     let (p2,_)   = pattern_subst ~by_name:true acc p2 in
     (Ppat_or (p1,p2), acc')
  | Ppat_constraint (p,cty) ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_constraint (p,cty), acc)
  | Ppat_type _ as x -> (x,acc)
  | Ppat_lazy p ->
     let (p,acc) = pattern_subst ~by_name acc p in
     (Ppat_lazy p, acc)
  | Ppat_unpack _ as x -> (x,acc)
  | _ -> assert false (* we do not create other forms of Ppat *)
 in
 ({pat with ppat_desc = desc}, acc)


let pattern_subst_list :
    string loc list -> Parsetree.pattern list -> 
     Parsetree.pattern list * string loc list = fun acc pl ->
 map_accum (pattern_subst ~by_name:false) acc pl



(* Build the general fun Parsetree *)

(* Build the fresh variable name for cases and build the Parsetree
   case list
   We implicitly assume that all variables bound by patterns in any clause
   scopes over all clauses. That seems like a wild assumption: for example,
   in
     function | x -> e1 | y -> e2
   the variable x should scope only over e1 rather than also over e2.
   However, this wild scoping is no problem: recall that we process
   the Typedtree, and the type checker already determined the scoping.
   In the type-checked example
     let x = 1 in
     function | x -> e1 | y -> x + 2
   the variables are represented not just by their names but by their Path,
   which contains the unique timestamp. Therefore, we are actually dealing with
     let x/1 = 1 in
     function | x/2 -> e1 | y/3 -> x/1 + 2
   Therefore, if we make x/2 also scope over the second clause, that is
   harmless.
   Because of such scoping rules, prepare_cases is also useful
   for processing letrec.
*)
let prepare_cases : Location.t -> 
  flvars ->     (* extra free variables used in kontinuation *)
  (* The following argument is a pair: a pattern list for the clauses
     of the function, and the list of names of bound variables, in order.
  *)
  (Parsetree.pattern list * string loc list) -> 
  (* The following function returns the list of pairs of guards and bodies,
     for each clause of the function
   *)
  (code_repr array -> (code_repr option * code_repr) array) -> 
  (* The continuation *)
  (Parsetree.case list -> Parsetree.expression) -> code_repr =
  fun loc evars (pats,old_names) fgbodies k -> 
    (* because of fold_left, which is convenient, the order of clauses
       is reversed.
    *)
    let fgbodies' newvars cleanupf = 
      let f (varss,es) = function
        | (None,cde) -> 
            let Code (vars,e) = cleanupf cde in
            (merge vars varss,(None,e)::es)
        | (Some ocde,cde) -> 
            let Code (vars,e)   = cleanupf cde in
            let Code (ovars,oe) = cleanupf ocde in
            (merge (merge vars ovars) varss,(Some oe,e)::es)
      in
      Array.fold_left f (empty,[]) @@ fgbodies newvars in
    let (names,vars,egbodies) = 
         with_binding_region_gen loc old_names fgbodies' in
    (* restore the order reversed by fgbodies', see comment above *)
    let egbodies = List.rev egbodies in 
    let pats = 
      if names = [] then pats else
      let (pats,acc) = pattern_subst_list names pats in
      assert (acc = []); pats
    in
    Code(merge evars vars,
         k @@ List.map2 (fun p (eo,e) -> {pc_lhs=p;pc_guard=eo;pc_rhs=e}) 
              pats egbodies)

let build_fun : 
  Location.t -> arg_label -> 
  (Parsetree.pattern list * string loc list) -> 
  (code_repr array -> (code_repr option * code_repr) array) -> code_repr =
  fun loc label pon fgbodies -> 
  prepare_cases loc empty pon fgbodies @@ function
    | [{pc_lhs=p; pc_guard=None; pc_rhs=e}] ->
        Ast_helper.Exp.fun_ ~loc label None p e
    | cases when label=Nolabel -> 
        Ast_helper.Exp.function_ ~loc cases
    | _ -> assert false


(* Build the general let-Parsetree (like the fun-Parsetree) *)
let build_let : 
  Location.t -> bool -> 
  (Parsetree.pattern list * string loc list) ->
  (code_repr array -> (code_repr option * code_repr) array) -> code_repr =
  fun loc recf pon fgbodies ->
  prepare_cases loc empty pon fgbodies @@ function
    | [] | [_] -> assert false
      (* The first case is the pseudo-case for the let body *)
    | {pc_guard=None; pc_rhs=ebody} :: cases ->
        Ast_helper.Exp.let_ ~loc (if recf then Recursive else Nonrecursive)
          (List.map (function 
            | {pc_lhs;pc_guard=None;pc_rhs} ->
                Ast_helper.Vb.mk ~loc:pc_lhs.ppat_loc pc_lhs pc_rhs
            | _ -> assert false)
           cases) 
         ebody
    | _ -> assert false

(* build match and try: both are very similar and similar to build_fun *)
let build_match : 
  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
  int ->
  (code_repr array -> (code_repr option * code_repr) array) -> code_repr =
  fun loc pon ec nregular fgbodies ->
    let Code (evars,exp) = validate_vars loc ec in
    let split : int -> 'a list -> 'a list * 'a list = fun n lst ->
      let rec loop n acc lst = match (n,lst) with
      | (0,lst)  -> (List.rev acc,lst)
      | (n,h::t) -> loop (n-1) (h::acc) t
      | _        -> assert false
      in loop n [] lst
    in
    prepare_cases loc evars pon fgbodies @@ fun cases ->
      Ast_helper.Exp.match_ ~loc exp
      (let (rc,ec) = split nregular cases in
       rc @ List.map 
          (fun c ->
            let pat = {c.pc_lhs with ppat_desc = Ppat_exception c.pc_lhs}
            in {c with pc_lhs = pat}) ec)


(* Essentially the same as build_match.
   TODO: implement the same check on the timestamp of the expression to try
*)
let build_try : 
  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
  (code_repr array -> (code_repr option * code_repr) array) -> code_repr =
  fun loc pon ec fgbodies ->
    let Code (evars,exp) = validate_vars loc ec in
    prepare_cases loc evars pon fgbodies @@ fun cases ->
      Ast_helper.Exp.try_ ~loc exp cases

(*}}}*)


(* ------------------------------------------------------------------------ *)
(* The main function to translate away brackets. It receives
   an expression at the level n > 0.

   Since bracket-translation is somewhat similar to un-typechecking,
   see tools/untypeast.ml for hints on mapping Typedtree.expression
   to Parsetree.expression.

TODO: an optimization idea. Consider <assert e> as a typical expression.
We translate it to the invocation of build_assert that will construct
the Parsetree node at run-time. However, if 'e' is simple (e.g., a constant)
then we can construct the Parsetree node at compile time and pass it
as a CSP. There are no longer any functions calls to make at run-time.
So, we can modify the translation of <assert e> below to detect
if the translation of e produced Texp_cspval. We extract the CSP value,
invoke build_assert (at compile time, when trx.ml is run) to build
the Pexp_assert node, and wrap it as a CSP.

Essentially the result of trx_bracket should be like
   Transl_bracket of Parsetree.expression option * Typedtree.expression
The first part of the result is the code built-in at compile time.
This part is None if the expression to translate contains an escape
or a true CSP (global id is OK). Sometimes we need both parts: consider
       <fun x -> x + ~(...)>
When we translate x we don't know if we can take a shortcut and
build the function code at translation time. So, we have to account
for both possibilities. If we can build the function at compile time,
we don't even need to rename the bound variable!

*)

(* Given a type [ty], return [ty code code ... code] (n times code).
   When we push the bracket in, expressions that had type ty before
   will have the type ty code.
   Here, ty code is an abstract type whose concrete representation
   is code_repr.
   Since now trx_bracket is used by the type checker proper, we should
   really report proper types on the transformed expressions.
*)

let rec wrap_ty_in_code : int -> type_expr -> type_expr = fun n ty ->
  if n=0 then ty else
  wrap_ty_in_code (n-1) (mk_type_code ty)

let map_option : ('a -> 'b) -> 'a option -> 'b option = fun f -> function
  | None   -> None
  | Some x -> Some (f x)


let rec trx_bracket : int -> expression -> expression = fun n exp ->
  (*
      let _ = debug_print "Texp_bracket" in
      let rec prattr = function
        | [] -> ()
        | ({txt=name},_) :: t -> 
            debug_print ("attr: " ^ name); prattr t
      in prattr   exp.exp_attributes;
      let _ = Location.print Format.err_formatter (exp.exp_loc) in
  *)
  (* Handle staging constructs, which are distinguished solely by
     attributes 
     The following staging constructs have appeared within the brackets,
     and were the result of texp_braesc invoked from typecore.
  *)
  match what_stage_attr exp.exp_attributes with
  | Stage0 -> trx_bracket_ n exp
        (* see texp_braesc for the representation of brackets and escapes
           in the Typedtree *)
  | Bracket(battrs,attrs)
  | FunBracket(battrs,attrs)
  | ValBracket(battrs,attrs) -> 
  begin
    match exp.exp_desc with
    | Texp_sequence (_,exp) ->
      {exp with exp_type = wrap_ty_in_code n exp.exp_type;
                exp_attributes = attrs;
                exp_desc =
                 texp_apply (texp_ident "Trx.build_braesc")
                   [texp_loc exp.exp_loc; 
                    texp_attributes battrs;
                    trx_bracket (n+1) exp]}
    | _ -> assert false   (* corrupted representation of bracket *)
  end
  | Escape(ea,attrs) -> 
  begin
    match exp.exp_desc with
    | Texp_sequence (_,exp) ->
        if n = 1 then exp	               (* switch to 0 level *)
        else
        {exp with 
          exp_type = wrap_ty_in_code n exp.exp_type;
          exp_attributes = attrs;
          exp_desc = texp_apply (texp_ident "Trx.build_braesc")
                      [texp_loc exp.exp_loc; 
                       texp_attributes [ea];
                       trx_bracket (n-1) exp]}
    | _ -> assert false   (* corrupted representation of escape *)
  end
  | CSP(_,li,attrs) -> (* For CSP, we only need to propagate the CSP attr *)
     {exp with 
         exp_type = wrap_ty_in_code n exp.exp_type;
         exp_attributes = attrs;
         exp_desc = texp_apply 
                     (texp_ident "Trx.dyn_quote") [exp; texp_lid li]}

  (* convert the case list to the function that receives the sequence
     of bound variables and returns the array of translated guards and
     bodies
   *)
and trx_case_list_body : int -> Typedtree.pattern -> 
  expression ->  (* used as the template for the result: we use
                    the env, location info *)
  value case list -> expression = 
  fun n binding_pat exp cl ->
  (* Translate the future-stage function as the present-stage 
     function whose argument is an array of variables 
     (should be a tuple, really) and the type
     some_targ code array -> tres code array
     Using array forces a single type to all arguments. Although
     it is phantom anyway, it is still a bummer. Instead of
     array, we should have used a tuple. But then we can't
     generically write build_fun.
   *)
  (* Pattern representing the function's argument:
     array of variables bound by the original pattern, in order.
   *)
  let body = 
    texp_array (List.map (fun {c_guard;c_rhs;_} -> 
      texp_tuple [texp_option @@ map_option (trx_bracket n) c_guard;
                  trx_bracket n c_rhs])
      cl) in
  { exp with
    exp_desc = Texp_function{arg_label=Nolabel;
                             param = Ident.create_local "bngs";
                             cases = [texp_case binding_pat body];
                             partial=Total};
    exp_type = {exp.exp_type with desc =
                   Tarrow (Nolabel,binding_pat.pat_type, body.exp_type, Cok)}
  }


and trx_bracket_ : int -> expression -> expression = fun n exp ->
  let new_desc = match exp.exp_desc with
    (* Don't just do only for vd.val_kind = Val_reg 
       because (+) or Array.get are Val_prim *)
  | Texp_ident (p,li,vd)  ->
    let stage = get_level vd.val_attributes in
    (* We make CSP only if the variable is bound at the stage 0.
       Variables bound at stage > 0 are subject to renaming.
       They are translated into stage 0 variable but of a different
       type (t code), as explained in the title comments.
     *)
    if stage = 0 then trx_csp exp p li 
    else
         (* Future-stage bound variable becomes the present-stage
            bound-variable, but at a different type.
          *)
      let () = assert (vd.val_kind = Val_reg) in
      (* The drawback is that exp.exp_loc disappears. If the scope extrusion
         is reported for a simple expression like <x>, we can no longer
         print in the error message the location that <x> appeared.
         We can only print the location x was bound.
      *)
      Texp_ident (p,li,{vd with val_type = wrap_ty_in_code n vd.val_type})

  | Texp_constant cst -> 
      texp_code ~node_id:"*cst*" exp.exp_loc (Pexp_constant (trx_const cst))

     (* The most common case of let-expressions: non-recursive
        let x = e in body *)
  | Texp_let (Nonrecursive,[{vb_pat = {pat_desc = Tpat_var (id,name)} as pat;
                     vb_expr = e}],ebody) ->
      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
      texp_apply (texp_ident "Trx.build_let_simple_nonrec") 
        [texp_loc exp.exp_loc;
         texp_string_loc name;
         trx_bracket n e;
         { exp with
           exp_desc = 
            Texp_function{arg_label=Nolabel;
                          param=id;
                          cases=[texp_case pat (trx_bracket n ebody)];
                          partial=Total};
           exp_type = 
            {exp.exp_type with desc =
               Tarrow (Nolabel,pat.pat_type, 
                       wrap_ty_in_code n ebody.exp_type, Cok)}
         }
       ]

     (* General case of let. There are two subcases: parallel and recursive:
          let     x = e1 and y = e2 ... in body
          let rec x = e1 and y = e2 ... in body
          
        The difference between them is profound: in the first case,
        x and y do not scope over e1 and e2, but in the recursive case,
        they do.
        And yet we translate the two cases uniformly. Recall that we are 
        processing the Typedtree: the type checker already determined
        the scoping rules. The variables are represented with their paths,
        which bear unique timestamps. See the comment in prepare_cases
        above.
     *)
  | Texp_let (recf,vbl,ebody) ->
     (*   No longer needed: Jeremy Yallop integrated the test into the typecore
      let check_letrec ({vb_pat=p;vb_expr=e} as vb) =
        begin
        match p.pat_desc with
        | Tpat_var (_,_) -> ()
        | _ -> 
            trx_error @@ Location.errorf ~loc:p.pat_loc
            "Only variables are allowed as left-hand side of `let rec'"
        end;
        match e.exp_desc with
        | Texp_function _ -> ()
        | _ -> 
            trx_error @@ Location.errorf ~loc:vb.vb_loc
            "Recursive let binding must be to a function"
            (* Location.print e.exp_loc *)
      in if recf = Recursive then
        List.iter check_letrec vbl;
      *)
      (* Artificially convert vbl to case list, making the body
         the first case with the Pat_any pattern.
         Of course the scoping rules are different for vbl and case list.
         Again, scoping has been already determined and resolved,
         and our case list processing assumes very wild scoping that
         accommodates let, letrec, functions, etc.
       *)
      let cl = 
        {c_lhs =                        (* pseudo-pattern for ebody *)
          {pat_desc = Tpat_any; pat_loc=ebody.exp_loc;
           pat_attributes=[]; pat_extra=[]; 
           pat_type=ebody.exp_type;
           pat_env=ebody.exp_env};
         c_guard=None; 
         c_rhs=ebody} ::
        List.map (fun {vb_pat;vb_expr} -> texp_case vb_pat vb_expr) vbl in
      let (pl,names,binding_pat) = 
        trx_cl cl (wrap_ty_in_code n (Btype.newgenvar ())) in
      texp_apply (texp_ident "Trx.build_let") 
        [texp_loc exp.exp_loc;
         texp_bool (recf = Recursive);
         texp_pats_names pl names;
         trx_case_list_body n binding_pat exp cl
       ]

     (* The most common case of functions: fun x -> body *)
  | Texp_function {arg_label=l; param;
                   cases=[{c_guard=None; 
                           c_lhs={pat_extra=[]; 
                                  pat_desc = Tpat_var (_,name)} as pat;
                       c_rhs=ebody}]} ->
      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
      texp_apply (texp_ident "Trx.build_fun_simple") 
        [texp_loc exp.exp_loc;
         texp_label l;
         texp_string_loc name;
         (* Translate the future-stage function as present-stage function;
            with the same variables, but with a different type,
            targ code -> tres code
          *)
         { exp with
           exp_desc = 
             Texp_function
             {arg_label=Nolabel;param;
              cases=[texp_case pat (trx_bracket n ebody)];
              partial=Total};
           exp_type = 
            {exp.exp_type with desc =
               Tarrow (Nolabel,pat.pat_type, 
                       wrap_ty_in_code n ebody.exp_type, Cok)}
         }
       ]

  | Texp_function {arg_label=l;cases=cl} ->
      begin
      match trx_cl cl (wrap_ty_in_code n (Btype.newgenvar ())) with
      | (pl, [], _) ->                    (* non-binding pattern *)
          texp_apply (texp_ident "Trx.build_fun_nonbinding")
            [texp_loc exp.exp_loc; 
             texp_label l;
             begin 
               let pl_exp = texp_ident "Trx.sample_pat_list" in
               {pl_exp with
                exp_desc = (texp_csp (Obj.repr pl)).exp_desc}
             end;
             texp_array (List.map (fun {c_guard;c_rhs;_} -> 
                 texp_tuple [texp_option @@ 
                              map_option (trx_bracket n) c_guard;
                             trx_bracket n c_rhs]) 
                 cl)
           ]
      | (pl, names, binding_pat) ->
          texp_apply (texp_ident "Trx.build_fun") 
            [texp_loc exp.exp_loc;
             texp_label l;
             texp_pats_names pl names;
             trx_case_list_body n binding_pat exp cl
           ]
      end

  | Texp_apply (e, el) ->
     (* first, we remove from el the information added by the type-checker *)
     let lel = List.fold_right (function                 (* keep the order! *)
                | (_,None)   -> fun acc -> acc
                | (l,Some e) -> fun acc -> (l,e)::acc) el [] in
     let lel = (Nolabel,e) :: lel in          (* Add the operator *)
      texp_apply (texp_ident "Trx.build_apply")
        [texp_loc exp.exp_loc; 
         texp_array (List.map (fun (l,e) ->
           texp_tuple [texp_label l;trx_bracket n e]) lel)]

  (* Pretty much like a function *)
  | Texp_match (e,cl',_) ->
      (* split into lists of ordinary and exceptional cases *)
      let rec collect_cases : 
        value case list * value case list -> 
        computation case list -> value case list * value case list =
          fun (rcl,ecl) -> function
        | [] -> (List.rev rcl, List.rev ecl)
        | {c_lhs=p} as c :: t ->
            let (rp,ep) = split_pattern p in
            t |> collect_cases Option.(
                rp |> fold ~none:rcl ~some:(fun p -> {c with c_lhs=p}::rcl), 
                ep |> fold ~none:ecl ~some:(fun p -> {c with c_lhs=p}::ecl)) 
      in
      let (rcl, ecl) = collect_cases ([],[]) cl' in
      let cl = rcl @ ecl in     (* handle all cases uniformly *)
      let (pl,names,binding_pat) = 
        trx_cl cl (wrap_ty_in_code n (Btype.newgenvar ())) in
      texp_apply (texp_ident "Trx.build_match") 
        [texp_loc exp.exp_loc;
         texp_pats_names pl names;
         trx_bracket n e;
         texp_int @@ List.length rcl;
         trx_case_list_body n binding_pat exp cl
       ]

  | Texp_try (e,cl) ->                 (* same as Texp_match *)
      let (pl,names,binding_pat) = 
        trx_cl cl (wrap_ty_in_code n (Btype.newgenvar ())) in
      texp_apply (texp_ident "Trx.build_try") 
        [texp_loc exp.exp_loc;
         texp_pats_names pl names;
         trx_bracket n e;
         trx_case_list_body n binding_pat exp cl
       ]

  | Texp_tuple el ->
      texp_apply (texp_ident "Trx.build_tuple")
        [texp_loc exp.exp_loc; 
	 texp_array (List.map (trx_bracket n) el)]

  | Texp_construct (li, cdesc, args) ->
      let lid = qualify_ctor li cdesc in
      texp_apply (texp_ident "Trx.build_construct")
        [texp_loc exp.exp_loc; 
         texp_lid lid;
	 texp_array (List.map (trx_bracket n) args)]

  | Texp_variant (l,eo) ->              (* polymorphic variant *)
      texp_apply (texp_ident "Trx.build_variant")
        [texp_loc exp.exp_loc; 
         texp_string l;
	 texp_option (map_option (trx_bracket n) eo)]

  | Texp_record {fields;representation=_r;extended_expression} ->
      texp_apply (texp_ident "Trx.build_record")
        [texp_loc exp.exp_loc; 
         texp_array (Array.fold_left (fun acc (ldesc,recd) ->
           match recd with 
           | Kept _ -> acc
           | Overridden (li,e) ->
           texp_tuple [texp_lid (qualify_label li ldesc);
                       trx_bracket n e] :: acc) [] fields);
         texp_option (map_option (trx_bracket n) extended_expression)]

  | Texp_field (e,li,ldesc) ->
      texp_apply (texp_ident "Trx.build_field")
        [texp_loc exp.exp_loc; 
         trx_bracket n e;
         texp_lid (qualify_label li ldesc)]

  | Texp_setfield (e1,li,ldesc,e2) ->
      texp_apply (texp_ident "Trx.build_setfield")
        [texp_loc exp.exp_loc; 
         trx_bracket n e1;
         texp_lid (qualify_label li ldesc);
         trx_bracket n e2]

  | Texp_array el ->
      texp_apply (texp_ident "Trx.build_array")
        [texp_loc exp.exp_loc; 
	 texp_array (List.map (trx_bracket n) el)]

  | Texp_ifthenelse (e,et,efo) ->
      texp_apply (texp_ident "Trx.build_ifthenelse")
        [texp_loc exp.exp_loc; 
         trx_bracket n e;
         trx_bracket n et;
	 texp_option (map_option (trx_bracket n) efo)]

  | Texp_sequence (e1,e2) ->
      texp_apply (texp_ident "Trx.build_sequence")
        [texp_loc exp.exp_loc; 
	 trx_bracket n e1; trx_bracket n e2]
  | Texp_while (e1,e2) ->
      texp_apply (texp_ident "Trx.build_while")
        [texp_loc exp.exp_loc; 
	 trx_bracket n e1; trx_bracket n e2]

  | Texp_for (id, pat, elo, ehi, dir, ebody) ->
      let name =
        begin
          match pat.ppat_desc with
          | Ppat_any -> mknoloc "_for"  (* the typechecker also makes a dummy*)
          | Ppat_var x -> x
          | _  -> assert false
        end
      in
      texp_apply (texp_ident "Trx.build_for") 
        [texp_loc exp.exp_loc;
         texp_string_loc name;
         trx_bracket n elo;
         trx_bracket n ehi;
         texp_bool (dir = Upto);
         let var_typ = wrap_ty_in_code n (Ctype.instance Predef.type_int) in
         let pat = {pat_loc = exp.exp_loc; pat_extra = [];
                    pat_attributes = [];
                    pat_type = var_typ; pat_env = exp.exp_env;
                    pat_desc = Tpat_var (id,name)} in
         { exp with
           exp_desc = 
             Texp_function{arg_label=Nolabel; param=id;
                           cases=[texp_case pat (trx_bracket n ebody)];
                           partial=Total};
           exp_type = 
            {exp.exp_type with desc =
               Tarrow (Nolabel,var_typ, wrap_ty_in_code n ebody.exp_type, Cok)}
         }
       ]

  | Texp_send (e,m,_) ->
      (* We don't check the persistence of the method: after all,
         a method name is somewhat like a polymorphic variant.
         It's perfectly OK to have a function fun x -> x # foo
      *)
      texp_apply (texp_ident "Trx.build_send")
        [texp_loc exp.exp_loc; 
	 trx_bracket n e;
         texp_string (match m with
                        | Tmeth_name name -> name
                        | Tmeth_val id -> Ident.name id)]

  | Texp_new (p,li,_) ->
      check_path_quotable "Class" p;
      texp_code ~node_id:"*new*" exp.exp_loc 
        (Pexp_new (Location.mkloc (path_to_lid p) li.loc))

  | Texp_instvar (_p1,_p2,_s) ->
      not_supported exp.exp_loc "Objects (Texp_instvar)"
        (* Alternatively: since instance variables are always bound 
           at level 0 (for now)
           so this is like a csp variable 
        call_trx_mkcsp exp None (path_to_lid p2)
        *)
  | Texp_setinstvar _ -> not_supported exp.exp_loc "Objects (Texp_setinstvar)"
  | Texp_override  _  -> not_supported exp.exp_loc "Objects (Texp_override)"
  | Texp_letmodule _  -> not_supported exp.exp_loc "let module"

  | Texp_assert e ->
      texp_apply (texp_ident "Trx.build_assert")
        [texp_loc exp.exp_loc; trx_bracket n e]

  | Texp_lazy e ->
      texp_apply (texp_ident "Trx.build_lazy")
        [texp_loc exp.exp_loc; trx_bracket n e]

  | Texp_object (_,_)   -> not_supported exp.exp_loc "Objects"
  | Texp_pack _         -> not_supported exp.exp_loc "First-class modules"
  | Texp_letexception _ -> not_supported exp.exp_loc "Local exceptions"
  | Texp_extension_constructor (_,_) -> 
                           not_supported exp.exp_loc "Type extensions"
  | Texp_unreachable    -> 
      texp_apply (texp_ident "Trx.build_unreachable")
        [texp_loc exp.exp_loc]
  | Texp_letop _       -> not_supported exp.exp_loc "letop"
  | Texp_open ({open_expr={mod_desc=Tmod_ident _}},e)  -> 
      (* The standard let open A.B.C in e 
         Since identifiers are qualified anyway, we don't need it
         in the generated code.
       *)
    (trx_bracket n e).exp_desc
  | Texp_open (_od,_e)   -> not_supported exp.exp_loc "let open general"
       (* general case of let open, when the opened structure is
          a functor application or inlined structure, etc.
        *)
          (*
       check_path_quotable "Texp_open" path;
       texp_apply (texp_ident "Trx.build_open")
        [texp_loc exp.exp_loc;
         texp_lid (mkloc (path_to_lid path) lid.loc);
         texp_csp (Obj.repr ovf);
         exp]      (* exp is the result of trx_bracket *)
           *)  (* | _ -> not_supported exp.exp_loc "not yet supported" *)
  in                               
  (* See untype_extra in tools/untypeast.ml *)
  let trx_extra (extra, loc, _attr) exp =  (* TODO: take care of attr *)
   let desc =
    match extra with
      (* Should check that cty contains only globally declared
         type components
       *)
    (* Type ascriptions:  exp : type
       Note that the type may contain type variables that are shared
       with the code outside the brackets, and these variables maybe unified
       laler on!

       For now we assume that the type is given solely for type-checking
       and documentation purposes, to constrain the type of an expression
       and help type inference -- in the meta-program!
       Once the meta-program is type-checked, the generated code needs
       no annotations. Therefore, we do not generate type ascriptions, at
       present. If this turns out needed, it should be accomplished through
       attributes.
    *)
    | Texp_constraint _cty -> 
        exp.exp_desc
    | Texp_coerce (_cto,_ct) ->
        not_supported loc "Texp_coerce"
    | Texp_poly _cto  -> not_supported loc "Texp_poly"
    | Texp_newtype _s -> 
        (* fun (type t) ->  *)
        not_supported loc "Texp_newtype"
    in {exp with exp_loc = loc; exp_desc = desc} (* type is the same: code *)
  in
  List.fold_right trx_extra exp.exp_extra
  {exp with exp_type = wrap_ty_in_code n exp.exp_type;
            exp_desc = new_desc}


(* First-class patterns: build a match statement from the list
   of clauses. A clause is a literal of the ('a->'w) type, that is,
   (function p -> e | ... | p -> e) or (fun p -> e)
   The user-visible function (in print_code.ml) has the type
     let make_match : 'a code -> ('a -> 'w) Trx.pat_code list -> 'w code
  The function below cannot use 'a code (because it is not defined in the 
  bootstrap compiler) and uses the code repr instead.
*)

let make_match : code_repr -> code_repr list -> code_repr =
  fun[@warning "-8"] scrutinee fns ->
  let (scrutinee::fns,vars) =
    (* Althernatively, use the location from scrutinee *)
    validate_vars_list Location.none (scrutinee::fns)  in
  let case_fn fn acc = 
   let open Parsetree in match fn.pexp_desc with
    | Pexp_function caselist      -> caselist @ acc
    | Pexp_fun (Nolabel,None,p,e) -> {pc_lhs=p;pc_guard=None;pc_rhs=e}::acc
    (* The type of pat_code assured that the match above is exhaustive *)
    | _ -> assert false
  in
  let caselist = List.fold_right case_fn fns [] in
  Code(vars,
   Ast_helper.Exp.match_ ~loc:(scrutinee.pexp_loc) scrutinee caselist)

(* Check to see if exp is a stage-n value 
   See the definition in most LambdaU etc. papers
 *)
let is_value_exp : stage -> Parsetree.expression -> bool = fun stagel exp ->
  let res   = ref true in (* drop to false once detected a non-value *)
  (* stage may be negative when is_value_exp is invoked on the
     contents of brackets, which is the norm.
   *)
  let stage = ref stagel in
  let open Ast_iterator in
  let scan_attrs = List.iter @@ function
  | {attr_name= {txt="metaocaml.bracket"}} -> incr stage
  | {attr_name= {txt="metaocaml.escape"}}  -> decr stage
  | _ -> () 
  in
  let defl = default_iterator in
  let iter = 
     {defl with expr =
       begin
       fun this exp ->
        if !res then  (* if already decided as a non-value, don't recur *)
        let stage_old = !stage in
        scan_attrs (exp.pexp_attributes);   (* may change stage *)
        if !stage < 0 then res := false else (* escape to prev level ... *)
        if !stage > 0 then  (* a code expression is a value *)
           defl.expr this exp   (* scan children *)
        else match exp.pexp_desc with
        (* always values *)
        | Pexp_ident _
        | Pexp_constant _ 
        | Pexp_fun _
        | Pexp_function _
        | Pexp_unreachable 
          -> ()
        (* values if sub-expressions are values *)
        | Pexp_let _
        | Pexp_tuple _
        | Pexp_construct _
        | Pexp_variant _
        | Pexp_record _
        | Pexp_field _
        | Pexp_array _
        | Pexp_coerce _
        | Pexp_constraint _
        | Pexp_send _
        | Pexp_letmodule _
        | Pexp_letexception _
        | Pexp_poly _
        | Pexp_newtype _ 
          -> defl.expr this exp
        | _  -> res := false
        ;
        stage := stage_old
    end}
    in 
    iter.expr iter exp; !res


(* let-insertion *)

(* Check to see that a future-stage expression (given as an AST)
   is not just a value but a value that is cheap to copy and hence
   should not be let-bound and shared. Rather, it should be used
   as it is, literally.
*)

let is_too_cheap_to_let_bind : Parsetree.expression -> bool = fun exp ->
  let res   = ref true in (* drop to false once detected a non-value *)
  let open Ast_iterator in
  (* bracket values are complicated and take storage: not simple *)
  let scan_attrs = List.iter @@ function
  | {attr_name= {txt = "metaocaml.bracket"}} -> res := false
  | {attr_name= {txt = "metaocaml.escape"}}  -> res := false
  | _ -> () 
  in
  let defl = default_iterator in
  let iter = 
     {defl with expr =
       begin
       fun this exp ->
        if !res then  (* if already decided as a non-value, don't recur *)
        let () = scan_attrs (exp.pexp_attributes) in   (* may change res *)
        if !res then  (* if still not decided *)
        match exp.pexp_desc with
        (* always values *)
        | Pexp_ident _
        | Pexp_unreachable 
          -> ()
        | Pexp_constant (Pconst_string _)
          -> res := false               (* strings are not cheap *)
        | Pexp_constant _
          -> ()                         (* integer, float literals are cheap *)
        (* cheap if sub-expressions are cheap *)
         (* | Pexp_construct _    perhaps may be cheap for things like Some 1..
            | Pexp_variant _      and unboxed constructed values
            | Pexp_record _
          *)
        | Pexp_field _
        | Pexp_coerce _
        | Pexp_constraint _
          -> defl.expr this exp
        | _  -> res := false
    end}
    in 
    iter.expr iter exp; !res

(* Locus for genlet binding: code_repr representing a dummy
   free variable. It is to be `virtually' added to the expression
   to le-bind, as if it had occurred there.
 *)
type locus = code_repr

(* Locus corresponding to the `global' scope: let the genlet-bound
   binding rise as high as possible.
   This locus is code_repr that contains no free variables, and hence
   introducing no extra dependencies to the genlet-bound expression.
*)
let locus_global = build_unreachable Location.none 

(* Make sure that user-provided name (hint) is useable as Lident.
   Adjust if needed.
 *)
let name_as_lident : string -> string = 
  String.map @@ function
    | ('a'..'z' as c)
    | ('0'..'9' as c) -> c
    | _             -> 'x'


(* The resulting code_repr represents a value and hence may be given the type
   'a val_code
 *)
let genlet : string -> locus -> code_repr -> code_repr = fun name locus cde ->
  let name = name_as_lident name in
  (* validate_vars_list will build vars that contains free varables of cde
     plus the free variables of locus. This is the way we mix in
     locus' free variable as the dependency to cde
   *)
  match validate_vars_list Location.none [cde;locus] with
  | ([exp;_],((heap,_) as vars)) ->
      if is_too_cheap_to_let_bind exp then cde else
      let freshname = get_fresh_name name vars in
      Code ((heap, [(freshname,Code (vars,exp))]),
        Ast_helper.Exp.ident (mknoloc (Longident.Lident freshname)))
  | _ -> assert false

(* Essentially, as if it were let local_genlet = XXX in k <local_genlet> *)
let with_locus : (locus -> code_repr) -> code_repr = fun k ->
  let (_new_name,vars,exp) =
    with_binding_region Location.none (Location.mknoloc "local_genlet") k in
  Code (vars,exp)

(* The code_repr passed to the continuation
    represents a value and hence may be given type 'a val_code
   It is essentially 
   with_locus (fun locus -> genlet locus exp |> k)
 *)
let genlet_immediate : string -> code_repr -> 
                       (code_repr -> code_repr) -> code_repr = 
  fun name cde k ->
  let name = name_as_lident name in
  let Code (_,exp) = validate_vars Location.none cde in
  if is_too_cheap_to_let_bind exp then k cde else
  build_let_simple_nonrec loc_none (mkloc name exp.pexp_loc) cde k


(*
  Building a let rec expression.
  The difference from build_let is that the names to bind aren't known
  upfront, but are created in the process of running the generator
  (by the k function). As the argument, that function receives genvar-like
  function to create new free variables (all with the same scope).
  The genvar function receives the hint of the name and returns the code
  for the new free variable.
*)
let make_genletrec : 
    ((string -> code_repr) ->           (* genvar function *)
      code_repr *                       (* body of let rec to generate *)
      (code_repr * code_repr) list) ->  (* bindings: (var,exp) pairs, where
                                           var is the code for a free var *) 
    code_repr =
  fun k ->
  let var_exp_pat : Parsetree.expression -> Parsetree.pattern = function
    | {pexp_desc=Pexp_ident {txt=Longident.Lident n;loc}} -> 
      Ast_helper.Pat.var (mkloc n loc)
    | _ -> assert false
  in
  let (_newnames,vars,bindings) =
  with_binding_region_gen Location.none 
      [Location.mknoloc "local_genlet"] (fun locus_var_arr cleanup ->
        let locus_var = locus_var_arr.(0) in
        let genvar name =
          let name = name_as_lident name in
          clone_free_var name locus_var 
        in
        let (body,bindings) = k genvar in
        (* add the body as the first binding *)
        (locus_var,body) :: bindings |>
        List.map (fun (Code (_,v),cde) -> (var_exp_pat v,cleanup cde)) |>
        map_accum 
          (fun varss (vi, Code (vars, expi)) -> 
            ((vi,expi),merge vars varss)) empty |>
        (fun (bs,vars) -> (vars,bs))
     )
  in
  match bindings with
  | [] -> assert false
  (* No bindings were generated while running the body *)
  | [(_,body)] -> Code (vars,body)
  | (_,body)::bindings ->
      Code (vars, Ast_helper.(Exp.let_ Recursive 
             (List.map (fun (pi,expi) -> Vb.mk pi expi) bindings)
             body))

(*{{{ Typedtree traversal to eliminate bracket/escapes *)

(* This part is obsolete *)

(* ------------------------------------------------------------------------ *)
(* Typedtree traversal to eliminate bracket/escapes *)

(* Functions to help traverse and transform a tree.
   We assume that every tree mapping function of the type 'a -> 'a
   throws the exception Not_modified if the tree has not been
   modified.
   This protocol helps minimize garbage and prevent useless tree
   duplication.

   We do not traverse attributes.
*)

(*
exception Not_modified

let replace_list : ('a -> 'a) -> 'a list -> 'a list = fun f l ->
  let rec loop mdf = function
  | [] -> if mdf then [] else raise Not_modified
  | h::t -> match (try Some (f h) with Not_modified -> None) with
             | Some h -> h :: loop true t
             | None   -> h :: loop mdf  t
  in loop false l

let replace_pair : ('a -> 'a) -> ('b -> 'b) -> 'a * 'b -> 'a * 'b =
  fun f g (x,y) ->
  match ((try Some (f x) with Not_modified -> None),
         (try Some (g y) with Not_modified -> None)) with
  | (None,None)      -> raise Not_modified
  | (Some x, None)   -> (x,y)
  | (None, Some y)   -> (x,y)
  | (Some x, Some y) -> (x,y)

let replace_opt : ('a -> 'a) -> 'a option -> 'a option = fun f -> function
  | Some e -> Some (f e)
  | None   -> raise Not_modified

(* The main function to scan the typed tree at the 0 level and
   detect brackets 
*)

let rec trx_struct str =
  {str with str_items = 
  replace_list (fun si -> {si with str_desc = trx_struct_item si.str_desc})
           str.str_items}

and trx_vb_list l = 
  replace_list (fun vb -> {vb with vb_expr = trx_exp vb.vb_expr}) l

and trx_struct_item = function
| Tstr_eval (e,a) -> Tstr_eval (trx_exp e,a)
| Tstr_value (rf,vbl) ->
    Tstr_value(rf, trx_vb_list vbl)
| Tstr_primitive _
| Tstr_type _
| Tstr_typext _
| Tstr_exception _   -> raise Not_modified
| Tstr_module mb     -> Tstr_module (trx_mb mb)
| Tstr_recmodule mbl -> Tstr_recmodule (replace_list trx_mb mbl)
| Tstr_modtype _
| Tstr_open _ -> raise Not_modified
| Tstr_class l ->
    Tstr_class (replace_list (fun (dcl,sl,vf) -> (trx_cdcl dcl,sl,vf)) l)
| Tstr_class_type _ -> raise Not_modified
| Tstr_include id ->
    Tstr_include {id with incl_mod = trx_me id.incl_mod}
| Tstr_attribute _ -> raise Not_modified

and trx_mb mb = 
  {mb with mb_expr = trx_me mb.mb_expr}

and trx_me me = 
  {me with mod_desc = trx_me_desc me.mod_desc} 

and trx_me_desc = function
| Tmod_ident _ -> raise Not_modified
| Tmod_structure str -> Tmod_structure (trx_struct str)
| Tmod_functor (i,l,t,me) -> Tmod_functor (i,l,t, trx_me me)
| Tmod_apply (me1,me2,mc) ->
  let (me1,me2) = replace_pair trx_me trx_me (me1,me2) in
  Tmod_apply (me1, me2, mc)
| Tmod_constraint (me,mt,mtc,mc) -> Tmod_constraint (trx_me me, mt, mtc, mc)
| Tmod_unpack (e,mt) -> Tmod_unpack (trx_exp e,mt)

and trx_cdcl class_decl =
  {class_decl with ci_expr = trx_ce class_decl.ci_expr}

and trx_ce class_expr =
  {class_expr with cl_desc = trx_ce_desc class_expr.cl_desc}

and trx_cl_struct cs =
  {cs with cstr_fields = 
     replace_list (fun cf -> {cf with cf_desc = trx_cf cf.cf_desc})
                  cs.cstr_fields}

and trx_ce_desc = function
| Tcl_ident (_,_,_) -> raise Not_modified
| Tcl_structure cs  -> Tcl_structure (trx_cl_struct cs)
| Tcl_fun (l,p,el,ce,pa) ->
  let (el,ce) = 
        replace_pair (replace_list (fun (i,l,e) -> (i,l,trx_exp e)))
                     trx_ce (el,ce) in
  Tcl_fun (l,p,el,ce,pa)
| Tcl_apply (ce,el) ->
  let repel (l,eo,o) = (l,replace_opt trx_exp eo,o) in
  let (ce,el) = replace_pair trx_ce (replace_list repel) (ce,el) in
  Tcl_apply (ce,el)
| Tcl_let (rf,vbl,el2,ce) ->
  let repel2 = replace_list (fun (i,l,e) -> (i,l,trx_exp e)) in
  let ((vbl,el2),ce) = replace_pair (replace_pair trx_vb_list repel2) trx_ce
                        ((vbl,el2),ce)
  in Tcl_let (rf,vbl,el2,ce)
| Tcl_constraint (ce,ct,sl1,sl2,cty) ->
  Tcl_constraint (trx_ce ce,ct,sl1,sl2,cty)

and trx_cf = function
| Tcf_inherit (ofl,ce,so,sl1,sl2) ->
  Tcf_inherit (ofl,trx_ce ce,so,sl1,sl2)
| Tcf_val (_,_,_,Tcfk_virtual _,_) -> raise Not_modified
| Tcf_val (sl,mf,i,Tcfk_concrete (ovf,e),b) ->
  Tcf_val (sl,mf,i,Tcfk_concrete (ovf,trx_exp e),b)
| Tcf_method (sl,pf,Tcfk_virtual _) -> raise Not_modified
| Tcf_method (sl,pf,Tcfk_concrete (ovf,e)) ->
  Tcf_method (sl,pf,Tcfk_concrete (ovf,trx_exp e))
| Tcf_constraint (_,_) -> raise Not_modified
| Tcf_initializer e -> Tcf_initializer (trx_exp e)
| Tcf_attribute _ -> raise Not_modified

and trx_exp exp =
  {exp with exp_desc = trx_expression exp.exp_desc}

and trx_caselist l = replace_list (fun cas -> 
   let (g,rhs) = replace_pair (replace_opt trx_exp) trx_exp 
                     (cas.c_guard,cas.c_rhs) in
   {cas with c_guard = g; c_rhs = rhs}) 
 l

and trx_expression = function
| Texp_ident (_,_,_)
| Texp_constant _ -> raise Not_modified
| Texp_let (rf, vbl, e) ->
  let (vbl,e) = replace_pair trx_vb_list trx_exp (vbl,e)
  in Texp_let (rf, vbl, e)
| Texp_function (l,cl,p) ->
  Texp_function (l,trx_caselist cl,p)
| Texp_apply (e,el) ->
  let repl (l,eo,op) = (l,replace_opt trx_exp eo,op) in
  let (e,el) = replace_pair trx_exp (replace_list repl) (e,el)
  in Texp_apply (e,el)
| Texp_match (e,cl1,cl2,p) ->
  let (e,(cl1,cl2)) = replace_pair 
     trx_exp (replace_pair trx_caselist trx_caselist) (e,(cl1,cl2))
  in Texp_match (e,cl1,cl2,p)
| Texp_try (e,cl) ->
  let (e,cl) = replace_pair trx_exp trx_caselist (e,cl)
  in Texp_try (e,cl)
| Texp_tuple l -> Texp_tuple (replace_list trx_exp l)
| Texp_construct (l,cd,el) ->
  Texp_construct (l,cd,replace_list trx_exp el)
| Texp_variant (l,eo) -> Texp_variant (l,replace_opt trx_exp eo)
| Texp_record (ll,eo) ->
  let repll (l,ld,e) = (l,ld,trx_exp e) in
  let (ll,eo) = replace_pair (replace_list repll) (replace_opt trx_exp) (ll,eo)
  in Texp_record (ll,eo)
| Texp_field (e,l,ld) -> Texp_field (trx_exp e,l,ld)
| Texp_setfield (e1,l,ld,e2) ->
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_setfield (e1,l,ld,e2)
| Texp_array el -> Texp_array (replace_list trx_exp el)
| Texp_ifthenelse (e1,e2,eo) ->
  let ((e1,e2),eo) = replace_pair (replace_pair trx_exp trx_exp) 
                                  (replace_opt trx_exp) ((e1,e2),eo)
  in Texp_ifthenelse (e1,e2,eo)
| Texp_sequence (e1,e2) -> 
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_sequence (e1,e2)
| Texp_while (e1,e2) ->
  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
  in Texp_while (e1,e2)
| Texp_for (i,p,e1,e2,df,e3) ->
  let ((e1,e2),e3) = replace_pair (replace_pair trx_exp trx_exp) 
                                  trx_exp ((e1,e2),e3)
  in Texp_for (i,p,e1,e2,df,e3)
| Texp_send (e1,m,eo) ->
  let (e1,eo) = replace_pair trx_exp (replace_opt trx_exp) (e1,eo)
  in Texp_send (e1,m,eo)
| Texp_new (_,_,_)
| Texp_instvar (_,_,_) -> raise Not_modified
| Texp_setinstvar (p1,p2,l,e) -> Texp_setinstvar (p1,p2,l,trx_exp e)
| Texp_override (p, el) ->
  Texp_override (p, replace_list (fun (p,l,e) -> (p,l,trx_exp e)) el)
| Texp_letmodule (i,l,me,e) ->
  let (me,e) = replace_pair trx_me trx_exp (me,e)
  in Texp_letmodule (i,l,me,e)
| Texp_assert e -> Texp_assert (trx_exp e)
| Texp_lazy e -> Texp_lazy (trx_exp e)
| Texp_object (cs,sl) -> Texp_object (trx_cl_struct cs,sl)
| Texp_pack me -> Texp_pack (trx_me me)
(*
| Texp_bracket e -> 
   let trx_exp e = try trx_exp e with Not_modified -> e in
  (trx_bracket trx_exp 1 e).exp_desc

| Texp_escape _ -> assert false         (* Not possible in well-typed code *)
| Texp_cspval (_,_) -> raise Not_modified
*)


(* public interface *)
let trx_structure str = 
  try trx_struct str with Not_modified -> str
*)

(*}}}*)

  
